
namei.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <get_write_access>:
acl_by_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:2333
 * except for the cases where we don't hold i_writecount yet. Then we need to
 * use {get,deny}_write_access() - these functions check the sign and refuse
 * to do the change if sign is wrong.
 */
static inline int get_write_access(struct inode *inode)
{
       0:	push   %rbp
       1:	lea    0x138(%rdi),%rcx
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:67

#ifndef atomic_inc_unless_negative
static inline int atomic_inc_unless_negative(atomic_t *p)
{
	int v, v1;
	for (v = 0; v >= 0; v = v1) {
       8:	xor    %edx,%edx
get_write_access():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:2333
       a:	mov    %rsp,%rbp
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:68
		v1 = atomic_cmpxchg(p, v, v + 1);
       d:	lea    0x1(%rdx),%esi
atomic_cmpxchg():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/atomic.h:176
#define atomic_inc_return(v)  (atomic_add_return(1, v))
#define atomic_dec_return(v)  (atomic_sub_return(1, v))

static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
{
	return cmpxchg(&v->counter, old, new);
      10:	mov    %edx,%eax
      12:	lock cmpxchg %esi,(%rcx)
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:69
		if (likely(v1 == v))
      16:	cmp    %eax,%edx
      18:	jne    1e <get_write_access+0x1e>
get_write_access():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:2334
	return atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;
      1a:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:2335
}
      1c:	pop    %rbp
      1d:	retq   
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:67

#ifndef atomic_inc_unless_negative
static inline int atomic_inc_unless_negative(atomic_t *p)
{
	int v, v1;
	for (v = 0; v >= 0; v = v1) {
      1e:	test   %eax,%eax
      20:	jns    29 <get_write_access+0x29>
get_write_access():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:2334
 * use {get,deny}_write_access() - these functions check the sign and refuse
 * to do the change if sign is wrong.
 */
static inline int get_write_access(struct inode *inode)
{
	return atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;
      22:	mov    $0xffffffe6,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:2335
}
      27:	pop    %rbp
      28:	retq   
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:67
      29:	mov    %eax,%edx
      2b:	jmp    d <get_write_access+0xd>
lookup_slow():
      2d:	nopl   (%rax)

0000000000000030 <dget>:
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:359
		dentry->d_lockref.count++;
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
      30:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
  MY_PRINTK(get_current()->comm);
      31:	mov    $0x0,%rdx
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
      38:	mov    %gs:0x0,%rcx
lookup_slow():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:359
		dentry->d_lockref.count++;
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
      41:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
  MY_PRINTK(get_current()->comm);
      44:	add    $0x4a8,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:359
		dentry->d_lockref.count++;
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
      4b:	push   %rbx
      4c:	mov    %rdi,%rbx
      4f:	jmp    5d <dget+0x2d>
      51:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
      58:	test   %sil,%sil
      5b:	je     c0 <dget+0x90>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
      5d:	add    $0x1,%rcx
      61:	movzbl -0x1(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
      65:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
      69:	cmp    -0x1(%rdx),%sil
      6d:	je     58 <dget+0x28>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
      6f:	mov    %gs:0x0,%rcx
lookup_slow():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
  MY_PRINTK(get_current()->comm);
      78:	mov    $0x0,%rdx
      7f:	add    $0x4a8,%rcx
      86:	jmp    95 <dget+0x65>
      88:	nopl   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
      90:	test   %sil,%sil
      93:	je     c0 <dget+0x90>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
      95:	add    $0x1,%rcx
      99:	movzbl -0x1(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
      9d:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
      a1:	cmp    -0x1(%rdx),%sil
      a5:	je     90 <dget+0x60>
lookup_slow():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
      a7:	test   %rbx,%rbx
      aa:	je     b5 <dget+0x85>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
      ac:	lea    0x58(%rbx),%rdi
walk_component():
      b0:	callq  b5 <dget+0x85>
vfs_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:364
	return dentry;
}
      b5:	mov    %rbx,%rax
      b8:	pop    %rbx
      b9:	pop    %rbp
      ba:	retq   
      bb:	nopl   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
      c0:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
      c9:	mov    $0x0,%rsi
      d0:	add    $0x4a8,%rdx
      d7:	mov    $0x0,%rdi
      de:	xor    %eax,%eax
      e0:	callq  e5 <dget+0xb5>
      e5:	jmp    a7 <dget+0x77>
      e7:	nopw   0x0(%rax,%rax,1)

00000000000000f0 <lookup_real>:
lookup_real():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1331
	struct dentry *old;

	/* Don't create child dentry for a dead directory. */
	if (unlikely(IS_DEADDIR(dir))) {
		dput(dentry);
		return ERR_PTR(-ENOENT);
      f0:	callq  f5 <lookup_real+0x5>
      f5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1332
	}
      f6:	mov    $0x0,%rcx
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
      fd:	mov    %gs:0x0,%r8
lookup_real():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1331
	struct dentry *old;

	/* Don't create child dentry for a dead directory. */
	if (unlikely(IS_DEADDIR(dir))) {
		dput(dentry);
		return ERR_PTR(-ENOENT);
     106:	mov    %rsp,%rbp
     109:	push   %r13
     10b:	mov    %edx,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1332
	}
     10e:	add    $0x4a8,%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1331
	struct dentry *old;

	/* Don't create child dentry for a dead directory. */
	if (unlikely(IS_DEADDIR(dir))) {
		dput(dentry);
		return ERR_PTR(-ENOENT);
     115:	push   %r12
     117:	mov    %rsi,%r12
     11a:	push   %rbx
     11b:	mov    %rdi,%rbx
     11e:	sub    $0x8,%rsp
     122:	jmp    12d <lookup_real+0x3d>
     124:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
     128:	test   %r9b,%r9b
     12b:	je     1a0 <lookup_real+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
     12d:	add    $0x1,%r8
     131:	movzbl -0x1(%r8),%r9d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
     136:	add    $0x1,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
     13a:	cmp    -0x1(%rcx),%r9b
     13e:	je     128 <lookup_real+0x38>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
     140:	mov    %gs:0x0,%r8
lookup_real():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1332
	}
     149:	mov    $0x0,%rcx
     150:	add    $0x4a8,%r8
     157:	jmp    165 <lookup_real+0x75>
     159:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
     160:	test   %r9b,%r9b
     163:	je     1a0 <lookup_real+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
     165:	add    $0x1,%r8
     169:	movzbl -0x1(%r8),%r9d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
     16e:	add    $0x1,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
     172:	cmp    -0x1(%rcx),%r9b
     176:	je     160 <lookup_real+0x70>
lookup_real():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1337

	old = dir->i_op->lookup(dir, dentry, flags);
	if (unlikely(old)) {
		dput(dentry);
		dentry = old;
     178:	testb  $0x10,0xc(%rbx)
     17c:	jne    1d9 <lookup_real+0xe9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1342
	}
	return dentry;
}

static struct dentry *__lookup_hash(struct qstr *name, struct dentry *base, unsigned int flags)
     17e:	mov    0x20(%rbx),%rax
     182:	mov    %r13d,%edx
     185:	mov    %r12,%rsi
     188:	mov    %rbx,%rdi
     18b:	callq  *(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1343
{
     18d:	test   %rax,%rax
     190:	jne    1c7 <lookup_real+0xd7>
     192:	mov    %r12,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1348
	bool need_lookup;
	struct dentry *dentry;

	dentry = lookup_dcache(name, base, flags, &need_lookup);
	if (!need_lookup)
     195:	add    $0x8,%rsp
     199:	pop    %rbx
     19a:	pop    %r12
     19c:	pop    %r13
     19e:	pop    %rbp
     19f:	retq   
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
     1a0:	mov    %gs:0x0,%rdx
lookup_real():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1332

	/* Don't create child dentry for a dead directory. */
	if (unlikely(IS_DEADDIR(dir))) {
		dput(dentry);
		return ERR_PTR(-ENOENT);
	}
     1a9:	mov    $0x0,%rsi
     1b0:	add    $0x4a8,%rdx
     1b7:	mov    $0x0,%rdi
     1be:	xor    %eax,%eax
     1c0:	callq  1c5 <lookup_real+0xd5>
     1c5:	jmp    178 <lookup_real+0x88>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1344
	return dentry;
}

static struct dentry *__lookup_hash(struct qstr *name, struct dentry *base, unsigned int flags)
{
	bool need_lookup;
     1c7:	mov    %r12,%rdi
     1ca:	mov    %rax,-0x20(%rbp)
     1ce:	callq  1d3 <lookup_real+0xe3>
     1d3:	mov    -0x20(%rbp),%rax
     1d7:	jmp    195 <lookup_real+0xa5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1338

	old = dir->i_op->lookup(dir, dentry, flags);
	if (unlikely(old)) {
		dput(dentry);
		dentry = old;
	}
     1d9:	mov    %r12,%rdi
     1dc:	callq  1e1 <lookup_real+0xf1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1339
	return dentry;
     1e1:	mov    $0xfffffffffffffffe,%rax
     1e8:	jmp    195 <lookup_real+0xa5>
     1ea:	nopw   0x0(%rax,%rax,1)

00000000000001f0 <path_put>:
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:487
 * Given a path decrement the reference count to the dentry and the vfsmount.
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
     1f0:	callq  1f5 <path_put+0x5>
     1f5:	push   %rbp
     1f6:	mov    %rsp,%rbp
     1f9:	push   %rbx
     1fa:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
}
     1fd:	mov    0x8(%rdi),%rdi
     201:	callq  206 <path_put+0x16>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
     206:	mov    (%rbx),%rdi
     209:	callq  20e <path_put+0x1e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:490

     20e:	pop    %rbx
     20f:	pop    %rbp
     210:	retq   
     211:	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000000220 <put_link>:
put_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:704

static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
{
	struct inode *inode = link->dentry->d_inode;
	if (inode->i_op->put_link)
		inode->i_op->put_link(link->dentry, nd, cookie);
     220:	push   %rbp
     221:	mov    %rdi,%r8
     224:	mov    %rsp,%rbp
     227:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:705
	path_put(link);
     228:	mov    0x8(%rsi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:704

static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
{
	struct inode *inode = link->dentry->d_inode;
	if (inode->i_op->put_link)
		inode->i_op->put_link(link->dentry, nd, cookie);
     22c:	mov    %rsi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:706
	path_put(link);
}
     22f:	mov    0x30(%rax),%rcx
     233:	mov    %rax,%rdi
     236:	mov    0x20(%rcx),%rcx
     23a:	mov    0x28(%rcx),%rcx
     23e:	test   %rcx,%rcx
     241:	je     24c <put_link+0x2c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:707

     243:	mov    %r8,%rsi
     246:	callq  *%rcx
     248:	mov    0x8(%rbx),%rdi
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
     24c:	callq  251 <put_link+0x31>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
     251:	mov    (%rbx),%rdi
     254:	callq  259 <put_link+0x39>
put_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:709
		inode->i_op->put_link(link->dentry, nd, cookie);
	path_put(link);
}

int sysctl_protected_symlinks __read_mostly = 0;
int sysctl_protected_hardlinks __read_mostly = 0;
     259:	pop    %rbx
     25a:	pop    %rbp
     25b:	retq   
     25c:	nopl   0x0(%rax)

0000000000000260 <follow_up>:
follow_up():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:919
int follow_up(struct path *path)
{
	struct mount *mnt = real_mount(path->mnt);
	struct mount *parent;
	struct dentry *mountpoint;

     260:	callq  265 <follow_up+0x5>
     265:	push   %rbp
     266:	mov    %rsp,%rbp
     269:	push   %r13
     26b:	push   %r12
     26d:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:920
	read_seqlock_excl(&mount_lock);
     26e:	mov    (%rdi),%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:919
int follow_up(struct path *path)
{
	struct mount *mnt = real_mount(path->mnt);
	struct mount *parent;
	struct dentry *mountpoint;

     271:	mov    %rdi,%rbx
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     274:	mov    $0x0,%rdi
     27b:	callq  280 <follow_up+0x20>
follow_up():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:925
	read_seqlock_excl(&mount_lock);
	parent = mnt->mnt_parent;
	if (parent == mnt) {
		read_sequnlock_excl(&mount_lock);
		return 0;
	}
     280:	mov    -0x10(%r12),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:920
{
	struct mount *mnt = real_mount(path->mnt);
	struct mount *parent;
	struct dentry *mountpoint;

	read_seqlock_excl(&mount_lock);
     285:	lea    -0x20(%r12),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:926
	parent = mnt->mnt_parent;
	if (parent == mnt) {
		read_sequnlock_excl(&mount_lock);
		return 0;
	}
	mntget(&parent->mnt);
     28a:	cmp    %rax,%rdi
     28d:	je     2e8 <follow_up+0x88>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:930
	// mountpoint = dget(mnt->mnt_mountpoint);
	mountpoint = msg_dget(mnt->mnt_mountpoint, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	read_sequnlock_excl(&mount_lock);
	dput(path->dentry);
     28f:	lea    0x20(%rdi),%r13
     293:	mov    %r13,%rdi
     296:	callq  29b <follow_up+0x3b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:932
	path->dentry = mountpoint;
	mntput(path->mnt);
     29b:	mov    0x0(%rip),%edx        # 2a1 <follow_up+0x41>
     2a1:	mov    0x0(%rip),%esi        # 2a7 <follow_up+0x47>
     2a7:	mov    -0x8(%r12),%rdi
     2ac:	callq  2b1 <follow_up+0x51>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
     2b1:	mov    $0x0,%rdi
follow_up():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:932
     2b8:	mov    %rax,%r12
read_sequnlock_excl():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
     2bb:	callq  2c0 <follow_up+0x60>
follow_up():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:934
	path->mnt = &parent->mnt;
	return 1;
     2c0:	mov    0x8(%rbx),%rdi
     2c4:	callq  2c9 <follow_up+0x69>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:936
}

     2c9:	mov    (%rbx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:935
	dput(path->dentry);
	path->dentry = mountpoint;
	mntput(path->mnt);
	path->mnt = &parent->mnt;
	return 1;
}
     2cc:	mov    %r12,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:936

     2d0:	callq  2d5 <follow_up+0x75>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:937
/*
     2d5:	mov    %r13,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:938
 * Perform an automount
     2d8:	mov    $0x1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:939
 * - return -EISDIR to tell follow_managed() to stop and return the path we
     2dd:	pop    %rbx
     2de:	pop    %r12
     2e0:	pop    %r13
     2e2:	pop    %rbp
     2e3:	retq   
     2e4:	nopl   0x0(%rax)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
     2e8:	mov    $0x0,%rdi
     2ef:	callq  2f4 <follow_up+0x94>
follow_up():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:939
     2f4:	pop    %rbx
     2f5:	pop    %r12
     2f7:	pop    %r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:928
		read_sequnlock_excl(&mount_lock);
		return 0;
	}
	mntget(&parent->mnt);
	// mountpoint = dget(mnt->mnt_mountpoint);
	mountpoint = msg_dget(mnt->mnt_mountpoint, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
     2f9:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:939
	return 1;
}

/*
 * Perform an automount
 * - return -EISDIR to tell follow_managed() to stop and return the path we
     2fb:	pop    %rbp
     2fc:	retq   
     2fd:	nopl   (%rax)

0000000000000300 <follow_down>:
follow_down():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1200
	unsigned managed;
	int ret;

	while (managed = ACCESS_ONCE(path->dentry->d_flags),
	       unlikely(managed & DCACHE_MANAGED_DENTRY)) {
		/* Allow the filesystem to manage the transit without i_mutex
     300:	callq  305 <follow_down+0x5>
     305:	push   %rbp
     306:	mov    %rsp,%rbp
     309:	push   %r12
     30b:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1204
		 * being held.
		 *
		 * We indicate to the filesystem if someone is trying to mount
		 * something here.  This gives autofs the chance to deny anyone
     30c:	mov    0x8(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1200
	unsigned managed;
	int ret;

	while (managed = ACCESS_ONCE(path->dentry->d_flags),
	       unlikely(managed & DCACHE_MANAGED_DENTRY)) {
		/* Allow the filesystem to manage the transit without i_mutex
     310:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1204
		 * being held.
		 *
		 * We indicate to the filesystem if someone is trying to mount
		 * something here.  This gives autofs the chance to deny anyone
     313:	mov    (%rax),%r12d
     316:	test   $0x70000,%r12d
     31d:	jne    326 <follow_down+0x26>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1240
}

/*
 * Skip to top of mountpoint pile in refwalk mode for follow_dotdot()
 */
static void follow_mount(struct path *path)
     31f:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1241
{
     321:	pop    %rbx
     322:	pop    %r12
     324:	pop    %rbp
     325:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1216
			BUG_ON(!path->dentry->d_op);
			BUG_ON(!path->dentry->d_op->d_manage);
			ret = path->dentry->d_op->d_manage(
				path->dentry, false);
			if (ret < 0)
				return ret == -EISDIR ? 0 : ret;
     326:	test   $0x40000,%r12d
     32d:	je     34e <follow_down+0x4e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1217
		}
     32f:	mov    0x60(%rax),%rdx
     333:	test   %rdx,%rdx
     336:	je     3a2 <follow_down+0xa2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1218

     338:	mov    0x50(%rdx),%rdx
     33c:	test   %rdx,%rdx
     33f:	je     3a0 <follow_down+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1219
		/* Transit to a mounted filesystem. */
     341:	xor    %esi,%esi
     343:	mov    %rax,%rdi
     346:	callq  *%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1221
		if (managed & DCACHE_MOUNTED) {
			struct vfsmount *mounted = lookup_mnt(path);
     348:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1219
				path->dentry, false);
			if (ret < 0)
				return ret == -EISDIR ? 0 : ret;
		}

		/* Transit to a mounted filesystem. */
     34a:	mov    %eax,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1221
		if (managed & DCACHE_MOUNTED) {
			struct vfsmount *mounted = lookup_mnt(path);
     34c:	js     396 <follow_down+0x96>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1226
			if (!mounted)
				break;
			dput(path->dentry);
			mntput(path->mnt);
			path->mnt = mounted;
     34e:	and    $0x10000,%r12d
     355:	je     31f <follow_down+0x1f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1227
			path->dentry = dget(mounted->mnt_root);
     357:	mov    %rbx,%rdi
     35a:	callq  35f <follow_down+0x5f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1228
			continue;
     35f:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1227
			if (!mounted)
				break;
			dput(path->dentry);
			mntput(path->mnt);
			path->mnt = mounted;
			path->dentry = dget(mounted->mnt_root);
     362:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1228
			continue;
     365:	je     31f <follow_down+0x1f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1230
		}

     367:	mov    0x8(%rbx),%rdi
     36b:	callq  370 <follow_down+0x70>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1231
		/* Don't handle automount points here */
     370:	mov    (%rbx),%rdi
     373:	callq  378 <follow_down+0x78>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1232
		break;
     378:	mov    %r12,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1233
	}
     37b:	mov    (%r12),%rdi
     37f:	callq  30 <dget>
     384:	mov    %rax,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1204
	       unlikely(managed & DCACHE_MANAGED_DENTRY)) {
		/* Allow the filesystem to manage the transit without i_mutex
		 * being held.
		 *
		 * We indicate to the filesystem if someone is trying to mount
		 * something here.  This gives autofs the chance to deny anyone
     388:	mov    (%rax),%r12d
     38b:	test   $0x70000,%r12d
     392:	je     31f <follow_down+0x1f>
     394:	jmp    326 <follow_down+0x26>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1222
		}

		/* Transit to a mounted filesystem. */
		if (managed & DCACHE_MOUNTED) {
			struct vfsmount *mounted = lookup_mnt(path);
			if (!mounted)
     396:	xor    %eax,%eax
     398:	cmp    $0xffffffeb,%edx
     39b:	cmovne %edx,%eax
     39e:	jmp    321 <follow_down+0x21>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1218 (discriminator 1)
			ret = path->dentry->d_op->d_manage(
				path->dentry, false);
			if (ret < 0)
				return ret == -EISDIR ? 0 : ret;
		}

     3a0:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1217 (discriminator 1)
			BUG_ON(!path->dentry->d_op->d_manage);
			ret = path->dentry->d_op->d_manage(
				path->dentry, false);
			if (ret < 0)
				return ret == -EISDIR ? 0 : ret;
		}
     3a2:	ud2    
     3a4:	data32 data32 nopw %cs:0x0(%rax,%rax,1)

00000000000003b0 <unlock_rename>:
unlock_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2501
	if (error)
		return error;
	error = dir->i_op->create(dir, dentry, mode, want_excl);
	if (!error)
		fsnotify_create(dir, dentry);
	return error;
     3b0:	callq  3b5 <unlock_rename+0x5>
     3b5:	push   %rbp
     3b6:	mov    %rsp,%rbp
     3b9:	push   %r12
     3bb:	mov    %rsi,%r12
     3be:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2502
}
     3bf:	mov    0x30(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2501
	if (error)
		return error;
	error = dir->i_op->create(dir, dentry, mode, want_excl);
	if (!error)
		fsnotify_create(dir, dentry);
	return error;
     3c3:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2502
}
     3c6:	lea    0xa8(%rax),%rdi
     3cd:	callq  3d2 <unlock_rename+0x22>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2503

     3d2:	cmp    %r12,%rbx
     3d5:	je     3fc <unlock_rename+0x4c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2504
static int may_open(struct path *path, int acc_mode, int flag)
     3d7:	mov    0x30(%r12),%rdi
     3dc:	add    $0xa8,%rdi
     3e3:	callq  3e8 <unlock_rename+0x38>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2505
{
     3e8:	mov    0x30(%rbx),%rax
     3ec:	mov    0x28(%rax),%rdi
     3f0:	add    $0x310,%rdi
     3f7:	callq  3fc <unlock_rename+0x4c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2507
	struct dentry *dentry = path->dentry;
	struct inode *inode = dentry->d_inode;
     3fc:	pop    %rbx
     3fd:	pop    %r12
     3ff:	pop    %rbp
     400:	retq   
     401:	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000000410 <complete_walk>:
complete_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:605
 * need to drop nd->path.
 */
static int complete_walk(struct nameidata *nd)
{
	struct dentry *dentry = nd->path.dentry;
	int status;
     410:	callq  415 <complete_walk+0x5>
     415:	push   %rbp
     416:	mov    %rsp,%rbp
     419:	push   %r12
     41b:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:609

	if (nd->flags & LOOKUP_RCU) {
		nd->flags &= ~LOOKUP_RCU;
		if (!(nd->flags & LOOKUP_ROOT))
     41c:	mov    0x38(%rdi),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:605
 * need to drop nd->path.
 */
static int complete_walk(struct nameidata *nd)
{
	struct dentry *dentry = nd->path.dentry;
	int status;
     41f:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:606

     422:	mov    0x8(%rdi),%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:609
	if (nd->flags & LOOKUP_RCU) {
		nd->flags &= ~LOOKUP_RCU;
		if (!(nd->flags & LOOKUP_ROOT))
     426:	test   $0x40,%sil
     42a:	je     46e <complete_walk+0x5e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:610
			nd->root.mnt = NULL;
     42c:	mov    %esi,%eax
     42e:	and    $0xffffffbf,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:611

     431:	and    $0x2000,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:610
	int status;

	if (nd->flags & LOOKUP_RCU) {
		nd->flags &= ~LOOKUP_RCU;
		if (!(nd->flags & LOOKUP_ROOT))
			nd->root.mnt = NULL;
     437:	mov    %eax,0x38(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:611

     43a:	jne    444 <complete_walk+0x34>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:612
		if (!legitimize_mnt(nd->path.mnt, nd->m_seq)) {
     43c:	movq   $0x0,0x20(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:614
			rcu_read_unlock();
			return -ECHILD;
     444:	mov    0x40(%rbx),%esi
     447:	mov    (%rbx),%rdi
     44a:	callq  44f <complete_walk+0x3f>
     44f:	test   %al,%al
     451:	je     480 <complete_walk+0x70>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:618
		}
		if (unlikely(!lockref_get_not_dead(&dentry->d_lockref))) {
			rcu_read_unlock();
			mntput(nd->path.mnt);
     453:	lea    0x58(%r12),%rdi
     458:	callq  45d <complete_walk+0x4d>
     45d:	test   %eax,%eax
     45f:	je     4c3 <complete_walk+0xb3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:623
			return -ECHILD;
		}
		if (read_seqcount_retry(&dentry->d_seq, nd->seq)) {
			rcu_read_unlock();
			dput(dentry);
     461:	mov    0x3c(%rbx),%eax
     464:	cmp    0x4(%r12),%eax
     469:	jne    4d2 <complete_walk+0xc2>
__rcu_read_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/rcupdate.h:203
	preempt_disable();
}

static inline void __rcu_read_unlock(void)
{
	preempt_enable();
     46b:	mov    0x38(%rbx),%esi
complete_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:632
		rcu_read_unlock();
	}

	if (likely(!(nd->flags & LOOKUP_JUMPED)))
		return 0;

     46e:	test   $0x1000,%esi
     474:	jne    487 <complete_walk+0x77>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:633
	if (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))
     476:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:647

	path_put(&nd->path);
	return status;
}

static __always_inline void set_root(struct nameidata *nd)
     478:	pop    %rbx
     479:	pop    %r12
     47b:	pop    %rbp
     47c:	retq   
     47d:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:616

		if (!legitimize_mnt(nd->path.mnt, nd->m_seq)) {
			rcu_read_unlock();
			return -ECHILD;
		}
		if (unlikely(!lockref_get_not_dead(&dentry->d_lockref))) {
     480:	mov    $0xfffffff6,%eax
     485:	jmp    478 <complete_walk+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:635
	if (likely(!(nd->flags & LOOKUP_JUMPED)))
		return 0;

	if (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))
		return 0;

     487:	testl  $0x800,(%r12)
     48f:	je     476 <complete_walk+0x66>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:638
	status = dentry->d_op->d_weak_revalidate(dentry, nd->flags);
	if (status > 0)
		return 0;
     491:	mov    0x60(%r12),%rax
     496:	mov    %r12,%rdi
     499:	callq  *0x8(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:639

     49c:	cmp    $0x0,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:638
	if (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))
		return 0;

	status = dentry->d_op->d_weak_revalidate(dentry, nd->flags);
	if (status > 0)
		return 0;
     49f:	mov    %eax,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:639

     4a2:	jg     476 <complete_walk+0x66>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
     4a4:	mov    0x8(%rbx),%rdi
complete_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:643
		return 0;

	if (!status)
		status = -ESTALE;

	path_put(&nd->path);
     4a8:	mov    $0xffffff8c,%eax
     4ad:	cmove  %eax,%r12d
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
     4b1:	callq  4b6 <complete_walk+0xa6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
     4b6:	mov    (%rbx),%rdi
     4b9:	callq  4be <complete_walk+0xae>
complete_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:646
		status = -ESTALE;

	path_put(&nd->path);
	return status;
}

     4be:	mov    %r12d,%eax
     4c1:	jmp    478 <complete_walk+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:620
		}
		if (unlikely(!lockref_get_not_dead(&dentry->d_lockref))) {
			rcu_read_unlock();
			mntput(nd->path.mnt);
			return -ECHILD;
		}
     4c3:	mov    (%rbx),%rdi
     4c6:	callq  4cb <complete_walk+0xbb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:621
		if (read_seqcount_retry(&dentry->d_seq, nd->seq)) {
     4cb:	mov    $0xfffffff6,%eax
     4d0:	jmp    478 <complete_walk+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:625
			rcu_read_unlock();
			dput(dentry);
			mntput(nd->path.mnt);
			return -ECHILD;
     4d2:	mov    %r12,%rdi
     4d5:	callq  4da <complete_walk+0xca>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:626
		}
     4da:	mov    (%rbx),%rdi
     4dd:	callq  4e2 <complete_walk+0xd2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:627
		rcu_read_unlock();
     4e2:	mov    $0xfffffff6,%eax
     4e7:	jmp    478 <complete_walk+0x68>
     4e9:	nopl   0x0(%rax)

00000000000004f0 <follow_managed>:
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1027
{
	struct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */
	unsigned managed;
	bool need_mntput = false;
	int ret = 0;

     4f0:	callq  4f5 <follow_managed+0x5>
     4f5:	push   %rbp
     4f6:	mov    %esi,%ecx
     4f8:	mov    %rsp,%rbp
     4fb:	push   %r15
     4fd:	push   %r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1031
	/* Given that we're not holding a lock here, we retain the value in a
	 * local variable for each dentry as we look at it so that we don't see
	 * the components of that value change under us */
	while (managed = ACCESS_ONCE(path->dentry->d_flags),
     4ff:	xor    %r14d,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1027
{
	struct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */
	unsigned managed;
	bool need_mntput = false;
	int ret = 0;

     502:	push   %r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1030
	/* Given that we're not holding a lock here, we retain the value in a
	 * local variable for each dentry as we look at it so that we don't see
	 * the components of that value change under us */
     504:	xor    %r13d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1027
{
	struct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */
	unsigned managed;
	bool need_mntput = false;
	int ret = 0;

     507:	push   %r12
     509:	mov    %rdi,%r12
     50c:	push   %rbx
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
     50d:	mov    %gs:0x0,%rbx
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1027
     516:	sub    $0x30,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1028
	/* Given that we're not holding a lock here, we retain the value in a
     51a:	mov    (%rdi),%rdx
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
     51d:	mov    %rbx,%r10
     520:	mov    %rbx,%r9
     523:	mov    %rbx,%r8
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1036 (discriminator 1)
	while (managed = ACCESS_ONCE(path->dentry->d_flags),
	       managed &= DCACHE_MANAGED_DENTRY,
	       unlikely(managed != 0)) {
		/* Allow the filesystem to manage the transit without i_mutex
		 * being held. */
		if (managed & DCACHE_MANAGE_TRANSIT) {
     526:	mov    0x8(%r12),%rdi
     52b:	mov    (%rdi),%r15d
     52e:	test   $0x70000,%r15d
     535:	jne    572 <follow_managed+0x82>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1080
	if (need_mntput && path->mnt == mnt)
		mntput(path->mnt);
	if (ret == -EISDIR)
		ret = 0;
	return ret < 0 ? ret : need_mntput;
}
     537:	test   %r13b,%r13b
     53a:	je     542 <follow_managed+0x52>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1080 (discriminator 1)
     53c:	cmp    %rdx,(%r12)
     540:	je     568 <follow_managed+0x78>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1082

int follow_down_one(struct path *path)
     542:	cmp    $0xffffffeb,%r14d
     546:	je     550 <follow_managed+0x60>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1084
{
	struct vfsmount *mounted;
     548:	test   %r14d,%r14d
     54b:	mov    %r14d,%eax
     54e:	js     554 <follow_managed+0x64>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1084 (discriminator 1)
     550:	movzbl %r13b,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1085

     554:	add    $0x30,%rsp
     558:	pop    %rbx
     559:	pop    %r12
     55b:	pop    %r13
     55d:	pop    %r14
     55f:	pop    %r15
     561:	pop    %rbp
     562:	retq   
     563:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1081
		mntput(path->mnt);
	if (ret == -EISDIR)
		ret = 0;
	return ret < 0 ? ret : need_mntput;
}

     568:	mov    %rdx,%rdi
     56b:	callq  570 <follow_managed+0x80>
     570:	jmp    542 <follow_managed+0x52>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1041
		if (managed & DCACHE_MANAGE_TRANSIT) {
			BUG_ON(!path->dentry->d_op);
			BUG_ON(!path->dentry->d_op->d_manage);
			ret = path->dentry->d_op->d_manage(path->dentry, false);
			if (ret < 0)
				break;
     572:	test   $0x40000,%r15d
     579:	je     5cb <follow_managed+0xdb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1042
		}
     57b:	mov    0x60(%rdi),%rsi
     57f:	test   %rsi,%rsi
     582:	je     8e7 <follow_managed+0x3f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1043

     588:	mov    0x50(%rsi),%r11
     58c:	test   %r11,%r11
     58f:	je     8e5 <follow_managed+0x3f5>
     595:	mov    %r8,-0x50(%rbp)
     599:	mov    %r9,-0x48(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1044
		/* Transit to a mounted filesystem. */
     59d:	xor    %esi,%esi
     59f:	mov    %r10,-0x40(%rbp)
     5a3:	mov    %ecx,-0x38(%rbp)
     5a6:	mov    %rdx,-0x30(%rbp)
     5aa:	callq  *%r11
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1045
		if (managed & DCACHE_MOUNTED) {
     5ad:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1044
			ret = path->dentry->d_op->d_manage(path->dentry, false);
			if (ret < 0)
				break;
		}

		/* Transit to a mounted filesystem. */
     5af:	mov    %eax,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1045
		if (managed & DCACHE_MOUNTED) {
     5b2:	mov    -0x30(%rbp),%rdx
     5b6:	mov    -0x38(%rbp),%ecx
     5b9:	mov    -0x40(%rbp),%r10
     5bd:	mov    -0x48(%rbp),%r9
     5c1:	mov    -0x50(%rbp),%r8
     5c5:	js     537 <follow_managed+0x47>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1050
			struct vfsmount *mounted = lookup_mnt(path);
			if (mounted) {
				dput(path->dentry);
				if (need_mntput)
					mntput(path->mnt);
     5cb:	test   $0x10000,%r15d
     5d2:	jne    7d6 <follow_managed+0x2e6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1069
		if (managed & DCACHE_NEED_AUTOMOUNT) {
			ret = follow_automount(path, flags, &need_mntput);
			if (ret < 0)
				break;
			continue;
		}
     5d8:	and    $0x20000,%r15d
     5df:	je     537 <follow_managed+0x47>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:952
	if (!path->dentry->d_op || !path->dentry->d_op->d_automount)
		return -EREMOTE;

	/* We don't want to mount if someone's just doing a stat -
	 * unless they're stat'ing a directory and appended a '/' to
	 * the name.
     5e5:	mov    0x8(%r12),%rax
     5ea:	mov    0x60(%rax),%rsi
     5ee:	test   %rsi,%rsi
     5f1:	je     8cf <follow_managed+0x3df>
     5f7:	cmpq   $0x0,0x48(%rsi)
     5fc:	je     8cf <follow_managed+0x3df>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:966
	if (!(flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |
		     LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&
	    path->dentry->d_inode)
		return -EISDIR;

	current->total_link_count++;
     602:	test   $0x316,%ecx
     608:	jne    615 <follow_managed+0x125>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:967
	if (current->total_link_count >= 40)
     60a:	cmpq   $0x0,0x30(%rax)
     60f:	jne    8da <follow_managed+0x3ea>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:971
		return -ELOOP;

	mnt = path->dentry->d_op->d_automount(path);
	if (IS_ERR(mnt)) {
     615:	lea    0x4a8(%rbx),%rsi
     61c:	mov    $0x0,%rax
     623:	jmp    62e <follow_managed+0x13e>
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
     625:	test   %dil,%dil
     628:	je     7bd <follow_managed+0x2cd>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
     62e:	add    $0x1,%rsi
     632:	movzbl -0x1(%rsi),%edi
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
     636:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
     63a:	cmp    -0x1(%rax),%dil
     63e:	je     625 <follow_managed+0x135>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:971
     640:	mov    %r8,%rax
     643:	addl   $0x1,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:972
		/*
     64a:	lea    0x4a8(%r10),%rsi
     651:	mov    $0x0,%rax
     658:	jmp    663 <follow_managed+0x173>
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
			return c1 < c2 ? -1 : 1;
		if (!c1)
     65a:	test   %dil,%dil
     65d:	je     7a4 <follow_managed+0x2b4>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
     663:	add    $0x1,%rsi
     667:	movzbl -0x1(%rsi),%edi
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
     66b:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
     66f:	cmp    -0x1(%rax),%dil
     673:	je     65a <follow_managed+0x16a>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:972
     675:	mov    %r9,%rax
     678:	cmpl   $0x27,0x4bc(%rax)
     67f:	mov    %r8,-0x50(%rbp)
     683:	mov    %r9,-0x48(%rbp)
     687:	mov    %r10,-0x40(%rbp)
     68b:	mov    %ecx,-0x38(%rbp)
     68e:	jg     887 <follow_managed+0x397>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:975
		 * The filesystem is allowed to return -EISDIR here to indicate
		 * it doesn't want to automount.  For instance, autofs would do
		 * this so that its userspace daemon can mount on this dentry.
     694:	mov    0x8(%r12),%rax
     699:	mov    %rdx,-0x30(%rbp)
     69d:	mov    %r12,%rdi
     6a0:	mov    0x60(%rax),%rax
     6a4:	callq  *0x48(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:976
		 *
     6a7:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:975
	mnt = path->dentry->d_op->d_automount(path);
	if (IS_ERR(mnt)) {
		/*
		 * The filesystem is allowed to return -EISDIR here to indicate
		 * it doesn't want to automount.  For instance, autofs would do
		 * this so that its userspace daemon can mount on this dentry.
     6ad:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:976
		 *
     6b0:	mov    -0x30(%rbp),%rdx
     6b4:	mov    -0x38(%rbp),%ecx
     6b7:	mov    -0x40(%rbp),%r10
     6bb:	mov    -0x48(%rbp),%r9
     6bf:	mov    -0x50(%rbp),%r8
     6c3:	ja     879 <follow_managed+0x389>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:991
	if (!mnt) /* mount collision */
		return 0;

	if (!*need_mntput) {
		/* lock_mount() may release path->mnt on error */
		mntget(path->mnt);
     6c9:	test   %rax,%rax
     6cc:	je     780 <follow_managed+0x290>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:994
		*need_mntput = true;
	}
	err = finish_automount(mnt, path);
     6d2:	test   %r13b,%r13b
     6d5:	jne    706 <follow_managed+0x216>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:996

	switch (err) {
     6d7:	mov    (%r12),%rdi
     6db:	mov    %r8,-0x50(%rbp)
     6df:	mov    %r9,-0x48(%rbp)
     6e3:	mov    %r10,-0x40(%rbp)
     6e7:	mov    %ecx,-0x38(%rbp)
     6ea:	mov    %rdx,-0x30(%rbp)
     6ee:	callq  6f3 <follow_managed+0x203>
     6f3:	mov    -0x50(%rbp),%r8
     6f7:	mov    -0x48(%rbp),%r9
     6fb:	mov    -0x40(%rbp),%r10
     6ff:	mov    -0x38(%rbp),%ecx
     702:	mov    -0x30(%rbp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:999
	case -EBUSY:
		/* Someone else made a mount here whilst we were busy */
		return 0;
     706:	mov    %r12,%rsi
     709:	mov    %r15,%rdi
     70c:	mov    %r8,-0x50(%rbp)
     710:	mov    %r9,-0x48(%rbp)
     714:	mov    %r10,-0x40(%rbp)
     718:	mov    %ecx,-0x38(%rbp)
     71b:	mov    %rdx,-0x30(%rbp)
     71f:	callq  724 <follow_managed+0x234>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1001
	case 0:
		path_put(path);
     724:	cmp    $0xfffffff0,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:999
	err = finish_automount(mnt, path);

	switch (err) {
	case -EBUSY:
		/* Someone else made a mount here whilst we were busy */
		return 0;
     727:	mov    %eax,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1001
	case 0:
		path_put(path);
     72a:	mov    -0x30(%rbp),%rdx
     72e:	mov    -0x38(%rbp),%ecx
     731:	mov    -0x40(%rbp),%r10
     735:	mov    -0x48(%rbp),%r9
     739:	mov    -0x50(%rbp),%r8
     73d:	je     79c <follow_managed+0x2ac>
     73f:	test   %eax,%eax
     741:	jne    788 <follow_managed+0x298>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
     743:	mov    0x8(%r12),%rdi
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1008
		path->dentry = dget(mnt->mnt_root);
		return 0;
	default:
		return err;
	}

     748:	mov    $0x1,%r13d
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
     74e:	callq  753 <follow_managed+0x263>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
     753:	mov    (%r12),%rdi
     757:	callq  75c <follow_managed+0x26c>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1007
		path->mnt = mnt;
		path->dentry = dget(mnt->mnt_root);
		return 0;
	default:
		return err;
	}
     75c:	mov    %r15,(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1008

     760:	mov    (%r15),%rdi
     763:	callq  30 <dget>
     768:	mov    -0x30(%rbp),%rdx
     76c:	mov    -0x38(%rbp),%ecx
     76f:	mov    -0x40(%rbp),%r10
     773:	mov    -0x48(%rbp),%r9
     777:	mov    -0x50(%rbp),%r8
     77b:	mov    %rax,0x8(%r12)
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1058
				need_mntput = true;
				continue;
			}

			/* Something is mounted on this dentry in another
			 * namespace and/or whatever was mounted there in this
     780:	xor    %r14d,%r14d
     783:	jmpq   526 <follow_managed+0x36>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1001
	switch (err) {
	case -EBUSY:
		/* Someone else made a mount here whilst we were busy */
		return 0;
	case 0:
		path_put(path);
     788:	mov    $0x1,%r13d
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1071
			if (ret < 0)
				break;
			continue;
		}

		/* We didn't change the current path point */
     78e:	test   %r14d,%r14d
     791:	js     537 <follow_managed+0x47>
     797:	jmpq   526 <follow_managed+0x36>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1001
	switch (err) {
	case -EBUSY:
		/* Someone else made a mount here whilst we were busy */
		return 0;
	case 0:
		path_put(path);
     79c:	mov    $0x1,%r13d
     7a2:	jmp    780 <follow_managed+0x290>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:972
	if (current->total_link_count >= 40)
		return -ELOOP;

	mnt = path->dentry->d_op->d_automount(path);
	if (IS_ERR(mnt)) {
		/*
     7a4:	cmpb   $0x0,0x0(%rip)        # 7ab <follow_managed+0x2bb>
     7ab:	je     675 <follow_managed+0x185>
     7b1:	mov    0x0(%rip),%rax        # 7b8 <follow_managed+0x2c8>
     7b8:	jmpq   678 <follow_managed+0x188>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:971
	current->total_link_count++;
	if (current->total_link_count >= 40)
		return -ELOOP;

	mnt = path->dentry->d_op->d_automount(path);
	if (IS_ERR(mnt)) {
     7bd:	cmpb   $0x0,0x0(%rip)        # 7c4 <follow_managed+0x2d4>
     7c4:	je     640 <follow_managed+0x150>
     7ca:	mov    0x0(%rip),%rax        # 7d1 <follow_managed+0x2e1>
     7d1:	jmpq   643 <follow_managed+0x153>
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1051
			struct vfsmount *mounted = lookup_mnt(path);
			if (mounted) {
				dput(path->dentry);
				if (need_mntput)
					mntput(path->mnt);
				path->mnt = mounted;
     7d6:	mov    %r12,%rdi
     7d9:	mov    %r8,-0x50(%rbp)
     7dd:	mov    %r9,-0x48(%rbp)
     7e1:	mov    %r10,-0x40(%rbp)
     7e5:	mov    %ecx,-0x38(%rbp)
     7e8:	mov    %rdx,-0x30(%rbp)
     7ec:	callq  7f1 <follow_managed+0x301>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1052
				path->dentry = dget(mounted->mnt_root);
     7f1:	test   %rax,%rax
     7f4:	mov    %rax,-0x58(%rbp)
     7f8:	mov    -0x30(%rbp),%rdx
     7fc:	mov    -0x38(%rbp),%ecx
     7ff:	mov    -0x40(%rbp),%r10
     803:	mov    -0x48(%rbp),%r9
     807:	mov    -0x50(%rbp),%r8
     80b:	je     5d8 <follow_managed+0xe8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1053
				need_mntput = true;
     811:	mov    0x8(%r12),%rdi
     816:	callq  81b <follow_managed+0x32b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1054
				continue;
     81b:	test   %r13b,%r13b
     81e:	mov    -0x30(%rbp),%rdx
     822:	mov    -0x38(%rbp),%ecx
     825:	mov    -0x40(%rbp),%r10
     829:	mov    -0x48(%rbp),%r9
     82d:	mov    -0x50(%rbp),%r8
     831:	mov    -0x58(%rbp),%rax
     835:	jne    892 <follow_managed+0x3a2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1056
			}

     837:	mov    %rax,(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1057
			/* Something is mounted on this dentry in another
     83b:	mov    (%rax),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1058
			 * namespace and/or whatever was mounted there in this
     83e:	mov    $0x1,%r13d
     844:	mov    %r8,-0x50(%rbp)
     848:	mov    %r9,-0x48(%rbp)
     84c:	mov    %r10,-0x40(%rbp)
     850:	mov    %ecx,-0x38(%rbp)
     853:	mov    %rdx,-0x30(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1057
				path->dentry = dget(mounted->mnt_root);
				need_mntput = true;
				continue;
			}

			/* Something is mounted on this dentry in another
     857:	callq  30 <dget>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1059
			 * namespace and/or whatever was mounted there in this
			 * namespace got unmounted before lookup_mnt() could
     85c:	mov    -0x30(%rbp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1057
				path->dentry = dget(mounted->mnt_root);
				need_mntput = true;
				continue;
			}

			/* Something is mounted on this dentry in another
     860:	mov    %rax,0x8(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1059
			 * namespace and/or whatever was mounted there in this
			 * namespace got unmounted before lookup_mnt() could
     865:	mov    -0x38(%rbp),%ecx
     868:	mov    -0x40(%rbp),%r10
     86c:	mov    -0x48(%rbp),%r9
     870:	mov    -0x50(%rbp),%r8
     874:	jmpq   526 <follow_managed+0x36>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:986
		if (PTR_ERR(mnt) == -EISDIR && (flags & LOOKUP_PARENT))
			return -EREMOTE;
		return PTR_ERR(mnt);
	}

	if (!mnt) /* mount collision */
     879:	cmp    $0xffffffffffffffeb,%rax
     87d:	je     8ca <follow_managed+0x3da>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:988
		return 0;

     87f:	mov    %r15d,%r14d
     882:	jmpq   78e <follow_managed+0x29e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:973
		return -ELOOP;

	mnt = path->dentry->d_op->d_automount(path);
	if (IS_ERR(mnt)) {
		/*
		 * The filesystem is allowed to return -EISDIR here to indicate
     887:	mov    $0xffffffd8,%r14d
     88d:	jmpq   537 <follow_managed+0x47>
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1055
					mntput(path->mnt);
				path->mnt = mounted;
				path->dentry = dget(mounted->mnt_root);
				need_mntput = true;
				continue;
			}
     892:	mov    (%r12),%rdi
     896:	mov    %r8,-0x58(%rbp)
     89a:	mov    %r9,-0x50(%rbp)
     89e:	mov    %r10,-0x48(%rbp)
     8a2:	mov    %ecx,-0x40(%rbp)
     8a5:	mov    %rax,-0x38(%rbp)
     8a9:	callq  8ae <follow_managed+0x3be>
     8ae:	mov    -0x58(%rbp),%r8
     8b2:	mov    -0x50(%rbp),%r9
     8b6:	mov    -0x48(%rbp),%r10
     8ba:	mov    -0x40(%rbp),%ecx
     8bd:	mov    -0x38(%rbp),%rax
     8c1:	mov    -0x30(%rbp),%rdx
     8c5:	jmpq   837 <follow_managed+0x347>
follow_automount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:986
		if (PTR_ERR(mnt) == -EISDIR && (flags & LOOKUP_PARENT))
			return -EREMOTE;
		return PTR_ERR(mnt);
	}

	if (!mnt) /* mount collision */
     8ca:	test   $0x10,%cl
     8cd:	je     87f <follow_managed+0x38f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:953
		return -EREMOTE;

	/* We don't want to mount if someone's just doing a stat -
	 * unless they're stat'ing a directory and appended a '/' to
	 * the name.
	 *
     8cf:	mov    $0xffffffbe,%r14d
     8d5:	jmpq   537 <follow_managed+0x47>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:969
		return -EISDIR;

	current->total_link_count++;
	if (current->total_link_count >= 40)
		return -ELOOP;

     8da:	mov    $0xffffffeb,%r14d
     8e0:	jmpq   537 <follow_managed+0x47>
follow_managed():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1043 (discriminator 1)
			BUG_ON(!path->dentry->d_op->d_manage);
			ret = path->dentry->d_op->d_manage(path->dentry, false);
			if (ret < 0)
				break;
		}

     8e5:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1042 (discriminator 1)
			BUG_ON(!path->dentry->d_op);
			BUG_ON(!path->dentry->d_op->d_manage);
			ret = path->dentry->d_op->d_manage(path->dentry, false);
			if (ret < 0)
				break;
		}
     8e7:	ud2    
     8e9:	nopl   0x0(%rax)

00000000000008f0 <lookup_dcache>:
lookup_dcache():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1292
	int error;

	*need_lookup = false;
	dentry = d_lookup(dir, name);
	if (dentry) {
		if (dentry->d_flags & DCACHE_OP_REVALIDATE) {
     8f0:	callq  8f5 <lookup_dcache+0x5>
     8f5:	push   %rbp
     8f6:	mov    %rsp,%rbp
     8f9:	push   %r15
     8fb:	mov    %edx,%r15d
     8fe:	push   %r14
     900:	mov    %rcx,%r14
     903:	push   %r13
     905:	mov    %rdi,%r13
     908:	push   %r12
     90a:	mov    %rsi,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1297
			error = d_revalidate(dentry, flags);
			if (unlikely(error <= 0)) {
				if (error < 0) {
					dput(dentry);
					return ERR_PTR(error);
     90d:	mov    %rdi,%rsi
     910:	mov    %r12,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1292
	int error;

	*need_lookup = false;
	dentry = d_lookup(dir, name);
	if (dentry) {
		if (dentry->d_flags & DCACHE_OP_REVALIDATE) {
     913:	push   %rbx
     914:	sub    $0x8,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1296
			error = d_revalidate(dentry, flags);
			if (unlikely(error <= 0)) {
				if (error < 0) {
					dput(dentry);
     918:	movb   $0x0,(%rcx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1297
					return ERR_PTR(error);
     91b:	callq  920 <lookup_dcache+0x30>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1298
				} else if (!d_invalidate(dentry)) {
     920:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1297
		if (dentry->d_flags & DCACHE_OP_REVALIDATE) {
			error = d_revalidate(dentry, flags);
			if (unlikely(error <= 0)) {
				if (error < 0) {
					dput(dentry);
					return ERR_PTR(error);
     923:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1298
				} else if (!d_invalidate(dentry)) {
     926:	je     970 <lookup_dcache+0x80>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1299
					dput(dentry);
     928:	testb  $0x4,(%rax)
     92b:	jne    940 <lookup_dcache+0x50>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1318
	return dentry;
}

/*
 * Call i_op->lookup on the dentry.  The dentry must be negative and
 * unhashed.
     92d:	mov    %rbx,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1321
 *
 * dir->d_inode->i_mutex must be held
 */
     930:	add    $0x8,%rsp
     934:	pop    %rbx
     935:	pop    %r12
     937:	pop    %r13
     939:	pop    %r14
     93b:	pop    %r15
     93d:	pop    %rbp
     93e:	retq   
     93f:	nop
d_revalidate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:591

static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
{
	return dentry->d_op->d_revalidate(dentry, flags);
}

     940:	mov    0x60(%rax),%rax
     944:	mov    %r15d,%esi
     947:	mov    %rbx,%rdi
     94a:	callq  *(%rax)
lookup_dcache():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1301
					dput(dentry);
					return ERR_PTR(error);
				} else if (!d_invalidate(dentry)) {
					dput(dentry);
					dentry = NULL;
				}
     94c:	cmp    $0x0,%eax
     94f:	jg     92d <lookup_dcache+0x3d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1302
			}
     951:	jne    98f <lookup_dcache+0x9f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1305
		}
	}

     953:	mov    %rbx,%rdi
     956:	callq  95b <lookup_dcache+0x6b>
     95b:	test   %eax,%eax
     95d:	nopl   (%rax)
     960:	jne    92d <lookup_dcache+0x3d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1306
	if (!dentry) {
     962:	mov    %rbx,%rdi
     965:	callq  96a <lookup_dcache+0x7a>
     96a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1314
			return ERR_PTR(-ENOMEM);

		*need_lookup = true;
	}
	return dentry;
}
     970:	mov    %r13,%rsi
     973:	mov    %r12,%rdi
     976:	callq  97b <lookup_dcache+0x8b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1315

     97b:	test   %rax,%rax
     97e:	je     986 <lookup_dcache+0x96>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1318
/*
 * Call i_op->lookup on the dentry.  The dentry must be negative and
 * unhashed.
     980:	movb   $0x1,(%r14)
     984:	jmp    930 <lookup_dcache+0x40>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1316
		*need_lookup = true;
	}
	return dentry;
}

/*
     986:	mov    $0xfffffffffffffff4,%rax
     98d:	jmp    930 <lookup_dcache+0x40>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1303
				} else if (!d_invalidate(dentry)) {
					dput(dentry);
					dentry = NULL;
				}
			}
		}
     98f:	mov    %rbx,%rdi
     992:	mov    %eax,-0x2c(%rbp)
     995:	callq  99a <lookup_dcache+0xaa>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1304
	}
     99a:	movslq -0x2c(%rbp),%rax
     99e:	jmp    930 <lookup_dcache+0x40>

00000000000009a0 <__lookup_hash>:
__lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1352
	dentry = lookup_dcache(name, base, flags, &need_lookup);
	if (!need_lookup)
		return dentry;

	return lookup_real(base->d_inode, dentry, flags);
}
     9a0:	callq  9a5 <__lookup_hash+0x5>
     9a5:	push   %rbp
     9a6:	mov    %rsp,%rbp
     9a9:	push   %r12
     9ab:	mov    %rsi,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1356

/*
 *  It's more convoluted than I'd like it to be, but... it's still fairly
 *  small and for now I'd prefer to have fast path as straight as possible.
     9ae:	lea    -0x11(%rbp),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1352
	dentry = lookup_dcache(name, base, flags, &need_lookup);
	if (!need_lookup)
		return dentry;

	return lookup_real(base->d_inode, dentry, flags);
}
     9b2:	push   %rbx
     9b3:	mov    %edx,%ebx
     9b5:	sub    $0x8,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1356

/*
 *  It's more convoluted than I'd like it to be, but... it's still fairly
 *  small and for now I'd prefer to have fast path as straight as possible.
     9b9:	callq  8f0 <lookup_dcache>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1357
 *  It _is_ time-critical.
     9be:	cmpb   $0x0,-0x11(%rbp)
     9c2:	je     9d3 <__lookup_hash+0x33>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1360
 */
static int lookup_fast(struct nameidata *nd, struct path *path, struct inode **inode)
{
     9c4:	mov    0x30(%r12),%rdi
     9c9:	mov    %ebx,%edx
     9cb:	mov    %rax,%rsi
     9ce:	callq  f0 <lookup_real>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1361
	struct vfsmount *mnt = nd->path.mnt;
     9d3:	add    $0x8,%rsp
     9d7:	pop    %rbx
     9d8:	pop    %r12
     9da:	pop    %rbp
     9db:	retq   
     9dc:	nopl   0x0(%rax)

00000000000009e0 <done_path_create>:
done_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3379
	error = dir->i_op->mknod(dir, dentry, mode, dev);
	if (!error)
		fsnotify_create(dir, dentry);
	return error;
}

     9e0:	callq  9e5 <done_path_create+0x5>
     9e5:	push   %rbp
     9e6:	mov    %rsp,%rbp
     9e9:	push   %rbx
     9ea:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3380
static int may_mknod(umode_t mode)
     9ed:	mov    %rsi,%rdi
     9f0:	callq  9f5 <done_path_create+0x15>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3381
{
     9f5:	mov    0x8(%rbx),%rax
     9f9:	mov    0x30(%rax),%rdi
     9fd:	add    $0xa8,%rdi
     a04:	callq  a09 <done_path_create+0x29>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3382
	switch (mode & S_IFMT) {
     a09:	mov    (%rbx),%rdi
     a0c:	callq  a11 <done_path_create+0x31>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
     a11:	mov    0x8(%rbx),%rdi
     a15:	callq  a1a <done_path_create+0x3a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
     a1a:	mov    (%rbx),%rdi
     a1d:	callq  a22 <done_path_create+0x42>
done_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3384

static int may_mknod(umode_t mode)
{
	switch (mode & S_IFMT) {
	case S_IFREG:
	case S_IFCHR:
     a22:	pop    %rbx
     a23:	pop    %rbp
     a24:	retq   
     a25:	data32 nopw %cs:0x0(%rax,%rax,1)

0000000000000a30 <dentry_unhash>:
dentry_unhash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3562
}

static long do_rmdir(int dfd, const char __user *pathname)
{
	int error = 0;
	struct filename *name;
     a30:	callq  a35 <dentry_unhash+0x5>
     a35:	push   %rbp
     a36:	mov    %rsp,%rbp
     a39:	push   %r12
     a3b:	push   %rbx
     a3c:	mov    %rdi,%rbx
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     a3f:	lea    0x58(%rbx),%r12
dentry_unhash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3563
	struct dentry *dentry;
     a43:	callq  a48 <dentry_unhash+0x18>
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
     a48:	mov    %r12,%rdi
     a4b:	callq  a50 <dentry_unhash+0x20>
dentry_unhash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3565
	struct nameidata nd;
	unsigned int lookup_flags = 0;
     a50:	cmpl   $0x1,0x5c(%rbx)
     a54:	je     a68 <dentry_unhash+0x38>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
     a56:	mov    %r12,%rdi
     a59:	callq  a5e <dentry_unhash+0x2e>
dentry_unhash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3568
retry:
	name = user_path_parent(dfd, pathname, &nd, lookup_flags);
	if (IS_ERR(name))
     a5e:	pop    %rbx
     a5f:	pop    %r12
     a61:	pop    %rbp
     a62:	retq   
     a63:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3566
	int error = 0;
	struct filename *name;
	struct dentry *dentry;
	struct nameidata nd;
	unsigned int lookup_flags = 0;
retry:
     a68:	mov    %rbx,%rdi
     a6b:	callq  a70 <dentry_unhash+0x40>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
     a70:	mov    %r12,%rdi
     a73:	callq  a78 <dentry_unhash+0x48>
dentry_unhash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3568
	name = user_path_parent(dfd, pathname, &nd, lookup_flags);
	if (IS_ERR(name))
     a78:	pop    %rbx
     a79:	pop    %r12
     a7b:	pop    %rbp
     a7c:	retq   
     a7d:	nopl   (%rax)

0000000000000a80 <vfs_readlink>:
vfs_readlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4325
	kaddr = kmap(page);
	nd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);
	return kaddr;
}

int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)
     a80:	callq  a85 <vfs_readlink+0x5>
     a85:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4329
{
	struct page *page = NULL;
	char *s = page_getlink(dentry, &page);
	int res = vfs_readlink(dentry,buffer,buflen,s);
     a86:	cmp    $0xfffffffffffff000,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4325
	kaddr = kmap(page);
	nd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);
	return kaddr;
}

int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)
     a8d:	mov    %rsp,%rbp
     a90:	push   %r13
     a92:	push   %r12
     a94:	mov    %rcx,%r12
     a97:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4329
{
	struct page *page = NULL;
	char *s = page_getlink(dentry, &page);
	int res = vfs_readlink(dentry,buffer,buflen,s);
     a98:	ja     acd <vfs_readlink+0x4d>
     a9a:	mov    %edx,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4332
	if (page) {
		kunmap(page);
		page_cache_release(page);
     a9c:	mov    %rcx,%rdi
     a9f:	mov    %rsi,%r13
     aa2:	callq  aa7 <vfs_readlink+0x27>
     aa7:	cmp    %eax,%ebx
copy_to_user():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/uaccess.h:631

	might_fault();

	/* See the comment in copy_from_user() above. */
	if (likely(sz < 0 || sz >= n))
		n = _copy_to_user(to, from, n);
     aa9:	mov    %r12,%rsi
     aac:	mov    %r13,%rdi
vfs_readlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4332
     aaf:	cmovae %eax,%ebx
copy_to_user():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/uaccess.h:631
     ab2:	mov    %ebx,%edx
     ab4:	callq  ab9 <vfs_readlink+0x39>
vfs_readlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4336
	}
	return res;
}

     ab9:	test   %rax,%rax
     abc:	mov    $0xfffffff2,%eax
     ac1:	cmovne %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4339
void *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)
{
	struct page *page = NULL;
     ac4:	mov    %ebx,%eax
     ac6:	pop    %rbx
     ac7:	pop    %r12
     ac9:	pop    %r13
     acb:	pop    %rbp
     acc:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4328
}

int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)
{
	struct page *page = NULL;
	char *s = page_getlink(dentry, &page);
     acd:	mov    %ecx,%ebx
     acf:	jmp    ac4 <vfs_readlink+0x44>
     ad1:	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000000ae0 <generic_readlink>:
generic_readlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4347
}

void page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)
{
	struct page *page = cookie;

     ae0:	callq  ae5 <generic_readlink+0x5>
     ae5:	push   %rbp
     ae6:	mov    %rsp,%rbp
     ae9:	push   %r14
     aeb:	mov    %edx,%r14d
     aee:	push   %r13
     af0:	mov    %rsi,%r13
     af3:	push   %r12
     af5:	push   %rbx
     af6:	mov    %rdi,%rbx
     af9:	and    $0xfffffffffffffff0,%rsp
     afd:	sub    $0xa0,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4353
	if (page) {
		kunmap(page);
		page_cache_release(page);
	}
}

     b04:	mov    0x30(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4352

	if (page) {
		kunmap(page);
		page_cache_release(page);
	}
}
     b08:	movl   $0x0,0x48(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4353

     b10:	mov    %rsp,%rsi
     b13:	mov    0x20(%rax),%rax
     b17:	callq  *0x8(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4354
/*
     b1a:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4353
	if (page) {
		kunmap(page);
		page_cache_release(page);
	}
}

     b20:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4354
/*
     b23:	ja     b6b <generic_readlink+0x8b>
nd_get_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:93
	nd->saved_names[nd->depth] = path;
}

static inline char *nd_get_link(struct nameidata *nd)
{
	return nd->saved_names[nd->depth];
     b25:	mov    0x48(%rsp),%eax
generic_readlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4357
 * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS
 */
int __page_symlink(struct inode *inode, const char *symname, int len, int nofs)
     b29:	mov    %r14d,%edx
     b2c:	mov    %r13,%rsi
     b2f:	mov    %rbx,%rdi
     b32:	mov    0x50(%rsp,%rax,8),%rcx
     b37:	callq  b3c <generic_readlink+0x5c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4358
{
     b3c:	mov    0x30(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4360
	struct address_space *mapping = inode->i_mapping;
	struct page *page;
     b40:	mov    %eax,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4358

/*
 * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS
 */
int __page_symlink(struct inode *inode, const char *symname, int len, int nofs)
{
     b43:	mov    0x20(%rdx),%rdx
     b47:	mov    0x28(%rdx),%rcx
     b4b:	test   %rcx,%rcx
     b4e:	je     b5b <generic_readlink+0x7b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4359
	struct address_space *mapping = inode->i_mapping;
     b50:	mov    %r12,%rdx
     b53:	mov    %rsp,%rsi
     b56:	mov    %rbx,%rdi
     b59:	callq  *%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4361
	struct page *page;
	void *fsdata;
     b5b:	lea    -0x20(%rbp),%rsp
     b5f:	mov    %r13d,%eax
     b62:	pop    %rbx
     b63:	pop    %r12
     b65:	pop    %r13
     b67:	pop    %r14
     b69:	pop    %rbp
     b6a:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4355
		page_cache_release(page);
	}
}

/*
 * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS
     b6b:	mov    %eax,%r13d
     b6e:	jmp    b5b <generic_readlink+0x7b>

0000000000000b70 <page_put_link>:
page_put_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4398
	return __page_symlink(inode, symname, len,
			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
}

const struct inode_operations page_symlink_inode_operations = {
	.readlink	= generic_readlink,
     b70:	callq  b75 <page_put_link+0x5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4401
	.follow_link	= page_follow_link_light,
	.put_link	= page_put_link,
};
     b75:	test   %rdx,%rdx
     b78:	je     b87 <page_put_link+0x17>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4398
	return __page_symlink(inode, symname, len,
			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
}

const struct inode_operations page_symlink_inode_operations = {
	.readlink	= generic_readlink,
     b7a:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4403
	.follow_link	= page_follow_link_light,
	.put_link	= page_put_link,
};

EXPORT_SYMBOL(user_path_at);
     b7b:	mov    %rdx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4398
	return __page_symlink(inode, symname, len,
			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
}

const struct inode_operations page_symlink_inode_operations = {
	.readlink	= generic_readlink,
     b7e:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4403
	.follow_link	= page_follow_link_light,
	.put_link	= page_put_link,
};

EXPORT_SYMBOL(user_path_at);
     b81:	callq  b86 <page_put_link+0x16>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4405
EXPORT_SYMBOL(follow_down_one);
EXPORT_SYMBOL(follow_down);
     b86:	pop    %rbp
     b87:	repz retq 
     b89:	nopl   0x0(%rax)

0000000000000b90 <__page_symlink>:
__page_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4411
EXPORT_SYMBOL(follow_up);
EXPORT_SYMBOL(get_write_access); /* nfsd */
EXPORT_SYMBOL(lock_rename);
EXPORT_SYMBOL(lookup_one_len);
EXPORT_SYMBOL(page_follow_link_light);
EXPORT_SYMBOL(page_put_link);
     b90:	callq  b95 <__page_symlink+0x5>
     b95:	push   %rbp
     b96:	mov    %rsp,%rbp
     b99:	push   %r15
     b9b:	mov    %rsi,%r15
     b9e:	push   %r14
     ba0:	lea    -0x30(%rbp),%r14
     ba4:	push   %r13
     ba6:	push   %r12
     ba8:	push   %rbx
     ba9:	lea    -0x1(%rdx),%ebx
     bac:	sub    $0x28,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4417
EXPORT_SYMBOL(page_readlink);
EXPORT_SYMBOL(__page_symlink);
EXPORT_SYMBOL(page_symlink);
EXPORT_SYMBOL(page_symlink_inode_operations);
EXPORT_SYMBOL(kern_path);
EXPORT_SYMBOL(vfs_path_lookup);
     bb0:	cmp    $0x1,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4428
EXPORT_SYMBOL(vfs_mknod);
EXPORT_SYMBOL(generic_permission);
EXPORT_SYMBOL(vfs_readlink);
EXPORT_SYMBOL(vfs_rename);
EXPORT_SYMBOL(vfs_rmdir);
EXPORT_SYMBOL(vfs_symlink);
     bb3:	movslq %ebx,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4417
EXPORT_SYMBOL(page_readlink);
EXPORT_SYMBOL(__page_symlink);
EXPORT_SYMBOL(page_symlink);
EXPORT_SYMBOL(page_symlink_inode_operations);
EXPORT_SYMBOL(kern_path);
EXPORT_SYMBOL(vfs_path_lookup);
     bb6:	sbb    %r13d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4411
EXPORT_SYMBOL(follow_up);
EXPORT_SYMBOL(get_write_access); /* nfsd */
EXPORT_SYMBOL(lock_rename);
EXPORT_SYMBOL(lookup_one_len);
EXPORT_SYMBOL(page_follow_link_light);
EXPORT_SYMBOL(page_put_link);
     bb9:	mov    %rdi,-0x48(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4412
EXPORT_SYMBOL(page_readlink);
     bbd:	mov    0x30(%rdi),%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4417
EXPORT_SYMBOL(__page_symlink);
EXPORT_SYMBOL(page_symlink);
EXPORT_SYMBOL(page_symlink_inode_operations);
EXPORT_SYMBOL(kern_path);
EXPORT_SYMBOL(vfs_path_lookup);
     bc1:	and    $0xfffffffc,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4428
EXPORT_SYMBOL(vfs_mknod);
EXPORT_SYMBOL(generic_permission);
EXPORT_SYMBOL(vfs_readlink);
EXPORT_SYMBOL(vfs_rename);
EXPORT_SYMBOL(vfs_rmdir);
EXPORT_SYMBOL(vfs_symlink);
     bc5:	mov    %rax,-0x40(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4417
EXPORT_SYMBOL(page_readlink);
EXPORT_SYMBOL(__page_symlink);
EXPORT_SYMBOL(page_symlink);
EXPORT_SYMBOL(page_symlink_inode_operations);
EXPORT_SYMBOL(kern_path);
EXPORT_SYMBOL(vfs_path_lookup);
     bc9:	add    $0x5,%r13d
     bcd:	jmp    c37 <__page_symlink+0xa7>
     bcf:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4427
EXPORT_SYMBOL(vfs_mkdir);
EXPORT_SYMBOL(vfs_mknod);
EXPORT_SYMBOL(generic_permission);
EXPORT_SYMBOL(vfs_readlink);
EXPORT_SYMBOL(vfs_rename);
EXPORT_SYMBOL(vfs_rmdir);
     bd0:	mov    -0x38(%rbp),%rdi
__preempt_count_add():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/preempt.h:75
 * The various preempt_count add/sub methods
 */

static __always_inline void __preempt_count_add(int val)
{
	__this_cpu_add_4(__preempt_count, val);
     bd4:	incl   %gs:0x0
lowmem_page_address():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/mm.h:841
 */
#include <linux/vmstat.h>

static __always_inline void *lowmem_page_address(const struct page *page)
{
	return __va(PFN_PHYS(page_to_pfn(page)));
     bdc:	movabs $0x160000000000,%rax
__page_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4428
EXPORT_SYMBOL(vfs_symlink);
     be6:	mov    -0x40(%rbp),%rdx
     bea:	mov    %r15,%rsi
lowmem_page_address():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/mm.h:841
     bed:	add    %rax,%rdi
     bf0:	movabs $0xffff880000000000,%rax
     bfa:	sar    $0x6,%rdi
     bfe:	shl    $0xc,%rdi
     c02:	add    %rax,%rdi
__page_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4428
     c05:	callq  c0a <__page_symlink+0x7a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4431
EXPORT_SYMBOL(vfs_unlink);
EXPORT_SYMBOL(dentry_unhash);
EXPORT_SYMBOL(generic_readlink);
     c0a:	mov    -0x30(%rbp),%rax
     c0e:	mov    -0x38(%rbp),%r9
     c12:	xor    %edx,%edx
     c14:	xor    %edi,%edi
     c16:	mov    %ebx,%r8d
     c19:	mov    %ebx,%ecx
     c1b:	mov    %r12,%rsi
     c1e:	mov    %rax,(%rsp)
__preempt_count_sub():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/preempt.h:80
}

static __always_inline void __preempt_count_sub(int val)
{
	__this_cpu_add_4(__preempt_count, -val);
     c22:	decl   %gs:0x0
__page_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4431
     c2a:	callq  c2f <__page_symlink+0x9f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4433
     c2f:	test   %eax,%eax
     c31:	js     c58 <__page_symlink+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4435
     c33:	cmp    %eax,%ebx
     c35:	jle    c70 <__page_symlink+0xe0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4422
EXPORT_SYMBOL(vfs_path_lookup);
EXPORT_SYMBOL(inode_permission);
EXPORT_SYMBOL(unlock_rename);
EXPORT_SYMBOL(vfs_create);
EXPORT_SYMBOL(vfs_link);
EXPORT_SYMBOL(vfs_mkdir);
     c37:	lea    -0x38(%rbp),%r9
     c3b:	xor    %edx,%edx
     c3d:	xor    %edi,%edi
     c3f:	mov    %r14,(%rsp)
     c43:	mov    %r13d,%r8d
     c46:	mov    %ebx,%ecx
     c48:	mov    %r12,%rsi
     c4b:	callq  c50 <__page_symlink+0xc0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4424
EXPORT_SYMBOL(vfs_mknod);
EXPORT_SYMBOL(generic_permission);
     c50:	test   %eax,%eax
     c52:	je     bd0 <__page_symlink+0x40>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4442
     c58:	add    $0x28,%rsp
     c5c:	pop    %rbx
     c5d:	pop    %r12
     c5f:	pop    %r13
     c61:	pop    %r14
     c63:	pop    %r15
     c65:	pop    %rbp
     c66:	retq   
     c67:	nopw   0x0(%rax,%rax,1)
mark_inode_dirty():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1753
#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)

extern void __mark_inode_dirty(struct inode *, int);
static inline void mark_inode_dirty(struct inode *inode)
{
	__mark_inode_dirty(inode, I_DIRTY);
     c70:	mov    -0x48(%rbp),%rdi
     c74:	mov    $0x7,%esi
     c79:	callq  c7e <__page_symlink+0xee>
__page_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4442
     c7e:	add    $0x28,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4439
     c82:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4442
     c84:	pop    %rbx
     c85:	pop    %r12
     c87:	pop    %r13
     c89:	pop    %r14
     c8b:	pop    %r15
     c8d:	pop    %rbp
     c8e:	retq   
     c8f:	nop

0000000000000c90 <page_symlink>:
page_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4445
     c90:	callq  c95 <page_symlink+0x5>
     c95:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4447
     c96:	mov    0x30(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4445
     c9a:	mov    %rsp,%rbp
mapping_gfp_mask():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:75
	return mapping && test_bit(AS_BALLOON_MAP, &mapping->flags);
}

static inline gfp_t mapping_gfp_mask(struct address_space * mapping)
{
	return (__force gfp_t)mapping->flags & __GFP_BITS_MASK;
     c9d:	mov    0x78(%rax),%rcx
page_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4446
     ca1:	shr    $0x7,%ecx
     ca4:	xor    $0x1,%ecx
     ca7:	and    $0x1,%ecx
     caa:	callq  caf <page_symlink+0x1f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4448
     caf:	pop    %rbp
     cb0:	retq   
     cb1:	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000000cc0 <terminate_walk>:
terminate_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1512
		if (!(nd->flags & LOOKUP_ROOT))
			nd->root.mnt = NULL;
		rcu_read_unlock();
	}
}

     cc0:	callq  cc5 <terminate_walk+0x5>
     cc5:	push   %rbp
     cc6:	mov    %rsp,%rbp
     cc9:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1513
/*
     cca:	mov    0x38(%rdi),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1512
		if (!(nd->flags & LOOKUP_ROOT))
			nd->root.mnt = NULL;
		rcu_read_unlock();
	}
}

     ccd:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1513
/*
     cd0:	test   $0x40,%al
     cd2:	je     cf8 <terminate_walk+0x38>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1516
 * Do we need to follow links? We _really_ want to be able
 * to do this check without having to look at inode->i_op,
 * so we keep a cache of "no, this doesn't need follow_link"
     cd4:	mov    %eax,%edx
     cd6:	and    $0xffffffbf,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1517
 * for the common case.
     cd9:	test   $0x20,%ah
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1516
}

/*
 * Do we need to follow links? We _really_ want to be able
 * to do this check without having to look at inode->i_op,
 * so we keep a cache of "no, this doesn't need follow_link"
     cdc:	mov    %edx,0x38(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1517
 * for the common case.
     cdf:	je     ce8 <terminate_walk+0x28>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1521
 */
static inline int should_follow_link(struct dentry *dentry, int follow)
{
	return unlikely(d_is_symlink(dentry)) ? follow : 0;
     ce1:	pop    %rbx
     ce2:	pop    %rbp
     ce3:	retq   
     ce4:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1518
/*
 * Do we need to follow links? We _really_ want to be able
 * to do this check without having to look at inode->i_op,
 * so we keep a cache of "no, this doesn't need follow_link"
 * for the common case.
 */
     ce8:	movq   $0x0,0x20(%rdi)
     cf0:	jmp    ce1 <terminate_walk+0x21>
     cf2:	nopw   0x0(%rax,%rax,1)
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
     cf8:	mov    0x8(%rdi),%rdi
     cfc:	callq  d01 <terminate_walk+0x41>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
     d01:	mov    (%rbx),%rdi
     d04:	callq  d09 <terminate_walk+0x49>
terminate_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1521
 * so we keep a cache of "no, this doesn't need follow_link"
 * for the common case.
 */
static inline int should_follow_link(struct dentry *dentry, int follow)
{
	return unlikely(d_is_symlink(dentry)) ? follow : 0;
     d09:	pop    %rbx
     d0a:	pop    %rbp
     d0b:	retq   
     d0c:	nopl   0x0(%rax)

0000000000000d10 <path_put_conditional.isra.13>:
path_put_conditional():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:671
	}
}

static void path_put_conditional(struct path *path, struct nameidata *nd)
{
	dput(path->dentry);
     d10:	callq  d15 <path_put_conditional.isra.13+0x5>
     d15:	push   %rbp
     d16:	mov    %rsp,%rbp
     d19:	push   %r12
     d1b:	mov    %rsi,%r12
     d1e:	push   %rbx
     d1f:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:673
	if (path->mnt != nd->path.mnt)
		mntput(path->mnt);
     d22:	mov    0x8(%rdi),%rdi
     d26:	callq  d2b <path_put_conditional.isra.13+0x1b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:674
}
     d2b:	mov    (%rbx),%rdi
     d2e:	cmp    (%r12),%rdi
     d32:	je     d39 <path_put_conditional.isra.13+0x29>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:675

     d34:	callq  d39 <path_put_conditional.isra.13+0x29>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:676
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
     d39:	pop    %rbx
     d3a:	pop    %r12
     d3c:	pop    %rbp
     d3d:	retq   
path_put_conditional.isra.13():
     d3e:	xchg   %ax,%ax

0000000000000d40 <lock_rename>:
lock_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2471
	mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
	mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
	return NULL;
}

void unlock_rename(struct dentry *p1, struct dentry *p2)
     d40:	callq  d45 <lock_rename+0x5>
     d45:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2474
{
	mutex_unlock(&p1->d_inode->i_mutex);
	if (p1 != p2) {
     d46:	cmp    %rsi,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2471
	mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
	mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
	return NULL;
}

void unlock_rename(struct dentry *p1, struct dentry *p2)
     d49:	mov    %rsp,%rbp
     d4c:	push   %r13
     d4e:	push   %r12
     d50:	mov    %rsi,%r12
     d53:	push   %rbx
     d54:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2474
{
	mutex_unlock(&p1->d_inode->i_mutex);
	if (p1 != p2) {
     d57:	je     df0 <lock_rename+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2479
		mutex_unlock(&p2->d_inode->i_mutex);
		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
	}
}

     d5d:	mov    0x30(%rdi),%rax
     d61:	mov    0x28(%rax),%rdi
     d65:	add    $0x310,%rdi
     d6c:	callq  d71 <lock_rename+0x31>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2481
int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool want_excl)
{
     d71:	mov    %rbx,%rsi
     d74:	mov    %r12,%rdi
     d77:	callq  d7c <lock_rename+0x3c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2482
  MY_PRINTK(get_current()->comm);
     d7c:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2481
		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
	}
}

int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool want_excl)
{
     d7f:	mov    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2482
  MY_PRINTK(get_current()->comm);
     d82:	je     db0 <lock_rename+0x70>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2483
	int error = may_create(dir, dentry);
     d84:	mov    0x30(%r12),%rdi
     d89:	add    $0xa8,%rdi
     d90:	callq  d95 <lock_rename+0x55>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2484
	if (error)
     d95:	mov    0x30(%rbx),%rdi
     d99:	add    $0xa8,%rdi
     da0:	callq  da5 <lock_rename+0x65>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2485
		return error;
     da5:	mov    %r13,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2498
    error = security_inode_create(dir, dentry, mode);
  else
    error = 0;
	if (error)
		return error;
	error = dir->i_op->create(dir, dentry, mode, want_excl);
     da8:	pop    %rbx
     da9:	pop    %r12
     dab:	pop    %r13
     dad:	pop    %rbp
     dae:	retq   
     daf:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2488
	int error = may_create(dir, dentry);
	if (error)
		return error;

	if (!dir->i_op->create)
		return -EACCES;	/* shouldn't it be ENOSYS? */
     db0:	mov    %rbx,%rdi
     db3:	mov    %r12,%rsi
     db6:	callq  dbb <lock_rename+0x7b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2490
	mode &= S_IALLUGO;
	mode |= S_IFREG;
     dbb:	mov    0x30(%rbx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2488
	int error = may_create(dir, dentry);
	if (error)
		return error;

	if (!dir->i_op->create)
		return -EACCES;	/* shouldn't it be ENOSYS? */
     dbf:	mov    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2490
	mode &= S_IALLUGO;
	mode |= S_IFREG;
     dc2:	add    $0xa8,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2489
	if (error)
		return error;

	if (!dir->i_op->create)
		return -EACCES;	/* shouldn't it be ENOSYS? */
	mode &= S_IALLUGO;
     dc9:	test   %rax,%rax
     dcc:	je     e04 <lock_rename+0xc4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2490
	mode |= S_IFREG;
     dce:	callq  dd3 <lock_rename+0x93>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2491
	// error = security_inode_create(dir, dentry, mode);
     dd3:	mov    0x30(%r12),%rdi
     dd8:	add    $0xa8,%rdi
     ddf:	callq  de4 <lock_rename+0xa4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2498
    error = security_inode_create(dir, dentry, mode);
  else
    error = 0;
	if (error)
		return error;
	error = dir->i_op->create(dir, dentry, mode, want_excl);
     de4:	pop    %rbx
     de5:	pop    %r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2492
	if (!dir->i_op->create)
		return -EACCES;	/* shouldn't it be ENOSYS? */
	mode &= S_IALLUGO;
	mode |= S_IFREG;
	// error = security_inode_create(dir, dentry, mode);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
     de7:	mov    %r13,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2498
    error = security_inode_create(dir, dentry, mode);
  else
    error = 0;
	if (error)
		return error;
	error = dir->i_op->create(dir, dentry, mode, want_excl);
     dea:	pop    %r13
     dec:	pop    %rbp
     ded:	retq   
     dee:	xchg   %ax,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2475

void unlock_rename(struct dentry *p1, struct dentry *p2)
{
	mutex_unlock(&p1->d_inode->i_mutex);
	if (p1 != p2) {
		mutex_unlock(&p2->d_inode->i_mutex);
     df0:	mov    0x30(%rdi),%rdi
     df4:	add    $0xa8,%rdi
     dfb:	callq  e00 <lock_rename+0xc0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2476
		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
     e00:	xor    %eax,%eax
     e02:	jmp    da8 <lock_rename+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2495
	mode |= S_IFREG;
	// error = security_inode_create(dir, dentry, mode);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_create(dir, dentry, mode);
  else
    error = 0;
     e04:	callq  e09 <lock_rename+0xc9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2496
	if (error)
     e09:	mov    0x30(%r12),%rdi
     e0e:	add    $0xa8,%rdi
     e15:	callq  e1a <lock_rename+0xda>
     e1a:	xor    %eax,%eax
     e1c:	jmp    da8 <lock_rename+0x68>
     e1e:	xchg   %ax,%ax

0000000000000e20 <generic_permission>:
generic_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:327
 * It would then be called again in ref-walk mode.
 */
int generic_permission(struct inode *inode, int mask)
{
	int ret;

     e20:	callq  e25 <generic_permission+0x5>
     e25:	push   %rbp
acl_permission_check():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:291
{
	unsigned int mode = inode->i_mode;

	if (likely(uid_eq(current_fsuid(), inode->i_uid)))
		mode >>= 6;
	else {
     e26:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
     e2d:	mov    %gs:0x0,%rcx
generic_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:327
 * It would then be called again in ref-walk mode.
 */
int generic_permission(struct inode *inode, int mask)
{
	int ret;

     e36:	mov    %rsp,%rbp
     e39:	push   %r15
acl_permission_check():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:291
{
	unsigned int mode = inode->i_mode;

	if (likely(uid_eq(current_fsuid(), inode->i_uid)))
		mode >>= 6;
	else {
     e3b:	add    $0x4a8,%rcx
generic_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:327
 * It would then be called again in ref-walk mode.
 */
int generic_permission(struct inode *inode, int mask)
{
	int ret;

     e42:	push   %r14
     e44:	mov    %esi,%r14d
     e47:	push   %r13
     e49:	push   %r12
     e4b:	mov    %rdi,%r12
     e4e:	push   %rbx
acl_permission_check():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:289
 */
static int acl_permission_check(struct inode *inode, int mask)
{
	unsigned int mode = inode->i_mode;

	if (likely(uid_eq(current_fsuid(), inode->i_uid)))
     e4f:	movzwl (%rdi),%edx
     e52:	movzwl %dx,%ebx
     e55:	jmp    e65 <generic_permission+0x45>
     e57:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
     e60:	test   %r8b,%r8b
     e63:	je     ec0 <generic_permission+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
     e65:	add    $0x1,%rcx
     e69:	movzbl -0x1(%rcx),%r8d
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
     e6e:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
     e72:	cmp    -0x1(%rax),%r8b
     e76:	je     e60 <generic_permission+0x40>
acl_permission_check():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:291
		mode >>= 6;
	else {
     e78:	mov    %gs:0x0,%rax
     e81:	mov    0x4a0(%rax),%rax
     e88:	mov    0x4(%r12),%esi
     e8d:	cmp    %esi,0x1c(%rax)
     e90:	jne    fcb <generic_permission+0x1ab>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:292
		if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {
     e96:	shr    $0x6,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:307
	/*
	 * If the DACs are ok we don't need any capability check.
	 */
	if ((mask & ~mode & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)
		return 0;
	return -EACCES;
     e99:	mov    %r14d,%eax
     e9c:	not    %ebx
     e9e:	and    $0x7,%eax
     ea1:	test   %ebx,%eax
     ea3:	jne    f30 <generic_permission+0x110>
generic_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:340
	if (S_ISDIR(inode->i_mode)) {
		/* DACs are overridable for directories */
		if (inode_capable(inode, CAP_DAC_OVERRIDE))
			return 0;
		if (!(mask & MAY_WRITE))
			if (inode_capable(inode, CAP_DAC_READ_SEARCH))
     ea9:	xor    %r13d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:364
			return 0;

	return -EACCES;
}

/*
     eac:	pop    %rbx
     ead:	pop    %r12
     eaf:	mov    %r13d,%eax
     eb2:	pop    %r13
     eb4:	pop    %r14
     eb6:	pop    %r15
     eb8:	pop    %rbp
     eb9:	retq   
     eba:	nopw   0x0(%rax,%rax,1)
acl_permission_check():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:291
{
	unsigned int mode = inode->i_mode;

	if (likely(uid_eq(current_fsuid(), inode->i_uid)))
		mode >>= 6;
	else {
     ec0:	cmpb   $0x0,0x0(%rip)        # ec7 <generic_permission+0xa7>
     ec7:	mov    0x0(%rip),%rax        # ece <generic_permission+0xae>
     ece:	jne    e81 <generic_permission+0x61>
     ed0:	jmp    e78 <generic_permission+0x58>
check_acl():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:241
#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl *acl;

	if (mask & MAY_NOT_BLOCK) {
		// acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);
		acl = msg_get_cached_acl_rcu(inode, ACL_TYPE_ACCESS, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
     ed2:	test   $0x80,%r14b
     ed6:	je     ff8 <generic_permission+0x1d8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:243
	        if (!acl)
	                return -EAGAIN;
     edc:	mov    0x0(%rip),%ecx        # ee2 <generic_permission+0xc2>
     ee2:	mov    0x0(%rip),%edx        # ee8 <generic_permission+0xc8>
     ee8:	mov    $0x8000,%esi
     eed:	mov    %r12,%rdi
     ef0:	callq  ef5 <generic_permission+0xd5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:244
		/* no ->get_acl() calls in RCU mode... */
     ef5:	test   %rax,%rax
     ef8:	je     fdf <generic_permission+0x1bf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:247
		if (acl == ACL_NOT_CACHED)
			return -ECHILD;
	        return posix_acl_permission(inode, acl, mask & ~MAY_NOT_BLOCK);
     efe:	cmp    $0xffffffffffffffff,%rax
     f02:	je     1091 <generic_permission+0x271>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:249
	}

     f08:	mov    %r14d,%edx
     f0b:	mov    %rax,%rsi
     f0e:	mov    %r12,%rdi
     f11:	and    $0x7f,%dl
     f14:	callq  f19 <generic_permission+0xf9>
     f19:	mov    %eax,%r13d
acl_permission_check():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:296
	else {
		if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {
			int error = check_acl(inode, mask);
			if (error != -EAGAIN)
				return error;
		}
     f1c:	cmp    $0xfffffff5,%r13d
     f20:	je     fdf <generic_permission+0x1bf>
generic_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:334
	 * Do the basic permission checks.
	 */
	ret = acl_permission_check(inode, mask);
	if (ret != -EACCES)
		return ret;

     f26:	cmp    $0xfffffff3,%r13d
     f2a:	jne    eac <generic_permission+0x8c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:337
	if (S_ISDIR(inode->i_mode)) {
		/* DACs are overridable for directories */
		if (inode_capable(inode, CAP_DAC_OVERRIDE))
     f30:	movzwl (%r12),%eax
     f35:	mov    %eax,%edx
     f37:	and    $0xf000,%dx
     f3c:	cmp    $0x4000,%dx
     f41:	je     f8c <generic_permission+0x16c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:351
	 * Executable DACs are overridable when there is
	 * at least one exec bit set.
	 */
	if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
		if (inode_capable(inode, CAP_DAC_OVERRIDE))
			return 0;
     f43:	test   $0x1,%r14b
     f47:	je     f4d <generic_permission+0x12d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:351 (discriminator 1)
     f49:	test   $0x49,%al
     f4b:	je     f62 <generic_permission+0x142>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:352

     f4d:	mov    $0x1,%esi
     f52:	mov    %r12,%rdi
     f55:	callq  f5a <generic_permission+0x13a>
     f5a:	test   %al,%al
     f5c:	jne    ea9 <generic_permission+0x89>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:358
	/*
	 * Searching includes executable on directories, else just read.
	 */
	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
	if (mask == MAY_READ)
		if (inode_capable(inode, CAP_DAC_READ_SEARCH))
     f62:	and    $0x7,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:359
			return 0;
     f66:	cmp    $0x4,%r14d
     f6a:	jne    f81 <generic_permission+0x161>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:360

     f6c:	mov    $0x2,%esi
     f71:	mov    %r12,%rdi
     f74:	callq  f79 <generic_permission+0x159>
     f79:	test   %al,%al
     f7b:	jne    ea9 <generic_permission+0x89>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:363
	return -EACCES;
}

     f81:	mov    $0xfffffff3,%r13d
     f87:	jmpq   eac <generic_permission+0x8c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:339

	if (S_ISDIR(inode->i_mode)) {
		/* DACs are overridable for directories */
		if (inode_capable(inode, CAP_DAC_OVERRIDE))
			return 0;
		if (!(mask & MAY_WRITE))
     f8c:	mov    $0x1,%esi
     f91:	mov    %r12,%rdi
     f94:	callq  f99 <generic_permission+0x179>
     f99:	test   %al,%al
     f9b:	jne    ea9 <generic_permission+0x89>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:341
			if (inode_capable(inode, CAP_DAC_READ_SEARCH))
				return 0;
     fa1:	and    $0x2,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:344
		return -EACCES;
	}
	/*
     fa5:	mov    $0xfffffff3,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:341
		/* DACs are overridable for directories */
		if (inode_capable(inode, CAP_DAC_OVERRIDE))
			return 0;
		if (!(mask & MAY_WRITE))
			if (inode_capable(inode, CAP_DAC_READ_SEARCH))
				return 0;
     fab:	jne    eac <generic_permission+0x8c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:342
		return -EACCES;
     fb1:	mov    $0x2,%esi
     fb6:	mov    %r12,%rdi
     fb9:	callq  fbe <generic_permission+0x19e>
     fbe:	test   %al,%al
     fc0:	jne    ea9 <generic_permission+0x89>
     fc6:	jmpq   eac <generic_permission+0x8c>
acl_permission_check():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:294
	if (likely(uid_eq(current_fsuid(), inode->i_uid)))
		mode >>= 6;
	else {
		if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {
			int error = check_acl(inode, mask);
			if (error != -EAGAIN)
     fcb:	mov    0x28(%r12),%rax
     fd0:	testb  $0x1,0x52(%rax)
     fd4:	je     fdf <generic_permission+0x1bf>
     fd6:	and    $0x38,%edx
     fd9:	jne    ed2 <generic_permission+0xb2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:300
				return error;
		}

		if (in_group_p(inode->i_gid))
			mode >>= 3;
	}
     fdf:	mov    0x8(%r12),%edi
     fe4:	callq  fe9 <generic_permission+0x1c9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:301

     fe9:	mov    %ebx,%edx
     feb:	shr    $0x3,%edx
     fee:	test   %eax,%eax
     ff0:	cmovne %edx,%ebx
     ff3:	jmpq   e99 <generic_permission+0x79>
get_cached_acl():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:115
}

static inline struct posix_acl *get_cached_acl(struct inode *inode, int type)
{
	struct posix_acl **p = acl_by_type(inode, type);
	struct posix_acl *acl = ACCESS_ONCE(*p);
     ff8:	mov    0x10(%r12),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:116
	if (acl) {
     ffd:	test   %rax,%rax
    1000:	je     fdf <generic_permission+0x1bf>
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    1002:	lea    0x88(%r12),%r15
    100a:	mov    %r15,%rdi
    100d:	callq  1012 <generic_permission+0x1f2>
get_cached_acl():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:118
		spin_lock(&inode->i_lock);
		acl = *p;
    1012:	mov    0x10(%r12),%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:119
		if (acl != ACL_NOT_CACHED)
    1017:	cmp    $0xffffffffffffffff,%r13
    101b:	je     1061 <generic_permission+0x241>
posix_acl_dup():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:68
 * Duplicate an ACL handle.
 */
static inline struct posix_acl *
posix_acl_dup(struct posix_acl *acl)
{
	if (acl)
    101d:	test   %r13,%r13
    1020:	je     1027 <generic_permission+0x207>
atomic_inc():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/atomic.h:91
 *
 * Atomically increments @v by 1.
 */
static inline void atomic_inc(atomic_t *v)
{
	asm volatile(LOCK_PREFIX "incl %0"
    1022:	lock incl 0x0(%r13)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    1027:	mov    %r15,%rdi
    102a:	callq  102f <generic_permission+0x20f>
check_acl():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:273
		}
	}

	if (acl) {
	        int error = posix_acl_permission(inode, acl, mask);
	        // posix_acl_release(acl);
    102f:	test   %r13,%r13
    1032:	je     fdf <generic_permission+0x1bf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:274
	        msg_posix_acl_release(acl, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    1034:	mov    %r13,%rsi
    1037:	mov    %r14d,%edx
    103a:	mov    %r12,%rdi
    103d:	callq  1042 <generic_permission+0x222>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:276
	        return error;
	}
    1042:	mov    0x0(%rip),%edx        # 1048 <generic_permission+0x228>
    1048:	mov    0x0(%rip),%esi        # 104e <generic_permission+0x22e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:274
	}

	if (acl) {
	        int error = posix_acl_permission(inode, acl, mask);
	        // posix_acl_release(acl);
	        msg_posix_acl_release(acl, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    104e:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:276
	        return error;
	}
    1051:	mov    %r13,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:277
#endif
    1054:	mov    %r15d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:276
	if (acl) {
	        int error = posix_acl_permission(inode, acl, mask);
	        // posix_acl_release(acl);
	        msg_posix_acl_release(acl, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	        return error;
	}
    1057:	callq  105c <generic_permission+0x23c>
    105c:	jmpq   f1c <generic_permission+0xfc>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
    1061:	mov    %r15,%rdi
    1064:	callq  1069 <generic_permission+0x249>
check_acl():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:263
	 * just create the negative cache entry.
	 */
	if (acl == ACL_NOT_CACHED) {
	        if (inode->i_op->get_acl) {
			acl = inode->i_op->get_acl(inode, ACL_TYPE_ACCESS);
			if (IS_ERR(acl))
    1069:	mov    0x20(%r12),%rax
    106e:	mov    0x18(%rax),%rax
    1072:	test   %rax,%rax
    1075:	je     109c <generic_permission+0x27c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:264
				return PTR_ERR(acl);
    1077:	mov    $0x8000,%esi
    107c:	mov    %r12,%rdi
    107f:	callq  *%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:265
		} else {
    1081:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:264
	 */
	if (acl == ACL_NOT_CACHED) {
	        if (inode->i_op->get_acl) {
			acl = inode->i_op->get_acl(inode, ACL_TYPE_ACCESS);
			if (IS_ERR(acl))
				return PTR_ERR(acl);
    1087:	mov    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:265
		} else {
    108a:	jbe    102f <generic_permission+0x20f>
    108c:	jmpq   f1c <generic_permission+0xfc>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:248
	                return -EAGAIN;
		/* no ->get_acl() calls in RCU mode... */
		if (acl == ACL_NOT_CACHED)
			return -ECHILD;
	        return posix_acl_permission(inode, acl, mask & ~MAY_NOT_BLOCK);
	}
    1091:	mov    $0xfffffff6,%r13d
    1097:	jmpq   eac <generic_permission+0x8c>
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    109c:	mov    %r15,%rdi
    109f:	callq  10a4 <generic_permission+0x284>
set_cached_acl():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:139
				  struct posix_acl *acl)
{
	struct posix_acl **p = acl_by_type(inode, type);
	struct posix_acl *old;
	spin_lock(&inode->i_lock);
	old = *p;
    10a4:	mov    0x10(%r12),%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:140
	rcu_assign_pointer(*p, posix_acl_dup(acl));
    10a9:	movq   $0x0,0x10(%r12)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    10b2:	mov    %r15,%rdi
    10b5:	callq  10ba <generic_permission+0x29a>
set_cached_acl():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:142
	spin_unlock(&inode->i_lock);
	if (old != ACL_NOT_CACHED)
    10ba:	cmp    $0xffffffffffffffff,%r13
    10be:	je     fdf <generic_permission+0x1bf>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    10c4:	mov    %gs:0x0,%rdx
posix_acl_release():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:79
 * Free an ACL handle.
 */
static inline void
posix_acl_release(struct posix_acl *acl)
{
  MY_PRINTK(get_current()->comm);
    10cd:	mov    $0x0,%rax
    10d4:	add    $0x4a8,%rdx
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    10db:	add    $0x1,%rdx
    10df:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    10e3:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    10e7:	cmp    -0x1(%rax),%cl
    10ea:	jne    112a <generic_permission+0x30a>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    10ec:	test   %cl,%cl
    10ee:	jne    10db <generic_permission+0x2bb>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    10f0:	mov    %gs:0x0,%rdx
posix_acl_release():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:79
    10f9:	mov    $0x0,%rsi
    1100:	add    $0x4a8,%rdx
    1107:	mov    $0x0,%rdi
    110e:	xor    %eax,%eax
    1110:	callq  1115 <generic_permission+0x2f5>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:80
	if (acl && atomic_dec_and_test(&acl->a_refcount))
    1115:	test   %r13,%r13
    1118:	je     fdf <generic_permission+0x1bf>
atomic_dec_and_test():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/atomic.h:117
 * returns true if the result is 0, or false for all other
 * cases.
 */
static inline int atomic_dec_and_test(atomic_t *v)
{
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", "e");
    111e:	lock decl 0x0(%r13)
    1123:	je     1158 <generic_permission+0x338>
    1125:	jmpq   fdf <generic_permission+0x1bf>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    112a:	mov    %gs:0x0,%rdx
posix_acl_release():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:79
 * Free an ACL handle.
 */
static inline void
posix_acl_release(struct posix_acl *acl)
{
  MY_PRINTK(get_current()->comm);
    1133:	mov    $0x0,%rax
    113a:	add    $0x4a8,%rdx
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1141:	add    $0x1,%rdx
    1145:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1149:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    114d:	cmp    -0x1(%rax),%cl
    1150:	jne    1115 <generic_permission+0x2f5>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1152:	test   %cl,%cl
    1154:	jne    1141 <generic_permission+0x321>
    1156:	jmp    10f0 <generic_permission+0x2d0>
posix_acl_release():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:81
	if (acl && atomic_dec_and_test(&acl->a_refcount))
		kfree_rcu(acl, a_rcu);
    1158:	xor    %esi,%esi
    115a:	mov    %r13,%rdi
    115d:	callq  1162 <generic_permission+0x342>
    1162:	jmpq   fdf <generic_permission+0x1bf>
generic_permission():
    1167:	nopw   0x0(%rax,%rax,1)

0000000000001170 <page_getlink.isra.21.constprop.30>:
page_getlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4364
	struct address_space *mapping = inode->i_mapping;
	struct page *page;
	void *fsdata;
	int err;
	char *kaddr;
	unsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;
    1170:	callq  1175 <page_getlink.isra.21.constprop.30+0x5>
    1175:	push   %rbp
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1176:	mov    %gs:0x0,%rdx
page_getlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4364
    117f:	mov    %rsp,%rbp
    1182:	push   %r13
read_mapping_page():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:294
}

static inline struct page *read_mapping_page(struct address_space *mapping,
				pgoff_t index, void *data)
{
  MY_PRINTK(get_current()->comm);
    1184:	add    $0x4a8,%rdx
page_getlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4364
    118b:	push   %r12
    118d:	mov    %rsi,%r12
    1190:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4368
	if (nofs)
		flags |= AOP_FLAG_NOFS;

retry:
    1191:	mov    (%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4364
	struct address_space *mapping = inode->i_mapping;
	struct page *page;
	void *fsdata;
	int err;
	char *kaddr;
	unsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;
    1194:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4368
	if (nofs)
		flags |= AOP_FLAG_NOFS;

retry:
    1197:	mov    0x30(%rax),%r13
read_mapping_page():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:294
    119b:	mov    $0x0,%rax
    11a2:	jmp    11b0 <page_getlink.isra.21.constprop.30+0x40>
    11a4:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
    11a8:	test   %cl,%cl
    11aa:	je     1260 <page_getlink.isra.21.constprop.30+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    11b0:	add    $0x1,%rdx
    11b4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    11b8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    11bc:	cmp    -0x1(%rax),%cl
    11bf:	je     11a8 <page_getlink.isra.21.constprop.30+0x38>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    11c1:	mov    %gs:0x0,%rdx
read_mapping_page():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:294
    11ca:	mov    $0x0,%rax
    11d1:	add    $0x4a8,%rdx
    11d8:	jmp    11e4 <page_getlink.isra.21.constprop.30+0x74>
    11da:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    11e0:	test   %cl,%cl
    11e2:	je     1260 <page_getlink.isra.21.constprop.30+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    11e4:	add    $0x1,%rdx
    11e8:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    11ec:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    11f0:	cmp    -0x1(%rax),%cl
    11f3:	je     11e0 <page_getlink.isra.21.constprop.30+0x70>
read_mapping_page():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:295
	filler_t *filler = (filler_t *)mapping->a_ops->readpage;
    11f5:	mov    0x70(%r13),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:296
	return read_cache_page(mapping, index, filler, data);
    11f9:	xor    %ecx,%ecx
    11fb:	xor    %esi,%esi
    11fd:	mov    %r13,%rdi
    1200:	mov    0x8(%rax),%rdx
    1204:	callq  1209 <page_getlink.isra.21.constprop.30+0x99>
page_getlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4370
	err = pagecache_write_begin(NULL, mapping, 0, len-1,
				flags, &page, &fsdata);
    1209:	cmp    $0xfffffffffffff000,%rax
read_mapping_page():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:296
    120f:	mov    %rax,%r13
page_getlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4370
    1212:	ja     1258 <page_getlink.isra.21.constprop.30+0xe8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4372
	if (err)
		goto fail;
    1214:	mov    %rax,(%r12)
kmap():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/highmem.h:59
#define totalhigh_pages 0UL

#ifndef ARCH_HAS_KMAP
static inline void *kmap(struct page *page)
{
	might_sleep();
    1218:	callq  121d <page_getlink.isra.21.constprop.30+0xad>
lowmem_page_address():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/mm.h:841
    121d:	movabs $0x160000000000,%rax
page_getlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4374

	kaddr = kmap_atomic(page);
    1227:	mov    (%rbx),%rcx
nd_terminate_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:98
}

static inline void nd_terminate_link(void *name, size_t len, size_t maxlen)
{
	((char *) name)[min(len, maxlen)] = '\0';
    122a:	mov    $0xfff,%edx
lowmem_page_address():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/mm.h:841
    122f:	add    %r13,%rax
    1232:	movabs $0xffff880000000000,%r13
    123c:	sar    $0x6,%rax
    1240:	shl    $0xc,%rax
    1244:	add    %r13,%rax
nd_terminate_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:98
    1247:	cmpq   $0xfff,0x50(%rcx)
    124f:	cmovbe 0x50(%rcx),%rdx
    1254:	movb   $0x0,(%rax,%rdx,1)
page_getlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4376
	memcpy(kaddr, symname, len-1);
	kunmap_atomic(kaddr);
    1258:	pop    %rbx
    1259:	pop    %r12
    125b:	pop    %r13
    125d:	pop    %rbp
    125e:	retq   
    125f:	nop
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1260:	mov    %gs:0x0,%rdx
read_mapping_page():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/pagemap.h:294
}

static inline struct page *read_mapping_page(struct address_space *mapping,
				pgoff_t index, void *data)
{
  MY_PRINTK(get_current()->comm);
    1269:	mov    $0x0,%rsi
    1270:	add    $0x4a8,%rdx
    1277:	mov    $0x0,%rdi
    127e:	xor    %eax,%eax
    1280:	callq  1285 <page_getlink.isra.21.constprop.30+0x115>
    1285:	jmpq   11f5 <page_getlink.isra.21.constprop.30+0x85>
page_getlink.isra.21.constprop.30():
    128a:	nopw   0x0(%rax,%rax,1)

0000000000001290 <page_follow_link_light>:
page_follow_link_light():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4391
	return 0;
fail:
	return err;
}

int page_symlink(struct inode *inode, const char *symname, int len)
    1290:	callq  1295 <page_follow_link_light+0x5>
    1295:	push   %rbp
    1296:	add    $0x30,%rdi
    129a:	mov    %rsp,%rbp
    129d:	push   %rbx
    129e:	mov    %rsi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4393
{
	return __page_symlink(inode, symname, len,
    12a1:	lea    -0x10(%rbp),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4391
	return 0;
fail:
	return err;
}

int page_symlink(struct inode *inode, const char *symname, int len)
    12a5:	sub    $0x8,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4392
{
    12a9:	movq   $0x0,-0x10(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4393
	return __page_symlink(inode, symname, len,
    12b1:	callq  1170 <page_getlink.isra.21.constprop.30>
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88

extern void nd_jump_link(struct nameidata *nd, struct path *path);

static inline void nd_set_link(struct nameidata *nd, char *path)
{
	nd->saved_names[nd->depth] = path;
    12b6:	mov    0x48(%rbx),%edx
    12b9:	mov    %rax,0x50(%rbx,%rdx,8)
page_follow_link_light():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4395
			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
}
    12be:	mov    -0x10(%rbp),%rax
    12c2:	add    $0x8,%rsp
    12c6:	pop    %rbx
    12c7:	pop    %rbp
    12c8:	retq   
    12c9:	nopl   0x0(%rax)

00000000000012d0 <page_readlink>:
page_readlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4379
	kaddr = kmap_atomic(page);
	memcpy(kaddr, symname, len-1);
	kunmap_atomic(kaddr);

	err = pagecache_write_end(NULL, mapping, 0, len-1, len-1,
							page, fsdata);
    12d0:	callq  12d5 <page_readlink+0x5>
    12d5:	push   %rbp
    12d6:	mov    %rsp,%rbp
    12d9:	push   %r13
    12db:	mov    %edx,%r13d
    12de:	push   %r12
    12e0:	mov    %rsi,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4381
	if (err < 0)
		goto fail;
    12e3:	lea    -0x20(%rbp),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4379
	kaddr = kmap_atomic(page);
	memcpy(kaddr, symname, len-1);
	kunmap_atomic(kaddr);

	err = pagecache_write_end(NULL, mapping, 0, len-1, len-1,
							page, fsdata);
    12e7:	push   %rbx
    12e8:	mov    %rdi,%rbx
    12eb:	lea    0x30(%rdi),%rdi
    12ef:	sub    $0x8,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4380
	if (err < 0)
    12f3:	movq   $0x0,-0x20(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4381
		goto fail;
    12fb:	callq  1170 <page_getlink.isra.21.constprop.30>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4382
	if (err < len-1)
    1300:	mov    %rbx,%rdi
    1303:	mov    %rax,%rcx
    1306:	mov    %r13d,%edx
    1309:	mov    %r12,%rsi
    130c:	callq  1311 <page_readlink+0x41>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4383
		goto retry;
    1311:	mov    -0x20(%rbp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4382

	err = pagecache_write_end(NULL, mapping, 0, len-1, len-1,
							page, fsdata);
	if (err < 0)
		goto fail;
	if (err < len-1)
    1315:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4383
		goto retry;
    1317:	test   %rdi,%rdi
    131a:	je     1321 <page_readlink+0x51>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4385

	mark_inode_dirty(inode);
    131c:	callq  1321 <page_readlink+0x51>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4388
	return 0;
fail:
	return err;
    1321:	add    $0x8,%rsp
    1325:	mov    %ebx,%eax
    1327:	pop    %rbx
    1328:	pop    %r12
    132a:	pop    %r13
    132c:	pop    %rbp
    132d:	retq   
    132e:	xchg   %ax,%ax

0000000000001330 <my_strcmp.constprop.33>:
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:7
#define _INTERACTIVE_DESIGN_H

//#include<linux/my_msg.h>
#include<linux/sched.h>

static int my_strcmp(const char *cs, const char *ct) {
    1330:	callq  1335 <my_strcmp.constprop.33+0x5>
    1335:	push   %rbp
    1336:	mov    $0x0,%rax
    133d:	mov    %rsp,%rbp
    1340:	jmp    134c <my_strcmp.constprop.33+0x1c>
    1342:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1348:	test   %dl,%dl
    134a:	je     1368 <my_strcmp.constprop.33+0x38>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    134c:	add    $0x1,%rdi
    1350:	movzbl -0x1(%rdi),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1354:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1358:	cmp    -0x1(%rax),%dl
    135b:	je     1348 <my_strcmp.constprop.33+0x18>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:14
			return c1 < c2 ? -1 : 1;
    135d:	sbb    %eax,%eax
    135f:	or     $0x1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:19
		if (!c1)
			break;
	}
	return 0;
}
    1362:	pop    %rbp
    1363:	retq   
    1364:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:18
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
			break;
	}
	return 0;
    1368:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:19
}
    136a:	pop    %rbp
    136b:	retq   
my_strcmp.constprop.33():
    136c:	nopl   0x0(%rax)

0000000000001370 <my_strcmp_base.constprop.35>:
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:22
}

static int my_strcmp_base(const char *cs, const char *ct) {
    1370:	callq  1375 <my_strcmp_base.constprop.35+0x5>
    1375:	push   %rbp
    1376:	mov    $0x0,%rax
    137d:	mov    %rsp,%rbp
    1380:	jmp    138c <my_strcmp_base.constprop.35+0x1c>
    1382:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1388:	test   %dl,%dl
    138a:	je     13a8 <my_strcmp_base.constprop.35+0x38>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    138c:	add    $0x1,%rdi
    1390:	movzbl -0x1(%rdi),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    1394:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    1398:	cmp    -0x1(%rax),%dl
    139b:	je     1388 <my_strcmp_base.constprop.35+0x18>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:29
			return c1 < c2 ? -1 : 1;
    139d:	sbb    %eax,%eax
    139f:	or     $0x1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:34
		if (!c1)
			break;
	}
	return 0;
}
    13a2:	pop    %rbp
    13a3:	retq   
    13a4:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:33
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
			break;
	}
	return 0;
    13a8:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:34
}
    13aa:	pop    %rbp
    13ab:	retq   
my_strcmp_base.constprop.35():
    13ac:	nopl   0x0(%rax)

00000000000013b0 <full_name_hash>:
full_name_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1655
		if (len < sizeof(unsigned long))
			break;
		hash += a;
		hash *= 9;
		name += sizeof(unsigned long);
		len -= sizeof(unsigned long);
    13b0:	callq  13b5 <full_name_hash+0x5>
    13b5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1657
		if (!len)
			goto done;
    13b6:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1655
		if (len < sizeof(unsigned long))
			break;
		hash += a;
		hash *= 9;
		name += sizeof(unsigned long);
		len -= sizeof(unsigned long);
    13b8:	mov    %rsp,%rbp
    13bb:	jmp    13d0 <full_name_hash+0x20>
    13bd:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1663
	}
	mask = bytemask_from_count(len);
	hash += mask & a;
done:
	return fold_hash(hash);
}
    13c0:	add    %rdx,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1665
EXPORT_SYMBOL(full_name_hash);

    13c3:	add    $0x8,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1667
/*
 * Calculate the length and hash of the path component, and
    13c7:	sub    $0x8,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1664
	mask = bytemask_from_count(len);
	hash += mask & a;
done:
	return fold_hash(hash);
}
EXPORT_SYMBOL(full_name_hash);
    13ca:	lea    (%rax,%rax,8),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1667

/*
 * Calculate the length and hash of the path component, and
    13ce:	je     13f2 <full_name_hash+0x42>
load_unaligned_zeropad():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:83
 */
static inline unsigned long load_unaligned_zeropad(const void *addr)
{
	unsigned long ret, dummy;

	asm(
    13d0:	mov    (%rdi),%rdx
full_name_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1661
		if (!len)
			goto done;
	}
	mask = bytemask_from_count(len);
	hash += mask & a;
done:
    13d3:	cmp    $0x7,%esi
    13d6:	ja     13c0 <full_name_hash+0x10>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1670

/*
 * Calculate the length and hash of the path component, and
 * return the length of the component;
 */
static inline unsigned long hash_name(const char *name, unsigned int *hashp)
    13d8:	lea    0x0(,%rsi,8),%ecx
    13df:	mov    $0xffffffffffffffff,%rdi
    13e6:	shl    %cl,%rdi
    13e9:	not    %rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1671
{
    13ec:	and    %rdx,%rdi
    13ef:	add    %rdi,%rax
fold_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1644
#define fold_hash(x) (x)

#endif

unsigned int full_name_hash(const unsigned char *name, unsigned int len)
{
    13f2:	mov    %rax,%rdx
    13f5:	shr    $0x20,%rdx
    13f9:	add    %rdx,%rax
full_name_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1674
 */
static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long a, b, adata, bdata, mask, hash, len;
	const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;

    13fc:	pop    %rbp
    13fd:	retq   
    13fe:	xchg   %ax,%ax

0000000000001400 <path_get>:
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:474
 * Given a path increment the reference count to the dentry and the vfsmount.
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
    1400:	callq  1405 <path_get+0x5>
    1405:	push   %rbp
    1406:	mov    %rsp,%rbp
    1409:	push   %rbx
    140a:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
}
    140d:	mov    (%rdi),%rdi
    1410:	callq  1415 <path_get+0x15>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    1415:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    141e:	mov    0x8(%rbx),%rbx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1422:	add    $0x4a8,%rdx
    1429:	mov    $0x0,%rax
    1430:	jmp    143c <path_get+0x3c>
    1432:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1438:	test   %cl,%cl
    143a:	je     14a0 <path_get+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    143c:	add    $0x1,%rdx
    1440:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1444:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1448:	cmp    -0x1(%rax),%cl
    144b:	je     1438 <path_get+0x38>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    144d:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1456:	mov    $0x0,%rax
    145d:	add    $0x4a8,%rdx
    1464:	jmp    1474 <path_get+0x74>
    1466:	nopw   %cs:0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1470:	test   %cl,%cl
    1472:	je     14a0 <path_get+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1474:	add    $0x1,%rdx
    1478:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    147c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1480:	cmp    -0x1(%rax),%cl
    1483:	je     1470 <path_get+0x70>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    1485:	test   %rbx,%rbx
    1488:	je     1493 <path_get+0x93>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    148a:	lea    0x58(%rbx),%rdi
    148e:	callq  1493 <path_get+0x93>
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:477

    1493:	pop    %rbx
    1494:	pop    %rbp
    1495:	retq   
    1496:	nopw   %cs:0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    14a0:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    14a9:	mov    $0x0,%rsi
    14b0:	add    $0x4a8,%rdx
    14b7:	mov    $0x0,%rdi
    14be:	xor    %eax,%eax
    14c0:	callq  14c5 <path_get+0xc5>
    14c5:	jmp    1485 <path_get+0x85>
path_get():
    14c7:	nopw   0x0(%rax,%rax,1)

00000000000014d0 <follow_down_one>:
follow_down_one():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1088
{
	struct vfsmount *mounted;

	mounted = lookup_mnt(path);
	if (mounted) {
		dput(path->dentry);
    14d0:	callq  14d5 <follow_down_one+0x5>
    14d5:	push   %rbp
    14d6:	mov    %rsp,%rbp
    14d9:	push   %r12
    14db:	push   %rbx
    14dc:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1091
		mntput(path->mnt);
		path->mnt = mounted;
		path->dentry = dget(mounted->mnt_root);
    14df:	callq  14e4 <follow_down_one+0x14>
    14e4:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1099
	return 0;
}

static inline bool managed_dentry_might_block(struct dentry *dentry)
{
	return (dentry->d_flags & DCACHE_MANAGE_TRANSIT &&
    14e7:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1092
	if (mounted) {
		dput(path->dentry);
		mntput(path->mnt);
		path->mnt = mounted;
		path->dentry = dget(mounted->mnt_root);
		return 1;
    14e9:	test   %r12,%r12
    14ec:	je     158d <follow_down_one+0xbd>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1093
	}
    14f2:	mov    0x8(%rbx),%rdi
    14f6:	callq  14fb <follow_down_one+0x2b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1094
	return 0;
    14fb:	mov    (%rbx),%rdi
    14fe:	callq  1503 <follow_down_one+0x33>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1095
}
    1503:	mov    %r12,(%rbx)
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1506:	mov    $0x0,%rax
follow_down_one():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1096

    150d:	mov    (%r12),%r12
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1511:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    151a:	add    $0x4a8,%rdx
    1521:	jmp    152c <follow_down_one+0x5c>
    1523:	nopl   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1528:	test   %cl,%cl
    152a:	je     1598 <follow_down_one+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    152c:	add    $0x1,%rdx
    1530:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1534:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1538:	cmp    -0x1(%rax),%cl
    153b:	je     1528 <follow_down_one+0x58>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    153d:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1546:	mov    $0x0,%rax
    154d:	add    $0x4a8,%rdx
    1554:	jmp    1564 <follow_down_one+0x94>
    1556:	nopw   %cs:0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1560:	test   %cl,%cl
    1562:	je     1598 <follow_down_one+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1564:	add    $0x1,%rdx
    1568:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    156c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1570:	cmp    -0x1(%rax),%cl
    1573:	je     1560 <follow_down_one+0x90>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    1575:	test   %r12,%r12
    1578:	je     1584 <follow_down_one+0xb4>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    157a:	lea    0x58(%r12),%rdi
    157f:	callq  1584 <follow_down_one+0xb4>
follow_down_one():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1096
    1584:	mov    %r12,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1097
static inline bool managed_dentry_might_block(struct dentry *dentry)
    1588:	mov    $0x1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1100
{
	return (dentry->d_flags & DCACHE_MANAGE_TRANSIT &&
		dentry->d_op->d_manage(dentry, true) < 0);
    158d:	pop    %rbx
    158e:	pop    %r12
    1590:	pop    %rbp
    1591:	retq   
    1592:	nopw   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1598:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    15a1:	mov    $0x0,%rsi
    15a8:	add    $0x4a8,%rdx
    15af:	mov    $0x0,%rdi
    15b6:	xor    %eax,%eax
    15b8:	callq  15bd <follow_down_one+0xed>
    15bd:	jmp    1575 <follow_down_one+0xa5>
follow_down_one():
    15bf:	nop

00000000000015c0 <follow_mount>:
follow_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1247
	while (d_mountpoint(path->dentry)) {
		struct vfsmount *mounted = lookup_mnt(path);
		if (!mounted)
			break;
		dput(path->dentry);
		mntput(path->mnt);
    15c0:	callq  15c5 <follow_mount+0x5>
    15c5:	push   %rbp
    15c6:	mov    %rsp,%rbp
    15c9:	push   %r15
    15cb:	push   %r14
    15cd:	push   %r13
    15cf:	push   %r12
    15d1:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1252
		path->mnt = mounted;
		path->dentry = dget(mounted->mnt_root);
	}
}

    15d2:	mov    0x8(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1247
	while (d_mountpoint(path->dentry)) {
		struct vfsmount *mounted = lookup_mnt(path);
		if (!mounted)
			break;
		dput(path->dentry);
		mntput(path->mnt);
    15d6:	mov    %rdi,%rbx
d_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:406
	return dentry->d_flags & DCACHE_MANAGED_DENTRY;
}

static inline bool d_mountpoint(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_MOUNTED;
    15d9:	mov    (%rax),%eax
follow_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1248
		path->mnt = mounted;
    15db:	test   $0x10000,%eax
    15e0:	je     169d <follow_mount+0xdd>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    15e6:	mov    %gs:0x0,%r12
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    15ef:	lea    0x4a8(%r12),%r14
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    15f7:	mov    %r12,%r13
    15fa:	nopw   0x0(%rax,%rax,1)
follow_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1249
		path->dentry = dget(mounted->mnt_root);
    1600:	mov    %rbx,%rdi
    1603:	callq  1608 <follow_mount+0x48>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1250
	}
    1608:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1249
		if (!mounted)
			break;
		dput(path->dentry);
		mntput(path->mnt);
		path->mnt = mounted;
		path->dentry = dget(mounted->mnt_root);
    160b:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1250
	}
    160e:	je     169d <follow_mount+0xdd>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1252
}

    1614:	mov    0x8(%rbx),%rdi
    1618:	callq  161d <follow_mount+0x5d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1253
static void follow_dotdot(struct nameidata *nd)
    161d:	mov    (%rbx),%rdi
    1620:	callq  1625 <follow_mount+0x65>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1254
{
    1625:	mov    %r15,(%rbx)
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1628:	lea    0x4a8(%r12),%rdx
follow_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1255
	set_root(nd);
    1630:	mov    (%r15),%r15
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1633:	mov    $0x0,%rax
    163a:	jmp    1644 <follow_mount+0x84>
    163c:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1640:	test   %cl,%cl
    1642:	je     16b0 <follow_mount+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1644:	add    $0x1,%rdx
    1648:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    164c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1650:	cmp    -0x1(%rax),%cl
    1653:	je     1640 <follow_mount+0x80>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1655:	lea    0x4a8(%r13),%rdx
    165c:	mov    $0x0,%rax
    1663:	jmp    166c <follow_mount+0xac>
    1665:	nopl   (%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1668:	test   %cl,%cl
    166a:	je     16b0 <follow_mount+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    166c:	add    $0x1,%rdx
    1670:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1674:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1678:	cmp    -0x1(%rax),%cl
    167b:	je     1668 <follow_mount+0xa8>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    167d:	test   %r15,%r15
    1680:	je     168b <follow_mount+0xcb>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    1682:	lea    0x58(%r15),%rdi
    1686:	callq  168b <follow_mount+0xcb>
follow_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1255
    168b:	mov    %r15,0x8(%rbx)
d_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:406
	return dentry->d_flags & DCACHE_MANAGED_DENTRY;
}

static inline bool d_mountpoint(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_MOUNTED;
    168f:	mov    (%r15),%eax
follow_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1248
		struct vfsmount *mounted = lookup_mnt(path);
		if (!mounted)
			break;
		dput(path->dentry);
		mntput(path->mnt);
		path->mnt = mounted;
    1692:	test   $0x10000,%eax
    1697:	jne    1600 <follow_mount+0x40>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1257

static void follow_dotdot(struct nameidata *nd)
{
	set_root(nd);

	while(1) {
    169d:	pop    %rbx
    169e:	pop    %r12
    16a0:	pop    %r13
    16a2:	pop    %r14
    16a4:	pop    %r15
    16a6:	pop    %rbp
    16a7:	retq   
    16a8:	nopl   0x0(%rax,%rax,1)
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    16b0:	mov    %r14,%rdx
    16b3:	mov    $0x0,%rsi
    16ba:	mov    $0x0,%rdi
    16c1:	xor    %eax,%eax
    16c3:	callq  16c8 <follow_mount+0x108>
    16c8:	jmp    167d <follow_mount+0xbd>
follow_mount():
    16ca:	nopw   0x0(%rax,%rax,1)

00000000000016d0 <get_fs_root>:
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:27
extern struct fs_struct *copy_fs_struct(struct fs_struct *);
extern void free_fs_struct(struct fs_struct *);
extern int unshare_fs_struct(void);

static inline void get_fs_root(struct fs_struct *fs, struct path *root)
{
    16d0:	push   %rbp
    16d1:	mov    %rsp,%rbp
    16d4:	push   %r13
    16d6:	mov    %rdi,%r13
    16d9:	push   %r12
    16db:	mov    %rsi,%r12
    16de:	push   %rbx
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    16df:	lea    0x4(%rdi),%rbx
    16e3:	mov    %rbx,%rdi
    16e6:	callq  16eb <get_fs_root+0x1b>
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:29
	spin_lock(&fs->lock);
	*root = fs->root;
    16eb:	mov    0x18(%r13),%rax
    16ef:	mov    0x20(%r13),%rdx
    16f3:	mov    %rax,%rdi
    16f6:	mov    %rdx,0x8(%r12)
    16fb:	mov    %rax,(%r12)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    16ff:	callq  1704 <get_fs_root+0x34>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1704:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    170d:	mov    0x8(%r12),%r12
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1712:	add    $0x4a8,%rdx
    1719:	mov    $0x0,%rax
    1720:	jmp    172c <get_fs_root+0x5c>
    1722:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1728:	test   %cl,%cl
    172a:	je     1798 <get_fs_root+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    172c:	add    $0x1,%rdx
    1730:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1734:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1738:	cmp    -0x1(%rax),%cl
    173b:	je     1728 <get_fs_root+0x58>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    173d:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1746:	mov    $0x0,%rax
    174d:	add    $0x4a8,%rdx
    1754:	jmp    1764 <get_fs_root+0x94>
    1756:	nopw   %cs:0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1760:	test   %cl,%cl
    1762:	je     1798 <get_fs_root+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1764:	add    $0x1,%rdx
    1768:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    176c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1770:	cmp    -0x1(%rax),%cl
    1773:	je     1760 <get_fs_root+0x90>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    1775:	test   %r12,%r12
    1778:	je     1784 <get_fs_root+0xb4>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    177a:	lea    0x58(%r12),%rdi
    177f:	callq  1784 <get_fs_root+0xb4>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    1784:	mov    %rbx,%rdi
    1787:	callq  178c <get_fs_root+0xbc>
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:32
	path_get(root);
	spin_unlock(&fs->lock);
}
    178c:	pop    %rbx
    178d:	pop    %r12
    178f:	pop    %r13
    1791:	pop    %rbp
    1792:	retq   
    1793:	nopl   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1798:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    17a1:	mov    $0x0,%rsi
    17a8:	add    $0x4a8,%rdx
    17af:	mov    $0x0,%rdi
    17b6:	xor    %eax,%eax
    17b8:	callq  17bd <get_fs_root+0xed>
    17bd:	jmp    1775 <get_fs_root+0xa5>
get_fs_root():
    17bf:	nop

00000000000017c0 <unlazy_walk>:
unlazy_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:515
 * @nd or NULL.  Must be called from rcu-walk context.
 */
static int unlazy_walk(struct nameidata *nd, struct dentry *dentry)
{
	struct fs_struct *fs = current->fs;
	struct dentry *parent = nd->path.dentry;
    17c0:	callq  17c5 <unlazy_walk+0x5>
    17c5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:516

    17c6:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    17cd:	mov    %gs:0x0,%rdx
unlazy_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:515
 * @nd or NULL.  Must be called from rcu-walk context.
 */
static int unlazy_walk(struct nameidata *nd, struct dentry *dentry)
{
	struct fs_struct *fs = current->fs;
	struct dentry *parent = nd->path.dentry;
    17d6:	mov    %rsp,%rbp
    17d9:	push   %r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:516

    17db:	add    $0x4a8,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:515
 * @nd or NULL.  Must be called from rcu-walk context.
 */
static int unlazy_walk(struct nameidata *nd, struct dentry *dentry)
{
	struct fs_struct *fs = current->fs;
	struct dentry *parent = nd->path.dentry;
    17e2:	push   %r13
    17e4:	push   %r12
    17e6:	mov    %rsi,%r12
    17e9:	push   %rbx
    17ea:	mov    %rdi,%rbx
    17ed:	jmp    17f8 <unlazy_walk+0x38>
    17ef:	nop
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    17f0:	test   %cl,%cl
    17f2:	je     1890 <unlazy_walk+0xd0>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    17f8:	add    $0x1,%rdx
    17fc:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    1800:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    1804:	cmp    -0x1(%rax),%cl
    1807:	je     17f0 <unlazy_walk+0x30>
unlazy_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:516

    1809:	mov    %gs:0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:519 (discriminator 3)
	BUG_ON(!(nd->flags & LOOKUP_RCU));

	/*
    1812:	testb  $0x40,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:516 (discriminator 3)
 */
static int unlazy_walk(struct nameidata *nd, struct dentry *dentry)
{
	struct fs_struct *fs = current->fs;
	struct dentry *parent = nd->path.dentry;

    1816:	mov    0x588(%rax),%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:517 (discriminator 3)
	BUG_ON(!(nd->flags & LOOKUP_RCU));
    181d:	mov    0x8(%rbx),%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:519 (discriminator 3)

	/*
    1821:	je     19d9 <unlazy_walk+0x219>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:529
	 * can't be legitimized, just set nd->path.dentry to NULL
	 * and rely on dput(NULL) being a no-op.
	 */
	if (!legitimize_mnt(nd->path.mnt, nd->m_seq))
		return -ECHILD;
	nd->flags &= ~LOOKUP_RCU;
    1827:	mov    0x40(%rbx),%esi
    182a:	mov    (%rbx),%rdi
    182d:	callq  1832 <unlazy_walk+0x72>
    1832:	test   %al,%al
    1834:	je     186c <unlazy_walk+0xac>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:531

	if (!lockref_get_not_dead(&parent->d_lockref)) {
    1836:	andl   $0xffffffbf,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:533
		nd->path.dentry = NULL;	
		goto out;
    183a:	lea    0x58(%r13),%rdi
    183e:	callq  1843 <unlazy_walk+0x83>
    1843:	test   %eax,%eax
    1845:	je     1880 <unlazy_walk+0xc0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:549
	 * the child sequence number. So we know the parent must still
	 * be valid if the child sequence number is still valid.
	 */
	if (!dentry) {
		if (read_seqcount_retry(&parent->d_seq, nd->seq))
			goto out;
    1847:	test   %r12,%r12
    184a:	je     1900 <unlazy_walk+0x140>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:554
		BUG_ON(nd->inode != parent->d_inode);
	} else {
		if (!lockref_get_not_dead(&dentry->d_lockref))
			goto out;
		if (read_seqcount_retry(&dentry->d_seq, nd->seq))
    1850:	lea    0x58(%r12),%rdi
    1855:	callq  185a <unlazy_walk+0x9a>
    185a:	test   %eax,%eax
    185c:	jne    18b0 <unlazy_walk+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:584
out:
	rcu_read_unlock();
drop_root_mnt:
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
	return -ECHILD;
    185e:	testb  $0x20,0x39(%rbx)
    1862:	jne    186c <unlazy_walk+0xac>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:585
}
    1864:	movq   $0x0,0x20(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:587

static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
    186c:	pop    %rbx
    186d:	pop    %r12
    186f:	pop    %r13
    1871:	pop    %r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:586
drop_root_mnt:
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
	return -ECHILD;
}

    1873:	mov    $0xfffffff6,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:587
static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
    1878:	pop    %rbp
    1879:	retq   
    187a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:534
	nd->flags &= ~LOOKUP_RCU;

	if (!lockref_get_not_dead(&parent->d_lockref)) {
		nd->path.dentry = NULL;	
		goto out;
	}
    1880:	movq   $0x0,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:535

    1888:	jmp    185e <unlazy_walk+0x9e>
    188a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:516
 */
static int unlazy_walk(struct nameidata *nd, struct dentry *dentry)
{
	struct fs_struct *fs = current->fs;
	struct dentry *parent = nd->path.dentry;

    1890:	cmpb   $0x0,0x0(%rip)        # 1897 <unlazy_walk+0xd7>
    1897:	mov    0x0(%rip),%rax        # 189e <unlazy_walk+0xde>
    189e:	jne    1812 <unlazy_walk+0x52>
    18a4:	jmpq   1809 <unlazy_walk+0x49>
    18a9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:556
	} else {
		if (!lockref_get_not_dead(&dentry->d_lockref))
			goto out;
		if (read_seqcount_retry(&dentry->d_seq, nd->seq))
			goto drop_dentry;
	}
    18b0:	mov    0x3c(%rbx),%eax
    18b3:	cmp    0x4(%r12),%eax
    18b8:	jne    18f0 <unlazy_walk+0x130>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:564
	 * Sequence counts matched. Now make sure that the root is
	 * still valid and get it if required.
	 */
	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {
		spin_lock(&fs->lock);
		if (nd->root.mnt != fs->root.mnt || nd->root.dentry != fs->root.dentry)
    18ba:	cmpq   $0x0,0x20(%rbx)
    18bf:	je     18c7 <unlazy_walk+0x107>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:564 (discriminator 1)
    18c1:	testb  $0x20,0x39(%rbx)
    18c5:	je     18d2 <unlazy_walk+0x112>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:573
	}

	rcu_read_unlock();
	return 0;

unlock_and_drop_dentry:
    18c7:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:587
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
	return -ECHILD;
}

static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
    18c9:	pop    %rbx
    18ca:	pop    %r12
    18cc:	pop    %r13
    18ce:	pop    %r14
    18d0:	pop    %rbp
    18d1:	retq   
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    18d2:	lea    0x4(%r14),%r13
    18d6:	mov    %r13,%rdi
    18d9:	callq  18de <unlazy_walk+0x11e>
unlazy_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:566
	 */
	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {
		spin_lock(&fs->lock);
		if (nd->root.mnt != fs->root.mnt || nd->root.dentry != fs->root.dentry)
			goto unlock_and_drop_dentry;
		path_get(&nd->root);
    18de:	mov    0x20(%rbx),%rdi
    18e2:	cmp    0x18(%r14),%rdi
    18e6:	je     1920 <unlazy_walk+0x160>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    18e8:	mov    %r13,%rdi
    18eb:	callq  18f0 <unlazy_walk+0x130>
unlazy_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:579
	spin_unlock(&fs->lock);
drop_dentry:
	rcu_read_unlock();
	dput(dentry);
	goto drop_root_mnt;
out:
    18f0:	mov    %r12,%rdi
    18f3:	callq  18f8 <unlazy_walk+0x138>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:580
	rcu_read_unlock();
    18f8:	jmpq   185e <unlazy_walk+0x9e>
    18fd:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:550
	 * be valid if the child sequence number is still valid.
	 */
	if (!dentry) {
		if (read_seqcount_retry(&parent->d_seq, nd->seq))
			goto out;
		BUG_ON(nd->inode != parent->d_inode);
    1900:	mov    0x3c(%rbx),%eax
    1903:	cmp    0x4(%r13),%eax
    1907:	jne    185e <unlazy_walk+0x9e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:552
	} else {
		if (!lockref_get_not_dead(&dentry->d_lockref))
    190d:	mov    0x30(%r13),%rax
    1911:	cmp    %rax,0x30(%rbx)
    1915:	je     18ba <unlazy_walk+0xfa>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:552 (discriminator 1)
    1917:	ud2    
    1919:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:566 (discriminator 1)
	 */
	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {
		spin_lock(&fs->lock);
		if (nd->root.mnt != fs->root.mnt || nd->root.dentry != fs->root.dentry)
			goto unlock_and_drop_dentry;
		path_get(&nd->root);
    1920:	mov    0x20(%r14),%rax
    1924:	cmp    %rax,0x28(%rbx)
    1928:	jne    18e8 <unlazy_walk+0x128>
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    192a:	callq  192f <unlazy_walk+0x16f>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    192f:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    1938:	mov    0x28(%rbx),%rbx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    193c:	add    $0x4a8,%rdx
    1943:	mov    $0x0,%rax
    194a:	jmp    1950 <unlazy_walk+0x190>
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    194c:	test   %cl,%cl
    194e:	je     19b2 <unlazy_walk+0x1f2>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1950:	add    $0x1,%rdx
    1954:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1958:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    195c:	cmp    -0x1(%rax),%cl
    195f:	je     194c <unlazy_walk+0x18c>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1961:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    196a:	mov    $0x0,%rax
    1971:	add    $0x4a8,%rdx
    1978:	jmp    1984 <unlazy_walk+0x1c4>
    197a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1980:	test   %cl,%cl
    1982:	je     19b2 <unlazy_walk+0x1f2>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1984:	add    $0x1,%rdx
    1988:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    198c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1990:	cmp    -0x1(%rax),%cl
    1993:	je     1980 <unlazy_walk+0x1c0>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    1995:	test   %rbx,%rbx
    1998:	je     19a3 <unlazy_walk+0x1e3>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    199a:	lea    0x58(%rbx),%rdi
    199e:	callq  19a3 <unlazy_walk+0x1e3>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
    19a3:	mov    %r13,%rdi
    19a6:	callq  19ab <unlazy_walk+0x1eb>
unlazy_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:573
	}

	rcu_read_unlock();
	return 0;

unlock_and_drop_dentry:
    19ab:	xor    %eax,%eax
    19ad:	jmpq   18c9 <unlazy_walk+0x109>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    19b2:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    19bb:	mov    $0x0,%rsi
    19c2:	add    $0x4a8,%rdx
    19c9:	mov    $0x0,%rdi
    19d0:	xor    %eax,%eax
    19d2:	callq  19d7 <unlazy_walk+0x217>
    19d7:	jmp    1995 <unlazy_walk+0x1d5>
unlazy_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:519 (discriminator 1)
	struct fs_struct *fs = current->fs;
	struct dentry *parent = nd->path.dentry;

	BUG_ON(!(nd->flags & LOOKUP_RCU));

	/*
    19d9:	ud2    
    19db:	nopl   0x0(%rax,%rax,1)

00000000000019e0 <lookup_fast>:
lookup_fast():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1370
	int err;

	/*
	 * Rename seqlock is not required here because in the off chance
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
    19e0:	callq  19e5 <lookup_fast+0x5>
    19e5:	push   %rbp
    19e6:	mov    %rsp,%rbp
    19e9:	push   %r15
    19eb:	push   %r14
    19ed:	mov    %rdi,%r14
    19f0:	push   %r13
    19f2:	push   %r12
    19f4:	mov    %rdx,%r12
    19f7:	push   %rbx
    19f8:	mov    %rsi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1384
		 * This sequence count validates that the inode matches
		 * the dentry name information from lookup.
		 */
		*inode = dentry->d_inode;
		if (read_seqcount_retry(&dentry->d_seq, seq))
			return -ECHILD;
    19fb:	lea    0x10(%rdi),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1370
	int err;

	/*
	 * Rename seqlock is not required here because in the off chance
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
    19ff:	sub    $0x18,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1382

		/*
		 * This sequence count validates that the inode matches
		 * the dentry name information from lookup.
		 */
		*inode = dentry->d_inode;
    1a03:	testb  $0x40,0x38(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1371

	/*
	 * Rename seqlock is not required here because in the off chance
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
    1a07:	mov    (%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1372
	if (nd->flags & LOOKUP_RCU) {
    1a0a:	mov    0x8(%rdi),%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1371

	/*
	 * Rename seqlock is not required here because in the off chance
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
    1a0e:	mov    %rax,-0x38(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1382

		/*
		 * This sequence count validates that the inode matches
		 * the dentry name information from lookup.
		 */
		*inode = dentry->d_inode;
    1a12:	je     1b30 <lookup_fast+0x150>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1384
		if (read_seqcount_retry(&dentry->d_seq, seq))
			return -ECHILD;
    1a18:	lea    -0x2c(%rbp),%rdx
    1a1c:	mov    %r15,%rdi
    1a1f:	callq  1a24 <lookup_fast+0x44>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1385

    1a24:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1384
		 * This sequence count validates that the inode matches
		 * the dentry name information from lookup.
		 */
		*inode = dentry->d_inode;
		if (read_seqcount_retry(&dentry->d_seq, seq))
			return -ECHILD;
    1a27:	mov    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1385

    1a2a:	je     1beb <lookup_fast+0x20b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1392
		 * This sequence count validates that the parent had no
		 * changes while we did the lookup of the dentry above.
		 *
		 * The memory barrier in read_seqcount_begin of child is
		 *  enough, we can use __read_seqcount_retry here.
		 */
    1a30:	mov    0x30(%rax),%rax
    1a34:	mov    %rax,(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1393
		if (__read_seqcount_retry(&parent->d_seq, nd->seq))
    1a38:	mov    -0x2c(%rbp),%eax
    1a3b:	cmp    0x4(%r13),%eax
    1a3f:	jne    1bd6 <lookup_fast+0x1f6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1403
			status = d_revalidate(dentry, nd->flags);
			if (unlikely(status <= 0)) {
				if (status != -ECHILD)
					need_reval = 0;
				goto unlazy;
			}
    1a45:	mov    0x4(%r15),%eax
    1a49:	cmp    %eax,0x3c(%r14)
    1a4d:	jne    1bd6 <lookup_fast+0x1f6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1405
		}
		path->mnt = mnt;
    1a53:	mov    -0x2c(%rbp),%eax
    1a56:	mov    %eax,0x3c(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1407
		path->dentry = dentry;
		if (unlikely(!__follow_mount_rcu(nd, path, inode)))
    1a5a:	testb  $0x4,0x0(%r13)
    1a5f:	jne    1c75 <lookup_fast+0x295>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1374
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
	if (nd->flags & LOOKUP_RCU) {
		unsigned seq;
		dentry = __d_lookup_rcu(parent, &nd->last, &seq);
    1a65:	mov    $0x1,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1415
			goto unlazy;
		return 0;
unlazy:
		if (unlazy_walk(nd, dentry))
			return -ECHILD;
	} else {
    1a6b:	mov    -0x38(%rbp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1416
		dentry = __d_lookup(parent, &nd->last);
    1a6f:	mov    %r13,0x8(%rbx)
    1a73:	mov    %r13,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1415
			goto unlazy;
		return 0;
unlazy:
		if (unlazy_walk(nd, dentry))
			return -ECHILD;
	} else {
    1a76:	mov    %rax,(%rbx)
    1a79:	jmp    1ada <lookup_fast+0xfa>
    1a7b:	nopl   0x0(%rax,%rax,1)
__follow_mount_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1124
			break;

		mounted = __lookup_mnt(path->mnt, path->dentry);
		if (!mounted)
			break;
		path->mnt = &mounted->mnt;
    1a80:	test   $0x10000,%edx
    1a86:	je     1b10 <lookup_fast+0x130>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1127
		path->dentry = mounted->mnt.mnt_root;
		nd->flags |= LOOKUP_JUMPED;
		nd->seq = read_seqcount_begin(&path->dentry->d_seq);
    1a8c:	mov    %rdi,%rsi
    1a8f:	mov    (%rbx),%rdi
    1a92:	callq  1a97 <lookup_fast+0xb7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1128
		/*
    1a97:	test   %rax,%rax
    1a9a:	je     1be0 <lookup_fast+0x200>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1130
		 * Update the inode too. We don't need to re-check the
		 * dentry sequence number here after this d_inode read,
    1aa0:	lea    0x20(%rax),%rdx
    1aa4:	mov    %rdx,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1131
		 * because a mount-point is always pinned.
    1aa7:	mov    0x20(%rax),%rax
    1aab:	mov    %rax,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1132
		 */
    1aaf:	orl    $0x1000,0x38(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1133
		*inode = path->dentry->d_inode;
    1ab7:	mov    0x8(%rbx),%rdx
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1abb:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1abe:	test   $0x1,%al
    1ac0:	jne    1bf8 <lookup_fast+0x218>
__follow_mount_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1133
    1ac6:	mov    %eax,0x3c(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1139
	}
	return true;
}

static void follow_mount_rcu(struct nameidata *nd)
{
    1aca:	mov    0x8(%rbx),%rax
    1ace:	mov    0x30(%rax),%rax
    1ad2:	mov    %rax,(%r12)
    1ad6:	mov    0x8(%rbx),%rdi
managed_dentry_might_block():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1104
	return (dentry->d_flags & DCACHE_MANAGE_TRANSIT &&
		dentry->d_op->d_manage(dentry, true) < 0);
}

/*
 * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if
    1ada:	mov    (%rdi),%edx
    1adc:	test   $0x40000,%edx
    1ae2:	je     1a80 <lookup_fast+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1105
 * we meet a managed dentry that would need blocking.
    1ae4:	mov    0x60(%rdi),%rdx
    1ae8:	mov    $0x1,%esi
    1aed:	callq  *0x50(%rdx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1104
	return (dentry->d_flags & DCACHE_MANAGE_TRANSIT &&
		dentry->d_op->d_manage(dentry, true) < 0);
}

/*
 * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if
    1af0:	test   %eax,%eax
    1af2:	js     1bb8 <lookup_fast+0x1d8>
    1af8:	mov    0x8(%rbx),%rdi
    1afc:	mov    (%rdi),%edx
__follow_mount_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1124
			break;

		mounted = __lookup_mnt(path->mnt, path->dentry);
		if (!mounted)
			break;
		path->mnt = &mounted->mnt;
    1afe:	test   $0x10000,%edx
    1b04:	jne    1a8c <lookup_fast+0xac>
    1b06:	nopw   %cs:0x0(%rax,%rax,1)
lookup_fast():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1419
			return -ECHILD;
	} else {
		dentry = __d_lookup(parent, &nd->last);
	}

	if (unlikely(!dentry))
    1b10:	and    $0x20000,%edx
    1b16:	jne    1bb8 <lookup_fast+0x1d8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1459
	struct dentry *dentry, *parent;
	int err;

	parent = nd->path.dentry;
	BUG_ON(nd->inode != parent->d_inode);

    1b1c:	add    $0x18,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1421
		dentry = __d_lookup(parent, &nd->last);
	}

	if (unlikely(!dentry))
		goto need_lookup;

    1b20:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1459
	struct dentry *dentry, *parent;
	int err;

	parent = nd->path.dentry;
	BUG_ON(nd->inode != parent->d_inode);

    1b22:	pop    %rbx
    1b23:	pop    %r12
    1b25:	pop    %r13
    1b27:	pop    %r14
    1b29:	pop    %r15
    1b2b:	pop    %rbp
    1b2c:	retq   
    1b2d:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1426

	if (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE) && need_reval)
		status = d_revalidate(dentry, nd->flags);
	if (unlikely(status <= 0)) {
		if (status < 0) {
			dput(dentry);
    1b30:	mov    %r15,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1374
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
	if (nd->flags & LOOKUP_RCU) {
		unsigned seq;
		dentry = __d_lookup_rcu(parent, &nd->last, &seq);
    1b33:	mov    $0x1,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1426

	if (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE) && need_reval)
		status = d_revalidate(dentry, nd->flags);
	if (unlikely(status <= 0)) {
		if (status < 0) {
			dput(dentry);
    1b39:	callq  1b3e <lookup_fast+0x15e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1373
	 * Rename seqlock is not required here because in the off chance
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
	if (nd->flags & LOOKUP_RCU) {
		unsigned seq;
    1b3e:	mov    $0x1,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1426

	if (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE) && need_reval)
		status = d_revalidate(dentry, nd->flags);
	if (unlikely(status <= 0)) {
		if (status < 0) {
			dput(dentry);
    1b43:	mov    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1429
			return status;
		}
		if (!d_invalidate(dentry)) {
    1b46:	test   %r13,%r13
    1b49:	je     1c6b <lookup_fast+0x28b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1432
			dput(dentry);
			goto need_lookup;
		}
    1b4f:	testb  $0x4,0x0(%r13)
    1b54:	jne    1c41 <lookup_fast+0x261>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1434
	}

    1b5a:	cmp    $0x0,%r15d
    1b5e:	jle    1c1d <lookup_fast+0x23d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1445
		return err;
	}
	if (err)
		nd->flags |= LOOKUP_JUMPED;
	*inode = path->dentry->d_inode;
	return 0;
    1b64:	mov    -0x38(%rbp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1446

    1b68:	mov    %r13,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1447
need_lookup:
    1b6c:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1445
		return err;
	}
	if (err)
		nd->flags |= LOOKUP_JUMPED;
	*inode = path->dentry->d_inode;
	return 0;
    1b6f:	mov    %rax,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1447

need_lookup:
    1b72:	mov    0x38(%r14),%esi
    1b76:	callq  4f0 <follow_managed>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1448
	return 1;
    1b7b:	test   %eax,%eax
    1b7d:	js     1c07 <lookup_fast+0x227>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1452
}

/* Fast lookup failed, do it the slow way */
static int lookup_slow(struct nameidata *nd, struct path *path)
    1b83:	jne    1ba8 <lookup_fast+0x1c8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1454
{
	struct dentry *dentry, *parent;
    1b85:	mov    0x8(%rbx),%rax
    1b89:	mov    0x30(%rax),%rax
    1b8d:	mov    %rax,(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1455
	int err;
    1b91:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1459

	parent = nd->path.dentry;
	BUG_ON(nd->inode != parent->d_inode);

    1b93:	add    $0x18,%rsp
    1b97:	pop    %rbx
    1b98:	pop    %r12
    1b9a:	pop    %r13
    1b9c:	pop    %r14
    1b9e:	pop    %r15
    1ba0:	pop    %rbp
    1ba1:	retq   
    1ba2:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1453
	return 1;
}

/* Fast lookup failed, do it the slow way */
static int lookup_slow(struct nameidata *nd, struct path *path)
{
    1ba8:	orl    $0x1000,0x38(%r14)
    1bb0:	jmp    1b85 <lookup_fast+0x1a5>
    1bb2:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1373
	 * Rename seqlock is not required here because in the off chance
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
	if (nd->flags & LOOKUP_RCU) {
		unsigned seq;
    1bb8:	mov    $0x1,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1423

	if (unlikely(!dentry))
		goto need_lookup;

	if (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE) && need_reval)
		status = d_revalidate(dentry, nd->flags);
    1bbd:	mov    %r13,%rsi
    1bc0:	mov    %r14,%rdi
    1bc3:	mov    %edx,-0x3c(%rbp)
    1bc6:	callq  17c0 <unlazy_walk>
    1bcb:	test   %eax,%eax
    1bcd:	mov    -0x3c(%rbp),%edx
    1bd0:	je     1b46 <lookup_fast+0x166>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1394
		 *
		 * The memory barrier in read_seqcount_begin of child is
		 *  enough, we can use __read_seqcount_retry here.
		 */
		if (__read_seqcount_retry(&parent->d_seq, nd->seq))
			return -ECHILD;
    1bd6:	mov    $0xfffffff6,%eax
    1bdb:	jmp    1b93 <lookup_fast+0x1b3>
    1bdd:	nopl   (%rax)
    1be0:	mov    0x8(%rbx),%rax
    1be4:	mov    (%rax),%edx
    1be6:	jmpq   1b10 <lookup_fast+0x130>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1374
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
	if (nd->flags & LOOKUP_RCU) {
		unsigned seq;
		dentry = __d_lookup_rcu(parent, &nd->last, &seq);
    1beb:	mov    $0x1,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1373
	 * Rename seqlock is not required here because in the off chance
	 * of a false negative due to a concurrent rename, we're going to
	 * do the non-racy lookup, below.
	 */
	if (nd->flags & LOOKUP_RCU) {
		unsigned seq;
    1bf1:	mov    $0x1,%edx
    1bf6:	jmp    1bbd <lookup_fast+0x1dd>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
}

/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
static inline void rep_nop(void)
{
	asm volatile("rep; nop" ::: "memory");
    1bf8:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1bfa:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1bfd:	test   $0x1,%al
    1bff:	je     1ac6 <lookup_fast+0xe6>
    1c05:	jmp    1bf8 <lookup_fast+0x218>
lookup_fast():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1449
	*inode = path->dentry->d_inode;
	return 0;

need_lookup:
	return 1;
}
    1c07:	mov    %r14,%rsi
    1c0a:	mov    %rbx,%rdi
    1c0d:	mov    %eax,-0x38(%rbp)
    1c10:	callq  d10 <path_put_conditional.isra.13>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1450

    1c15:	mov    -0x38(%rbp),%eax
    1c18:	jmpq   1b93 <lookup_fast+0x1b3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1436
			goto need_lookup;
		}
	}

	path->mnt = mnt;
	path->dentry = dentry;
    1c1d:	mov    %r13,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1435
			dput(dentry);
			goto need_lookup;
		}
	}

	path->mnt = mnt;
    1c20:	jne    1c5e <lookup_fast+0x27e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1439
	path->dentry = dentry;
	err = follow_managed(path, nd->flags);
	if (unlikely(err < 0)) {
		path_put_conditional(path, nd);
    1c22:	callq  1c27 <lookup_fast+0x247>
    1c27:	test   %eax,%eax
    1c29:	jne    1b64 <lookup_fast+0x184>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1440
		return err;
    1c2f:	mov    %r13,%rdi
    1c32:	callq  1c37 <lookup_fast+0x257>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1458
{
	struct dentry *dentry, *parent;
	int err;

	parent = nd->path.dentry;
	BUG_ON(nd->inode != parent->d_inode);
    1c37:	mov    $0x1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1441
	path->dentry = dentry;
	err = follow_managed(path, nd->flags);
	if (unlikely(err < 0)) {
		path_put_conditional(path, nd);
		return err;
	}
    1c3c:	jmpq   1b93 <lookup_fast+0x1b3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1432 (discriminator 1)
			return status;
		}
		if (!d_invalidate(dentry)) {
			dput(dentry);
			goto need_lookup;
		}
    1c41:	test   %edx,%edx
    1c43:	je     1b5a <lookup_fast+0x17a>
d_revalidate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:591

static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
{
	return dentry->d_op->d_revalidate(dentry, flags);
}

    1c49:	mov    0x60(%r13),%rax
    1c4d:	mov    0x38(%r14),%esi
    1c51:	mov    %r13,%rdi
    1c54:	callq  *(%rax)
    1c56:	mov    %eax,%r15d
    1c59:	jmpq   1b5a <lookup_fast+0x17a>
lookup_fast():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1436
			goto need_lookup;
		}
	}

	path->mnt = mnt;
	path->dentry = dentry;
    1c5e:	callq  1c63 <lookup_fast+0x283>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1437
	err = follow_managed(path, nd->flags);
    1c63:	mov    %r15d,%eax
    1c66:	jmpq   1b93 <lookup_fast+0x1b3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1458
{
	struct dentry *dentry, *parent;
	int err;

	parent = nd->path.dentry;
	BUG_ON(nd->inode != parent->d_inode);
    1c6b:	mov    $0x1,%eax
    1c70:	jmpq   1b93 <lookup_fast+0x1b3>
d_revalidate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:591

static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
{
	return dentry->d_op->d_revalidate(dentry, flags);
}

    1c75:	mov    0x60(%r13),%rax
    1c79:	mov    0x38(%r14),%esi
    1c7d:	mov    %r13,%rdi
    1c80:	callq  *(%rax)
lookup_fast():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1409
		}
		path->mnt = mnt;
		path->dentry = dentry;
		if (unlikely(!__follow_mount_rcu(nd, path, inode)))
			goto unlazy;
		if (unlikely(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT))
    1c82:	test   %eax,%eax
d_revalidate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:591

static inline int d_revalidate(struct dentry *dentry, unsigned int flags)
{
	return dentry->d_op->d_revalidate(dentry, flags);
}

    1c84:	mov    %eax,%r15d
lookup_fast():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1409
		}
		path->mnt = mnt;
		path->dentry = dentry;
		if (unlikely(!__follow_mount_rcu(nd, path, inode)))
			goto unlazy;
		if (unlikely(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT))
    1c87:	jg     1a6b <lookup_fast+0x8b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1410
			goto unlazy;
    1c8d:	xor    %edx,%edx
    1c8f:	cmp    $0xfffffff6,%eax
    1c92:	sete   %dl
    1c95:	jmpq   1bbd <lookup_fast+0x1dd>
    1c9a:	nopw   0x0(%rax,%rax,1)

0000000000001ca0 <handle_dots>:
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1508
	if (!(nd->flags & LOOKUP_RCU)) {
		path_put(&nd->path);
	} else {
		nd->flags &= ~LOOKUP_RCU;
		if (!(nd->flags & LOOKUP_ROOT))
			nd->root.mnt = NULL;
    1ca0:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1501
			follow_dotdot(nd);
	}
	return 0;
}

static void terminate_walk(struct nameidata *nd)
    1ca2:	cmp    $0x3,%esi
    1ca5:	je     1cb0 <handle_dots+0x10>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1509
		path_put(&nd->path);
	} else {
		nd->flags &= ~LOOKUP_RCU;
		if (!(nd->flags & LOOKUP_ROOT))
			nd->root.mnt = NULL;
		rcu_read_unlock();
    1ca7:	retq   
    1ca8:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1500
		} else
			follow_dotdot(nd);
	}
	return 0;
}

    1cb0:	push   %rbp
    1cb1:	mov    %rsp,%rbp
    1cb4:	push   %r13
    1cb6:	push   %r12
    1cb8:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1502
static void terminate_walk(struct nameidata *nd)
{
    1cb9:	testb  $0x40,0x38(%rdi)
    1cbd:	mov    %rdi,%rbx
    1cc0:	je     1da0 <handle_dots+0x100>
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:659

static __always_inline void set_root_rcu(struct nameidata *nd)
{
	if (!nd->root.mnt) {
		struct fs_struct *fs = current->fs;
		unsigned seq;
    1cc6:	cmpq   $0x0,0x20(%rdi)
    1ccb:	jne    1d07 <handle_dots+0x67>
    1ccd:	jmpq   1e16 <handle_dots+0x176>
    1cd2:	nopw   0x0(%rax,%rax,1)
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1166
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
			unsigned seq;

			seq = read_seqcount_begin(&parent->d_seq);
			if (read_seqcount_retry(&old->d_seq, nd->seq))
    1cd8:	cmp    (%rax),%rsi
    1cdb:	jne    1d20 <handle_dots+0x80>
follow_up_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:900
	parent = mnt->mnt_parent;
	if (&parent->mnt == path->mnt)
		return 0;
	mountpoint = mnt->mnt_mountpoint;
	path->dentry = mountpoint;
	path->mnt = &parent->mnt;
    1cdd:	mov    -0x10(%rax),%rdi
    1ce1:	lea    0x20(%rdi),%rdx
    1ce5:	cmp    %rax,%rdx
    1ce8:	je     1d82 <handle_dots+0xe2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:902
	return 1;
}
    1cee:	mov    -0x8(%rax),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:904

/*
    1cf2:	mov    %rdx,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:903
	mountpoint = mnt->mnt_mountpoint;
	path->dentry = mountpoint;
	path->mnt = &parent->mnt;
	return 1;
}

    1cf5:	mov    %rcx,0x8(%rbx)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1cf9:	mov    0x4(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1cfc:	test   $0x1,%al
    1cfe:	jne    1f78 <handle_dots+0x2d8>
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1180
	}
	follow_mount_rcu(nd);
	nd->inode = nd->path.dentry->d_inode;
	return 0;

failed:
    1d04:	mov    %eax,0x3c(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1162
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
    1d07:	mov    0x8(%rbx),%rsi
    1d0b:	cmp    0x28(%rbx),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1163
			unsigned seq;
    1d0f:	mov    (%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1162
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
    1d12:	jne    1cd8 <handle_dots+0x38>
    1d14:	cmp    0x20(%rbx),%rax
    1d18:	je     1d82 <handle_dots+0xe2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1166
			unsigned seq;

			seq = read_seqcount_begin(&parent->d_seq);
			if (read_seqcount_retry(&old->d_seq, nd->seq))
    1d1a:	cmp    (%rax),%rsi
    1d1d:	je     1cdd <handle_dots+0x3d>
    1d1f:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1168
				goto failed;
			nd->path.dentry = parent;
    1d20:	mov    0x18(%rsi),%rax
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1d24:	mov    0x4(%rax),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1d27:	test   $0x1,%dl
    1d2a:	jne    1feb <handle_dots+0x34b>
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1172
			nd->seq = seq;
			break;
		}
		if (!follow_up_rcu(&nd->path))
    1d30:	mov    0x3c(%rbx),%ecx
    1d33:	cmp    0x4(%rsi),%ecx
    1d36:	jne    1fc9 <handle_dots+0x329>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1175
			break;
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
	}
    1d3c:	mov    %rax,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1174
			nd->seq = seq;
			break;
		}
		if (!follow_up_rcu(&nd->path))
			break;
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
    1d3f:	mov    %rax,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1175
	}
    1d43:	mov    %edx,0x3c(%rbx)
follow_mount_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1146
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
    1d46:	testl  $0x10000,(%rsi)
    1d4c:	je     1d8a <handle_dots+0xea>
    1d4e:	xchg   %ax,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1148
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
	}
    1d50:	mov    (%rbx),%rdi
    1d53:	callq  1d58 <handle_dots+0xb8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1149
}
    1d58:	test   %rax,%rax
    1d5b:	je     1df0 <handle_dots+0x150>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1151

static int follow_dotdot_rcu(struct nameidata *nd)
    1d61:	lea    0x20(%rax),%rdx
    1d65:	mov    %rdx,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1152
{
    1d68:	mov    0x20(%rax),%rdx
    1d6c:	mov    %rdx,0x8(%rbx)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1d70:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1d73:	test   $0x1,%al
    1d75:	jne    1f90 <handle_dots+0x2f0>
follow_mount_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1146
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
    1d7b:	mov    0x8(%rbx),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1153
	}
}

static int follow_dotdot_rcu(struct nameidata *nd)
{
	set_root_rcu(nd);
    1d7f:	mov    %eax,0x3c(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1146
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
    1d82:	testl  $0x10000,(%rsi)
    1d88:	jne    1d50 <handle_dots+0xb0>
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1183
	return 0;

failed:
	nd->flags &= ~LOOKUP_RCU;
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
    1d8a:	mov    0x30(%rsi),%rax
    1d8e:	mov    %rax,0x30(%rbx)
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1508
	if (!(nd->flags & LOOKUP_RCU)) {
		path_put(&nd->path);
	} else {
		nd->flags &= ~LOOKUP_RCU;
		if (!(nd->flags & LOOKUP_ROOT))
			nd->root.mnt = NULL;
    1d92:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1509
		rcu_read_unlock();
    1d94:	pop    %rbx
    1d95:	pop    %r12
    1d97:	pop    %r13
    1d99:	pop    %rbp
    1d9a:	retq   
    1d9b:	nopl   0x0(%rax,%rax,1)
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    1da0:	cmpq   $0x0,0x20(%rdi)
    1da5:	jne    1dc1 <handle_dots+0x121>
    1da7:	jmpq   1e90 <handle_dots+0x1f0>
    1dac:	nopl   0x0(%rax)
follow_dotdot():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1270
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
    1db0:	cmp    (%rax),%r12
    1db3:	jne    1e00 <handle_dots+0x160>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1276
			break;
	}
	follow_mount(&nd->path);
	nd->inode = nd->path.dentry->d_inode;
}

    1db5:	mov    %rbx,%rdi
    1db8:	callq  1dbd <handle_dots+0x11d>
    1dbd:	test   %eax,%eax
    1dbf:	je     1dd8 <handle_dots+0x138>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1264

		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
    1dc1:	mov    0x8(%rbx),%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1266
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
    1dc5:	cmp    0x28(%rbx),%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1267
			dput(old);
    1dc9:	mov    (%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1266
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
    1dcc:	jne    1db0 <handle_dots+0x110>
    1dce:	cmp    0x20(%rbx),%rax
    1dd2:	jne    1db0 <handle_dots+0x110>
    1dd4:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1279
	nd->inode = nd->path.dentry->d_inode;
}

/*
 * This looks up the name in dcache, possibly revalidates the old dentry and
 * allocates a new one if not found or not valid.  In the need_lookup argument
    1dd8:	mov    %rbx,%rdi
    1ddb:	callq  15c0 <follow_mount>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1280
 * returns whether i_op->lookup is necessary.
    1de0:	mov    0x8(%rbx),%rax
    1de4:	mov    0x30(%rax),%rax
    1de8:	mov    %rax,0x30(%rbx)
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1508
	if (!(nd->flags & LOOKUP_RCU)) {
		path_put(&nd->path);
	} else {
		nd->flags &= ~LOOKUP_RCU;
		if (!(nd->flags & LOOKUP_ROOT))
			nd->root.mnt = NULL;
    1dec:	xor    %eax,%eax
    1dee:	jmp    1d94 <handle_dots+0xf4>
    1df0:	mov    0x8(%rbx),%rsi
    1df4:	jmp    1d8a <handle_dots+0xea>
    1df6:	nopw   %cs:0x0(%rax,%rax,1)
follow_dotdot():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1272
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
    1e00:	mov    %r12,%rdi
    1e03:	callq  1e08 <handle_dots+0x168>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1273
	follow_mount(&nd->path);
    1e08:	mov    %r12,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1272
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
    1e0b:	mov    %rax,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1273
	follow_mount(&nd->path);
    1e0f:	callq  1e14 <handle_dots+0x174>
    1e14:	jmp    1dd8 <handle_dots+0x138>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1e16:	mov    %gs:0x0,%rdi
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:660
static __always_inline void set_root_rcu(struct nameidata *nd)
{
	if (!nd->root.mnt) {
		struct fs_struct *fs = current->fs;
		unsigned seq;

    1e1f:	add    $0x4a8,%rdi
    1e26:	callq  1370 <my_strcmp_base.constprop.35>
    1e2b:	test   %eax,%eax
    1e2d:	jne    1e3f <handle_dots+0x19f>
    1e2f:	cmpb   $0x0,0x0(%rip)        # 1e36 <handle_dots+0x196>
    1e36:	mov    0x0(%rip),%rax        # 1e3d <handle_dots+0x19d>
    1e3d:	jne    1e48 <handle_dots+0x1a8>
    1e3f:	mov    %gs:0x0,%rax
    1e48:	mov    0x588(%rax),%rcx
    1e4f:	jmp    1e83 <handle_dots+0x1e3>
    1e51:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:665
		do {
			seq = read_seqcount_begin(&fs->seq);
			nd->root = fs->root;
			nd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
		} while (read_seqcount_retry(&fs->seq, seq));
    1e58:	mov    0x20(%rcx),%rdx
    1e5c:	mov    0x18(%rcx),%rax
    1e60:	mov    %rdx,0x28(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:666
	}
    1e64:	mov    0x28(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:665

		do {
			seq = read_seqcount_begin(&fs->seq);
			nd->root = fs->root;
			nd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
		} while (read_seqcount_retry(&fs->seq, seq));
    1e68:	mov    %rax,0x20(%rbx)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1e6c:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1e6f:	test   $0x1,%al
    1e71:	jne    1ffb <handle_dots+0x35b>
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:666
	}
    1e77:	mov    %eax,0x3c(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:667
}
    1e7a:	cmp    0x8(%rcx),%esi
    1e7d:	je     1d07 <handle_dots+0x67>
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1e83:	mov    0x8(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1e86:	test   $0x1,%sil
    1e8a:	je     1e58 <handle_dots+0x1b8>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    1e8c:	pause  
    1e8e:	jmp    1e83 <handle_dots+0x1e3>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1e90:	mov    %gs:0x0,%rdi
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652
static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}

    1e99:	add    $0x4a8,%rdi
    1ea0:	callq  1370 <my_strcmp_base.constprop.35>
    1ea5:	test   %eax,%eax
    1ea7:	jne    1eb9 <handle_dots+0x219>
    1ea9:	cmpb   $0x0,0x0(%rip)        # 1eb0 <handle_dots+0x210>
    1eb0:	mov    0x0(%rip),%rax        # 1eb7 <handle_dots+0x217>
    1eb7:	jne    1ec2 <handle_dots+0x222>
    1eb9:	mov    %gs:0x0,%rax
    1ec2:	mov    0x588(%rax),%r13
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    1ec9:	lea    0x4(%r13),%r12
    1ecd:	mov    %r12,%rdi
    1ed0:	callq  1ed5 <handle_dots+0x235>
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:29
extern int unshare_fs_struct(void);

static inline void get_fs_root(struct fs_struct *fs, struct path *root)
{
	spin_lock(&fs->lock);
	*root = fs->root;
    1ed5:	mov    0x18(%r13),%rax
    1ed9:	mov    0x20(%r13),%rdx
    1edd:	mov    %rax,%rdi
    1ee0:	mov    %rdx,0x28(%rbx)
    1ee4:	mov    %rax,0x20(%rbx)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    1ee8:	callq  1eed <handle_dots+0x24d>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1eed:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    1ef6:	mov    0x28(%rbx),%r13
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1efa:	add    $0x4a8,%rdx
    1f01:	mov    $0x0,%rax
    1f08:	jmp    1f18 <handle_dots+0x278>
    1f0a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1f10:	test   %cl,%cl
    1f12:	je     1fa2 <handle_dots+0x302>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1f18:	add    $0x1,%rdx
    1f1c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1f20:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1f24:	cmp    -0x1(%rax),%cl
    1f27:	je     1f10 <handle_dots+0x270>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1f29:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    1f32:	mov    $0x0,%rax
    1f39:	add    $0x4a8,%rdx
    1f40:	jmp    1f4c <handle_dots+0x2ac>
    1f42:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    1f48:	test   %cl,%cl
    1f4a:	je     1fa2 <handle_dots+0x302>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    1f4c:	add    $0x1,%rdx
    1f50:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    1f54:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    1f58:	cmp    -0x1(%rax),%cl
    1f5b:	je     1f48 <handle_dots+0x2a8>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    1f5d:	test   %r13,%r13
    1f60:	je     1f6b <handle_dots+0x2cb>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    1f62:	lea    0x58(%r13),%rdi
    1f66:	callq  1f6b <handle_dots+0x2cb>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    1f6b:	mov    %r12,%rdi
    1f6e:	callq  1f73 <handle_dots+0x2d3>
    1f73:	jmpq   1dc1 <handle_dots+0x121>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    1f78:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1f7a:	mov    0x4(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1f7d:	test   $0x1,%al
    1f7f:	je     1d04 <handle_dots+0x64>
    1f85:	jmp    1f78 <handle_dots+0x2d8>
    1f87:	nopw   0x0(%rax,%rax,1)
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    1f90:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1f92:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1f95:	test   $0x1,%al
    1f97:	je     1d7b <handle_dots+0xdb>
    1f9d:	nopl   (%rax)
    1fa0:	jmp    1f90 <handle_dots+0x2f0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    1fa2:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    1fab:	mov    $0x0,%rsi
    1fb2:	add    $0x4a8,%rdx
    1fb9:	mov    $0x0,%rdi
    1fc0:	xor    %eax,%eax
    1fc2:	callq  1fc7 <handle_dots+0x327>
    1fc7:	jmp    1f5d <handle_dots+0x2bd>
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1187
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
	rcu_read_unlock();
	return -ECHILD;
}

    1fc9:	mov    0x38(%rbx),%eax
    1fcc:	mov    %eax,%edx
    1fce:	and    $0xffffffbf,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1188
/*
    1fd1:	test   $0x20,%ah
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1187
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
	rcu_read_unlock();
	return -ECHILD;
}

    1fd4:	mov    %edx,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1188
/*
    1fd7:	jne    1fe1 <handle_dots+0x341>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1189
 * Follow down to the covering mount currently visible to userspace.  At each
    1fd9:	movq   $0x0,0x20(%rbx)
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1504
}

static void terminate_walk(struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		path_put(&nd->path);
    1fe1:	mov    $0xfffffff6,%eax
    1fe6:	jmpq   1d94 <handle_dots+0xf4>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    1feb:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1fed:	mov    0x4(%rax),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    1ff0:	test   $0x1,%dl
    1ff3:	je     1d30 <handle_dots+0x90>
    1ff9:	jmp    1feb <handle_dots+0x34b>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    1ffb:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    1ffd:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2000:	test   $0x1,%al
    2002:	je     1e77 <handle_dots+0x1d7>
    2008:	jmp    1ffb <handle_dots+0x35b>
handle_dots():
    200a:	nopw   0x0(%rax,%rax,1)

0000000000002010 <mountpoint_last>:
mountpoint_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2214
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

    2010:	callq  2015 <mountpoint_last+0x5>
    2015:	push   %rbp
    2016:	mov    %rsp,%rbp
    2019:	push   %r15
    201b:	push   %r14
    201d:	mov    %rsi,%r14
    2020:	push   %r13
    2022:	push   %r12
    2024:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2220
	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
    2025:	mov    0x38(%rdi),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2214
		if (error)
			goto out;
		dentry = dget(nd->path.dentry);
		goto done;
	}

    2028:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2217
	mutex_lock(&dir->d_inode->i_mutex);
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
    202b:	mov    0x8(%rdi),%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2220
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
    202f:	test   $0x40,%al
    2031:	jne    20e0 <mountpoint_last+0xd0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2229
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
    2037:	mov    0x44(%rbx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2227
		 */
		dentry = d_alloc(dir, &nd->last);
		if (!dentry) {
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
    203a:	and    $0xffffffef,%eax
    203d:	mov    %eax,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2229
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
    2040:	test   %esi,%esi
    2042:	jne    217b <mountpoint_last+0x16b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2237
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

    2048:	mov    0x30(%r13),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2238
done:
    204c:	lea    0x10(%rbx),%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2237
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

    2050:	lea    0xa8(%rax),%rdi
    2057:	callq  205c <mountpoint_last+0x4c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2238
done:
    205c:	mov    %r15,%rsi
    205f:	mov    %r13,%rdi
    2062:	callq  2067 <mountpoint_last+0x57>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2239
	if (!dentry->d_inode) {
    2067:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2238
			goto out;
		}
	}
	mutex_unlock(&dir->d_inode->i_mutex);

done:
    206a:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2239
	if (!dentry->d_inode) {
    206d:	je     2100 <mountpoint_last+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2258
}

/**
 * path_mountpoint - look up a path to be umounted
 * @dfd:	directory file descriptor to start walk from
 * @name:	full pathname to walk
    2073:	mov    0x30(%r13),%rdi
    2077:	add    $0xa8,%rdi
    207e:	callq  2083 <mountpoint_last+0x73>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2261
 * @path:	pointer to container for result
 * @flags:	lookup flags
 *
    2083:	cmpq   $0x0,0x30(%r12)
    2089:	je     2148 <mountpoint_last+0x138>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2266
 * Look up the given name, but don't attempt to revalidate the last component.
 * Returns 0 and "path" will be valid on success; Returns error otherwise.
 */
static int path_mountpoint(int dfd, const char *name, struct path *path, unsigned int flags)
{
    208f:	mov    %r12,0x8(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2267
	struct file *base = NULL;
    2093:	mov    (%rbx),%rdi
    2096:	callq  209b <mountpoint_last+0x8b>
    209b:	mov    %rax,(%r14)
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    209e:	mov    (%r12),%eax
mountpoint_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2268
	struct nameidata nd;
    20a2:	mov    0x38(%rbx),%edx
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    20a5:	and    $0x700000,%eax
should_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1531
	struct inode *inode;
	int err;
	/*
	 * "." and ".." are special - ".." especially so because it has
	 * to be able to know about the current root directory and
	 * parent relationships.
    20aa:	cmp    $0x300000,%eax
    20af:	je     219f <mountpoint_last+0x18f>
mountpoint_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2270
static int path_mountpoint(int dfd, const char *name, struct path *path, unsigned int flags)
{
	struct file *base = NULL;
	struct nameidata nd;
	int err;

    20b5:	mov    %r14,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2271
	err = path_init(dfd, name, flags | LOOKUP_PARENT, &nd, &base);
    20b8:	xor    %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2270
static int path_mountpoint(int dfd, const char *name, struct path *path, unsigned int flags)
{
	struct file *base = NULL;
	struct nameidata nd;
	int err;

    20bb:	callq  15c0 <follow_mount>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2273
	err = path_init(dfd, name, flags | LOOKUP_PARENT, &nd, &base);
	if (unlikely(err))
		return err;
    20c0:	mov    %rbx,%rdi
    20c3:	callq  cc0 <terminate_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2274

    20c8:	mov    %r12d,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2275
	current->total_link_count = 0;
    20cb:	pop    %rbx
    20cc:	pop    %r12
    20ce:	pop    %r13
    20d0:	pop    %r14
    20d2:	pop    %r15
    20d4:	pop    %rbp
    20d5:	retq   
    20d6:	nopw   %cs:0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2221
	dentry = d_lookup(dir, &nd->last);
	if (!dentry) {
		/*
		 * No cached dentry. Mounted dentries are pinned in the cache,
		 * so that means that this dentry is probably a symlink or the
		 * path doesn't actually point to a mounted dentry.
    20e0:	xor    %esi,%esi
    20e2:	callq  17c0 <unlazy_walk>
    20e7:	test   %eax,%eax
    20e9:	je     20f8 <mountpoint_last+0xe8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2222
		 */
    20eb:	mov    $0xfffffff6,%r12d
    20f1:	jmp    20c0 <mountpoint_last+0xb0>
    20f3:	nopl   0x0(%rax,%rax,1)
    20f8:	mov    0x38(%rbx),%eax
    20fb:	jmpq   2037 <mountpoint_last+0x27>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2245
		error = -ENOENT;
		dput(dentry);
		goto out;
	}
	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
    2100:	mov    %r15,%rsi
    2103:	mov    %r13,%rdi
    2106:	callq  210b <mountpoint_last+0xfb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2246
	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
    210b:	test   %rax,%rax
    210e:	je     2160 <mountpoint_last+0x150>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2251
		return 1;
	follow_mount(path);
	error = 0;
out:
	terminate_walk(nd);
    2110:	mov    0x38(%rbx),%edx
    2113:	mov    0x30(%r13),%rdi
    2117:	mov    %rax,%rsi
    211a:	callq  f0 <lookup_real>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2253
	return error;
}
    211f:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2251
	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
		return 1;
	follow_mount(path);
	error = 0;
out:
	terminate_walk(nd);
    2125:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2253
	return error;
}
    2128:	jbe    2073 <mountpoint_last+0x63>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2254

    212e:	mov    0x30(%r13),%rdi
    2132:	add    $0xa8,%rdi
    2139:	callq  213e <mountpoint_last+0x12e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2255
/**
    213e:	jmpq   20c0 <mountpoint_last+0xb0>
    2143:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2263
 * @name:	full pathname to walk
 * @path:	pointer to container for result
 * @flags:	lookup flags
 *
 * Look up the given name, but don't attempt to revalidate the last component.
 * Returns 0 and "path" will be valid on success; Returns error otherwise.
    2148:	mov    %r12,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2262
 * @dfd:	directory file descriptor to start walk from
 * @name:	full pathname to walk
 * @path:	pointer to container for result
 * @flags:	lookup flags
 *
 * Look up the given name, but don't attempt to revalidate the last component.
    214b:	mov    $0xfffffffe,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2263
 * Returns 0 and "path" will be valid on success; Returns error otherwise.
    2151:	callq  2156 <mountpoint_last+0x146>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2264
 */
    2156:	jmpq   20c0 <mountpoint_last+0xb0>
    215b:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2248
	}
	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
		return 1;
	follow_mount(path);
    2160:	mov    0x30(%r13),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2247
		goto out;
	}
	path->dentry = dentry;
	path->mnt = mntget(nd->path.mnt);
	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
		return 1;
    2164:	mov    $0xfffffff4,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2248
	follow_mount(path);
    216a:	add    $0xa8,%rdi
    2171:	callq  2176 <mountpoint_last+0x166>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2249
	error = 0;
    2176:	jmpq   20c0 <mountpoint_last+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2230
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
    217b:	mov    %rbx,%rdi
    217e:	callq  1ca0 <handle_dots>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2231
		if (IS_ERR(dentry)) {
    2183:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2230
			error = -ENOMEM;
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
		}
		dentry = lookup_real(dir->d_inode, dentry, nd->flags);
		error = PTR_ERR(dentry);
    2185:	mov    %eax,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2231
		if (IS_ERR(dentry)) {
    2188:	jne    20c0 <mountpoint_last+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2233
			mutex_unlock(&dir->d_inode->i_mutex);
			goto out;
    218e:	mov    0x8(%rbx),%rdi
    2192:	callq  30 <dget>
    2197:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2234
		}
    219a:	jmpq   2083 <mountpoint_last+0x73>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2268
 * Returns 0 and "path" will be valid on success; Returns error otherwise.
 */
static int path_mountpoint(int dfd, const char *name, struct path *path, unsigned int flags)
{
	struct file *base = NULL;
	struct nameidata nd;
    219f:	and    $0x1,%dl
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2269
	int err;
    21a2:	mov    $0x1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2268
 * Returns 0 and "path" will be valid on success; Returns error otherwise.
 */
static int path_mountpoint(int dfd, const char *name, struct path *path, unsigned int flags)
{
	struct file *base = NULL;
	struct nameidata nd;
    21a7:	jne    20cb <mountpoint_last+0xbb>
    21ad:	jmpq   20b5 <mountpoint_last+0xa5>
    21b2:	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

00000000000021c0 <final_putname>:
final_putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:123
 *
 * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
 * PATH_MAX includes the nul terminator --RR.
 */
void final_putname(struct filename *name)
{
    21c0:	callq  21c5 <final_putname+0x5>
    21c5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:126
	if (name->separate) {
		// __putname(name->name);
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    21c6:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    21cd:	mov    %gs:0x0,%rdx
final_putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:123
 *
 * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
 * PATH_MAX includes the nul terminator --RR.
 */
void final_putname(struct filename *name)
{
    21d6:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:126
	if (name->separate) {
		// __putname(name->name);
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    21d9:	add    $0x4a8,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:123
 *
 * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
 * PATH_MAX includes the nul terminator --RR.
 */
void final_putname(struct filename *name)
{
    21e0:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:124
	if (name->separate) {
    21e1:	cmpb   $0x0,0x18(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:123
 *
 * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
 * PATH_MAX includes the nul terminator --RR.
 */
void final_putname(struct filename *name)
{
    21e5:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:124
	if (name->separate) {
    21e8:	je     2224 <final_putname+0x64>
    21ea:	jmp    21f4 <final_putname+0x34>
    21ec:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    21f0:	test   %cl,%cl
    21f2:	je     2250 <final_putname+0x90>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    21f4:	add    $0x1,%rdx
    21f8:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    21fc:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2200:	cmp    -0x1(%rax),%cl
    2203:	je     21f0 <final_putname+0x30>
final_putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:127
		// __putname(name->name);
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
      __putname(name->name);
    2205:	mov    (%rbx),%rsi
    2208:	mov    0x0(%rip),%rdi        # 220f <final_putname+0x4f>
    220f:	callq  2214 <final_putname+0x54>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:130
    else
      msg_kmem_cache_free(names_cachep, (void *)(name->name), msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
		kfree(name);
    2214:	mov    %rbx,%rdi
    2217:	callq  221c <final_putname+0x5c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:139
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
      __putname(name);
    else
      msg_kmem_cache_free(names_cachep, (void *)(name), msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	}
}
    221c:	pop    %rbx
    221d:	pop    %rbp
    221e:	retq   
    221f:	nop
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2220:	test   %cl,%cl
    2222:	je     2270 <final_putname+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2224:	add    $0x1,%rdx
    2228:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    222c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2230:	cmp    -0x1(%rax),%cl
    2233:	je     2220 <final_putname+0x60>
final_putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:135
		kfree(name);
    // msg_kfree(name);
	} else {
		// __putname(name);
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
      __putname(name);
    2235:	mov    0x0(%rip),%rdi        # 223c <final_putname+0x7c>
    223c:	mov    %rbx,%rsi
    223f:	callq  2244 <final_putname+0x84>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:139
    else
      msg_kmem_cache_free(names_cachep, (void *)(name), msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	}
}
    2244:	pop    %rbx
    2245:	pop    %rbp
    2246:	retq   
    2247:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:129
	if (name->separate) {
		// __putname(name->name);
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
      __putname(name->name);
    else
      msg_kmem_cache_free(names_cachep, (void *)(name->name), msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    2250:	mov    0x0(%rip),%ecx        # 2256 <final_putname+0x96>
    2256:	mov    0x0(%rip),%edx        # 225c <final_putname+0x9c>
    225c:	mov    (%rbx),%rsi
    225f:	mov    0x0(%rip),%rdi        # 2266 <final_putname+0xa6>
    2266:	callq  226b <final_putname+0xab>
    226b:	jmp    2214 <final_putname+0x54>
    226d:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:137
	} else {
		// __putname(name);
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
      __putname(name);
    else
      msg_kmem_cache_free(names_cachep, (void *)(name), msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    2270:	mov    0x0(%rip),%ecx        # 2276 <final_putname+0xb6>
    2276:	mov    0x0(%rip),%edx        # 227c <final_putname+0xbc>
    227c:	mov    %rbx,%rsi
    227f:	mov    0x0(%rip),%rdi        # 2286 <final_putname+0xc6>
    2286:	callq  228b <final_putname+0xcb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:139
	}
}
    228b:	pop    %rbx
    228c:	pop    %rbp
    228d:	retq   
    228e:	xchg   %ax,%ax

0000000000002290 <getname_flags>:
getname_flags():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:145

#define EMBEDDED_NAME_MAX	(PATH_MAX - sizeof(struct filename))

static struct filename *getname_flags(const char __user *filename, int flags, int *empty)
{
	struct filename *result, *err;
    2290:	callq  2295 <getname_flags+0x5>
    2295:	push   %rbp
    2296:	mov    %rsp,%rbp
    2299:	push   %r15
    229b:	push   %r14
    229d:	mov    %esi,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:152
	long max;
	char *kname;

	// result = audit_reusename(filename);
	result = msg_audit_reusename(filename, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	if (result)
    22a0:	mov    0x0(%rip),%esi        # 22a6 <getname_flags+0x16>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:145

#define EMBEDDED_NAME_MAX	(PATH_MAX - sizeof(struct filename))

static struct filename *getname_flags(const char __user *filename, int flags, int *empty)
{
	struct filename *result, *err;
    22a6:	push   %r13
    22a8:	mov    %rdx,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:152
	long max;
	char *kname;

	// result = audit_reusename(filename);
	result = msg_audit_reusename(filename, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	if (result)
    22ab:	mov    0x0(%rip),%edx        # 22b1 <getname_flags+0x21>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:145

#define EMBEDDED_NAME_MAX	(PATH_MAX - sizeof(struct filename))

static struct filename *getname_flags(const char __user *filename, int flags, int *empty)
{
	struct filename *result, *err;
    22b1:	push   %r12
    22b3:	mov    %rdi,%r12
    22b6:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:152
	long max;
	char *kname;

	// result = audit_reusename(filename);
	result = msg_audit_reusename(filename, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	if (result)
    22b7:	callq  22bc <getname_flags+0x2c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:153
		return result;
    22bc:	test   %rax,%rax
    22bf:	je     22d0 <getname_flags+0x40>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:218

error:
	final_putname(result);
	return err;
}

    22c1:	pop    %rbx
    22c2:	pop    %r12
    22c4:	pop    %r13
    22c6:	pop    %r14
    22c8:	pop    %r15
    22ca:	pop    %rbp
    22cb:	retq   
    22cc:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:156
	result = msg_audit_reusename(filename, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	if (result)
		return result;

	result = __getname();
	if (unlikely(!result))
    22d0:	mov    0x0(%rip),%rdi        # 22d7 <getname_flags+0x47>
    22d7:	mov    $0xd0,%esi
    22dc:	callq  22e1 <getname_flags+0x51>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:157
		return ERR_PTR(-ENOMEM);
    22e1:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:156
	result = msg_audit_reusename(filename, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	if (result)
		return result;

	result = __getname();
	if (unlikely(!result))
    22e4:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:157
		return ERR_PTR(-ENOMEM);
    22e7:	je     239c <getname_flags+0x10c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:164
	/*
	 * First, try to embed the struct filename inside the names_cache
	 * allocation
	 */
	kname = (char *)result + sizeof(*result);
	result->name = kname;
    22ed:	lea    0x20(%rax),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:166
	result->separate = false;
	max = EMBEDDED_NAME_MAX;
    22f1:	movb   $0x0,0x18(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:167

    22f5:	mov    $0xfe0,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:165
	 * First, try to embed the struct filename inside the names_cache
	 * allocation
	 */
	kname = (char *)result + sizeof(*result);
	result->name = kname;
	result->separate = false;
    22fb:	mov    %rdi,(%rax)
    22fe:	jmp    2336 <getname_flags+0xa6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:182
	 * separate struct filename so we can dedicate the entire
	 * names_cache allocation for the pathname, and re-do the copy from
	 * userland.
	 */
	if (len == EMBEDDED_NAME_MAX && max == EMBEDDED_NAME_MAX) {
		kname = (char *)result;
    2300:	cmp    $0xfe0,%r15
    2307:	jne    234e <getname_flags+0xbe>
kmalloc():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/slab.h:454
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    2309:	mov    0x0(%rip),%rdi        # 2310 <getname_flags+0x80>
    2310:	mov    $0x20,%edx
    2315:	mov    $0x80d0,%esi
    231a:	callq  231f <getname_flags+0x8f>
getname_flags():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:186

		result = kzalloc(sizeof(*result), GFP_KERNEL);
		if (!result) {
			err = ERR_PTR(-ENOMEM);
    231f:	test   %rax,%rax
    2322:	je     2380 <getname_flags+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:191
			result = (struct filename *)kname;
			goto error;
		}
		result->name = kname;
		result->separate = true;
    2324:	mov    %rbx,(%rax)
    2327:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:192
		max = PATH_MAX;
    232a:	movb   $0x1,0x18(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:193
		goto recopy;
    232e:	mov    $0x1000,%r15w
    2333:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:170
	result->separate = false;
	max = EMBEDDED_NAME_MAX;

recopy:
	len = strncpy_from_user(kname, filename, max);
	if (unlikely(len < 0)) {
    2336:	mov    %r15,%rdx
    2339:	mov    %r12,%rsi
    233c:	callq  2341 <getname_flags+0xb1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:171
		err = ERR_PTR(len);
    2341:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:170
	result->separate = false;
	max = EMBEDDED_NAME_MAX;

recopy:
	len = strncpy_from_user(kname, filename, max);
	if (unlikely(len < 0)) {
    2343:	mov    %eax,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:171
		err = ERR_PTR(len);
    2345:	js     2397 <getname_flags+0x107>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:182
	 * separate struct filename so we can dedicate the entire
	 * names_cache allocation for the pathname, and re-do the copy from
	 * userland.
	 */
	if (len == EMBEDDED_NAME_MAX && max == EMBEDDED_NAME_MAX) {
		kname = (char *)result;
    2347:	cmp    $0xfe0,%eax
    234c:	je     2300 <getname_flags+0x70>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:198
		goto recopy;
	}

	/* The empty path is special. */
	if (unlikely(!len)) {
		if (empty)
    234e:	test   %edx,%edx
    2350:	je     23b1 <getname_flags+0x121>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:207
			goto error;
	}

	err = ERR_PTR(-ENAMETOOLONG);
	if (unlikely(len >= PATH_MAX))
		goto error;
    2352:	cmp    $0xfff,%edx
    2358:	jg     23a8 <getname_flags+0x118>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:212

	result->uptr = filename;
	// audit_getname(result);
	msg_audit_getname(result, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	return result;
    235a:	mov    0x0(%rip),%edx        # 2360 <getname_flags+0xd0>
    2360:	mov    0x0(%rip),%esi        # 2366 <getname_flags+0xd6>
    2366:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:210
	err = ERR_PTR(-ENAMETOOLONG);
	if (unlikely(len >= PATH_MAX))
		goto error;

	result->uptr = filename;
	// audit_getname(result);
    2369:	mov    %r12,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:212
	msg_audit_getname(result, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	return result;
    236d:	callq  2372 <getname_flags+0xe2>
    2372:	mov    %rbx,%rax
    2375:	jmpq   22c1 <getname_flags+0x31>
    237a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:187
		kname = (char *)result;

		result = kzalloc(sizeof(*result), GFP_KERNEL);
		if (!result) {
			err = ERR_PTR(-ENOMEM);
			result = (struct filename *)kname;
    2380:	mov    $0xfffffffffffffff4,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:216
	msg_audit_getname(result, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	return result;

error:
	final_putname(result);
	return err;
    2387:	mov    %rbx,%rdi
    238a:	callq  238f <getname_flags+0xff>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:217
}
    238f:	mov    %r12,%rax
    2392:	jmpq   22c1 <getname_flags+0x31>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:172

recopy:
	len = strncpy_from_user(kname, filename, max);
	if (unlikely(len < 0)) {
		err = ERR_PTR(len);
		goto error;
    2397:	movslq %eax,%r12
    239a:	jmp    2387 <getname_flags+0xf7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:158
		return result;

	result = __getname();
	if (unlikely(!result))
		return ERR_PTR(-ENOMEM);

    239c:	mov    $0xfffffffffffffff4,%rax
    23a3:	jmpq   22c1 <getname_flags+0x31>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:206
		if (!(flags & LOOKUP_EMPTY))
			goto error;
	}

	err = ERR_PTR(-ENAMETOOLONG);
	if (unlikely(len >= PATH_MAX))
    23a8:	mov    $0xffffffffffffffdc,%r12
    23af:	jmp    2387 <getname_flags+0xf7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:199
	}

	/* The empty path is special. */
	if (unlikely(!len)) {
		if (empty)
			*empty = 1;
    23b1:	test   %r13,%r13
    23b4:	je     23be <getname_flags+0x12e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:200
		err = ERR_PTR(-ENOENT);
    23b6:	movl   $0x1,0x0(%r13)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:202
		if (!(flags & LOOKUP_EMPTY))
			goto error;
    23be:	and    $0x4000,%r14d
    23c5:	jne    235a <getname_flags+0xca>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:201
	/* The empty path is special. */
	if (unlikely(!len)) {
		if (empty)
			*empty = 1;
		err = ERR_PTR(-ENOENT);
		if (!(flags & LOOKUP_EMPTY))
    23c7:	mov    $0xfffffffffffffffe,%r12
    23ce:	jmp    2387 <getname_flags+0xf7>

00000000000023d0 <getname>:
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:222
}

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
    23d0:	callq  23d5 <getname+0x5>
    23d5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223
EXPORT_SYMBOL(getname);
    23d6:	xor    %edx,%edx
    23d8:	xor    %esi,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:222
}

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
    23da:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223
EXPORT_SYMBOL(getname);
    23dd:	callq  2290 <getname_flags>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:224

    23e2:	pop    %rbp
    23e3:	retq   
    23e4:	data32 data32 nopw %cs:0x0(%rax,%rax,1)

00000000000023f0 <putname>:
putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:229
#ifdef CONFIG_AUDITSYSCALL
void putname(struct filename *name)
{
	if (unlikely(!audit_dummy_context()))
		return audit_putname(name);
    23f0:	callq  23f5 <putname+0x5>
    23f5:	push   %rbp
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    23f6:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    23fd:	mov    %gs:0x0,%rdx
putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:229
    2406:	mov    %rsp,%rbp
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    2409:	add    $0x4a8,%rdx
    2410:	jmp    241c <putname+0x2c>
    2412:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2418:	test   %cl,%cl
    241a:	je     2458 <putname+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    241c:	add    $0x1,%rdx
    2420:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    2424:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    2428:	cmp    -0x1(%rax),%cl
    242b:	je     2418 <putname+0x28>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    242d:	mov    %gs:0x0,%rax
    2436:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    243d:	test   %rax,%rax
    2440:	je     2478 <putname+0x88>
    2442:	mov    (%rax),%eax
    2444:	test   %eax,%eax
    2446:	jne    2478 <putname+0x88>
putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:231
	final_putname(name);
}
    2448:	callq  244d <putname+0x5d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:233
#endif

    244d:	pop    %rbp
    244e:	xchg   %ax,%ax
    2450:	retq   
    2451:	nopl   0x0(%rax)
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    2458:	cmpb   $0x0,0x0(%rip)        # 245f <putname+0x6f>
    245f:	mov    0x0(%rip),%rax        # 2466 <putname+0x76>
    2466:	je     242d <putname+0x3d>
    2468:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    246f:	test   %rax,%rax
    2472:	jne    2442 <putname+0x52>
    2474:	nopl   0x0(%rax)
putname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:232
{
	if (unlikely(!audit_dummy_context()))
		return audit_putname(name);
	final_putname(name);
}
#endif
    2478:	callq  247d <putname+0x8d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:233

    247d:	pop    %rbp
    247e:	retq   
    247f:	nop

0000000000002480 <__inode_permission>:
__inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:399
 * inode_permission().
 */
int __inode_permission(struct inode *inode, int mask)
{
	int retval;

    2480:	callq  2485 <__inode_permission+0x5>
    2485:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:402
	if (unlikely(mask & MAY_WRITE)) {
		/*
		 * Nobody gets write access to an immutable file.
    2486:	test   $0x2,%sil
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:399
 * inode_permission().
 */
int __inode_permission(struct inode *inode, int mask)
{
	int retval;

    248a:	mov    %rsp,%rbp
    248d:	push   %r13
    248f:	mov    %esi,%r13d
    2492:	push   %r12
    2494:	push   %rbx
    2495:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:402
	if (unlikely(mask & MAY_WRITE)) {
		/*
		 * Nobody gets write access to an immutable file.
    2498:	jne    2561 <__inode_permission+0xe1>
do_inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:374
 */
static inline int do_inode_permission(struct inode *inode, int mask)
{
	if (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {
		if (likely(inode->i_op->permission))
			return inode->i_op->permission(inode, mask);
    249e:	testb  $0x1,0x2(%rbx)
    24a2:	je     2544 <__inode_permission+0xc4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:383
		inode->i_opflags |= IOP_FASTPERM;
		spin_unlock(&inode->i_lock);
	}
	return generic_permission(inode, mask);
}

    24a8:	mov    %r13d,%esi
    24ab:	mov    %rbx,%rdi
    24ae:	callq  24b3 <__inode_permission+0x33>
    24b3:	mov    %eax,%r12d
__inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:411
	}

	retval = do_inode_permission(inode, mask);
	if (retval)
		return retval;

    24b6:	test   %r12d,%r12d
    24b9:	je     24c8 <__inode_permission+0x48>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:423
    return security_inode_permission(inode, mask);
  else
    return 0;
}

/**
    24bb:	pop    %rbx
    24bc:	mov    %r12d,%eax
    24bf:	pop    %r12
    24c1:	pop    %r13
    24c3:	pop    %rbp
    24c4:	retq   
    24c5:	nopl   (%rax)
devcgroup_inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/device_cgroup.h:8
#ifdef CONFIG_CGROUP_DEVICE
extern int __devcgroup_inode_permission(struct inode *inode, int mask);
extern int devcgroup_inode_mknod(int mode, dev_t dev);
static inline int devcgroup_inode_permission(struct inode *inode, int mask)
{
	if (likely(!inode->i_rdev))
    24c8:	mov    0x4c(%rbx),%eax
    24cb:	test   %eax,%eax
    24cd:	jne    2520 <__inode_permission+0xa0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    24cf:	mov    %gs:0x0,%rcx
__inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:419
		return retval;

	// return security_inode_permission(inode, mask);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    return security_inode_permission(inode, mask);
  else
    24d8:	mov    $0x0,%rdx
    24df:	add    $0x4a8,%rcx
    24e6:	jmp    24f5 <__inode_permission+0x75>
    24e8:	nopl   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    24f0:	test   %r8b,%r8b
    24f3:	je     24bb <__inode_permission+0x3b>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    24f5:	add    $0x1,%rcx
    24f9:	movzbl -0x1(%rcx),%r8d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    24fe:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2502:	cmp    -0x1(%rdx),%r8b
    2506:	je     24f0 <__inode_permission+0x70>
__inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:420
    return 0;
    2508:	mov    %r13d,%esi
    250b:	mov    %rbx,%rdi
    250e:	callq  2513 <__inode_permission+0x93>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:423
}

/**
    2513:	pop    %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:420

	// return security_inode_permission(inode, mask);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    return security_inode_permission(inode, mask);
  else
    return 0;
    2514:	mov    %eax,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:423
}

/**
    2517:	mov    %r12d,%eax
    251a:	pop    %r12
    251c:	pop    %r13
    251e:	pop    %rbp
    251f:	retq   
devcgroup_inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/device_cgroup.h:10
		return 0;
	if (!S_ISBLK(inode->i_mode) && !S_ISCHR(inode->i_mode))
    2520:	movzwl (%rbx),%eax
    2523:	and    $0xb000,%ax
    2527:	cmp    $0x2000,%ax
    252b:	jne    24cf <__inode_permission+0x4f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/device_cgroup.h:12
		return 0;
	return __devcgroup_inode_permission(inode, mask);
    252d:	mov    %r13d,%esi
    2530:	mov    %rbx,%rdi
    2533:	callq  2538 <__inode_permission+0xb8>
__inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:415
		return retval;

	retval = devcgroup_inode_permission(inode, mask);
	if (retval)
		return retval;

    2538:	test   %eax,%eax
    253a:	je     24cf <__inode_permission+0x4f>
    253c:	mov    %eax,%r12d
    253f:	jmpq   24bb <__inode_permission+0x3b>
do_inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:375
static inline int do_inode_permission(struct inode *inode, int mask)
{
	if (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {
		if (likely(inode->i_op->permission))
			return inode->i_op->permission(inode, mask);

    2544:	mov    0x20(%rbx),%rax
    2548:	mov    0x10(%rax),%rax
    254c:	test   %rax,%rax
    254f:	je     2576 <__inode_permission+0xf6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:376
		/* This gets set once for the inode lifetime */
    2551:	mov    %r13d,%esi
    2554:	mov    %rbx,%rdi
    2557:	callq  *%rax
    2559:	mov    %eax,%r12d
    255c:	jmpq   24b6 <__inode_permission+0x36>
__inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:406
		/*
		 * Nobody gets write access to an immutable file.
		 */
		if (IS_IMMUTABLE(inode))
			return -EACCES;
	}
    2561:	testb  $0x8,0xc(%rdi)
    2565:	je     249e <__inode_permission+0x1e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:407

    256b:	mov    $0xfffffff3,%r12d
    2571:	jmpq   24bb <__inode_permission+0x3b>
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    2576:	lea    0x88(%rbx),%r12
    257d:	mov    %r12,%rdi
    2580:	callq  2585 <__inode_permission+0x105>
do_inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:380

		/* This gets set once for the inode lifetime */
		spin_lock(&inode->i_lock);
		inode->i_opflags |= IOP_FASTPERM;
		spin_unlock(&inode->i_lock);
	}
    2585:	orw    $0x1,0x2(%rbx)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    258a:	mov    %r12,%rdi
    258d:	callq  2592 <__inode_permission+0x112>
    2592:	jmpq   24a8 <__inode_permission+0x28>
__inode_permission():
    2597:	nopw   0x0(%rax,%rax,1)

00000000000025a0 <inode_permission>:
inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:458
 * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.
 */
int inode_permission(struct inode *inode, int mask)
{
	int retval;

    25a0:	callq  25a5 <inode_permission+0x5>
    25a5:	push   %rbp
sb_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:435
 */
static int sb_permission(struct super_block *sb, struct inode *inode, int mask)
{
	if (unlikely(mask & MAY_WRITE)) {
		umode_t mode = inode->i_mode;

    25a6:	test   $0x2,%sil
inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:461
{
	int retval;

	retval = sb_permission(inode->i_sb, inode, mask);
	if (retval)
		return retval;
    25aa:	mov    0x28(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:458
 * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.
 */
int inode_permission(struct inode *inode, int mask)
{
	int retval;

    25ae:	mov    %rsp,%rbp
sb_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:435
 */
static int sb_permission(struct super_block *sb, struct inode *inode, int mask)
{
	if (unlikely(mask & MAY_WRITE)) {
		umode_t mode = inode->i_mode;

    25b1:	jne    25ba <inode_permission+0x1a>
inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:464
	retval = sb_permission(inode->i_sb, inode, mask);
	if (retval)
		return retval;
	return __inode_permission(inode, mask);
}

    25b3:	callq  25b8 <inode_permission+0x18>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:465
/**
    25b8:	pop    %rbp
    25b9:	retq   
sb_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:439
		umode_t mode = inode->i_mode;

		/* Nobody gets write access to a read-only fs. */
		if ((sb->s_flags & MS_RDONLY) &&
		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
			return -EROFS;
    25ba:	testb  $0x1,0x50(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:436
static int sb_permission(struct super_block *sb, struct inode *inode, int mask)
{
	if (unlikely(mask & MAY_WRITE)) {
		umode_t mode = inode->i_mode;

		/* Nobody gets write access to a read-only fs. */
    25be:	movzwl (%rdi),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:439
		if ((sb->s_flags & MS_RDONLY) &&
		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
			return -EROFS;
    25c1:	je     25b3 <inode_permission+0x13>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:440
	}
    25c3:	mov    %edx,%eax
    25c5:	and    $0xd000,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:439
		umode_t mode = inode->i_mode;

		/* Nobody gets write access to a read-only fs. */
		if ((sb->s_flags & MS_RDONLY) &&
		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
			return -EROFS;
    25c9:	cmp    $0x8000,%ax
    25cd:	je     25db <inode_permission+0x3b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:440
	}
    25cf:	and    $0xf000,%dx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:439
		umode_t mode = inode->i_mode;

		/* Nobody gets write access to a read-only fs. */
		if ((sb->s_flags & MS_RDONLY) &&
		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
			return -EROFS;
    25d4:	cmp    $0x4000,%dx
    25d9:	jne    25b3 <inode_permission+0x13>
    25db:	mov    $0xffffffe2,%eax
inode_permission():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:465
	if (retval)
		return retval;
	return __inode_permission(inode, mask);
}

/**
    25e0:	pop    %rbp
    25e1:	retq   
    25e2:	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

00000000000025f0 <path_init>:
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1828
		struct dentry *root = nd->root.dentry;
		struct inode *inode = root->d_inode;
		if (*name) {
			if (!d_is_directory(root))
				return -ENOTDIR;
			retval = inode_permission(inode, MAY_EXEC);
    25f0:	callq  25f5 <path_init+0x5>
    25f5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1832
			if (retval)
				return retval;
		}
		nd->path = nd->root;
    25f6:	mov    %edx,%eax
    25f8:	or     $0x10,%ah
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1828
		struct dentry *root = nd->root.dentry;
		struct inode *inode = root->d_inode;
		if (*name) {
			if (!d_is_directory(root))
				return -ENOTDIR;
			retval = inode_permission(inode, MAY_EXEC);
    25fb:	mov    %rsp,%rbp
    25fe:	push   %r15
    2600:	push   %r14
    2602:	push   %r13
    2604:	mov    %rsi,%r13
    2607:	push   %r12
    2609:	mov    %edx,%r12d
    260c:	push   %rbx
    260d:	mov    %rcx,%rbx
    2610:	sub    $0x10,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1834
			if (retval)
				return retval;
		}
		nd->path = nd->root;
		nd->inode = inode;
		if (flags & LOOKUP_RCU) {
    2614:	test   $0x20,%dh
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1831
			if (!d_is_directory(root))
				return -ENOTDIR;
			retval = inode_permission(inode, MAY_EXEC);
			if (retval)
				return retval;
		}
    2617:	movl   $0x1,0x44(%rcx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1832
		nd->path = nd->root;
    261e:	mov    %eax,0x38(%rcx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1833
		nd->inode = inode;
    2621:	movl   $0x0,0x48(%rcx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1834
		if (flags & LOOKUP_RCU) {
    2628:	je     2690 <path_init+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1837
			rcu_read_lock();
			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			nd->m_seq = read_seqbegin(&mount_lock);
    262a:	cmpb   $0x0,(%rsi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1835
				return retval;
		}
		nd->path = nd->root;
		nd->inode = inode;
		if (flags & LOOKUP_RCU) {
			rcu_read_lock();
    262d:	mov    0x28(%rcx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1836
			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
    2631:	mov    0x30(%rax),%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1837
			nd->m_seq = read_seqbegin(&mount_lock);
    2635:	jne    2720 <path_init+0x130>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1844
			path_get(&nd->path);
		}
		return 0;
	}

	nd->root.mnt = NULL;
    263b:	mov    0x20(%rbx),%rax
    263f:	mov    0x28(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1846

	nd->m_seq = read_seqbegin(&mount_lock);
    2643:	and    $0x40,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1845
		}
		return 0;
	}

	nd->root.mnt = NULL;

    2647:	mov    %r14,0x30(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1844
			path_get(&nd->path);
		}
		return 0;
	}

	nd->root.mnt = NULL;
    264b:	mov    %rax,(%rbx)
    264e:	mov    %rdx,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1846

	nd->m_seq = read_seqbegin(&mount_lock);
    2652:	je     2940 <path_init+0x350>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1848
	if (*name=='/') {
		if (flags & LOOKUP_RCU) {
    2658:	mov    0x8(%rbx),%rdx
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    265c:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    265f:	test   $0x1,%al
    2661:	jne    2d92 <path_init+0x7a2>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1848
    2667:	mov    %eax,0x3c(%rbx)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    266a:	mov    0x0(%rip),%eax        # 2670 <path_init+0x80>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2670:	test   $0x1,%al
    2672:	jne    2d7e <path_init+0x78e>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1849
			rcu_read_lock();
    2678:	mov    %eax,0x40(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1853
			set_root_rcu(nd);
		} else {
			set_root(nd);
			path_get(&nd->root);
    267b:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1914
	nd->flags &= ~LOOKUP_PARENT;
	return walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);
}

/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
    267d:	add    $0x10,%rsp
    2681:	pop    %rbx
    2682:	pop    %r12
    2684:	pop    %r13
    2686:	pop    %r14
    2688:	pop    %r15
    268a:	pop    %rbp
    268b:	retq   
    268c:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1856
		} else {
			set_root(nd);
			path_get(&nd->root);
		}
		nd->path = nd->root;
	} else if (dfd == AT_FDCWD) {
    2690:	movq   $0x0,0x20(%rcx)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2698:	mov    0x0(%rip),%eax        # 269e <path_init+0xae>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    269e:	test   $0x1,%al
    26a0:	jne    2a9d <path_init+0x4ad>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1858
		if (flags & LOOKUP_RCU) {
			struct fs_struct *fs = current->fs;
    26a6:	mov    %eax,0x40(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1859
			unsigned seq;
    26a9:	cmpb   $0x2f,0x0(%r13)
    26ae:	je     28b8 <path_init+0x2c8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1868
			do {
				seq = read_seqcount_begin(&fs->seq);
				nd->path = fs->pwd;
				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			} while (read_seqcount_retry(&fs->seq, seq));
		} else {
    26b4:	cmp    $0xffffff9c,%edi
    26b7:	je     2750 <path_init+0x160>
fdget_raw():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/file.h:56
extern struct file *fget_raw_light(unsigned int fd, int *fput_needed);

static inline struct fd fdget_raw(unsigned int fd)
{
	int b;
	struct file *f = fget_raw_light(fd, &b);
    26bd:	lea    0xc(%rsp),%rsi
    26c2:	mov    %r8,(%rsp)
    26c6:	callq  26cb <path_init+0xdb>
    26cb:	mov    %rax,%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/file.h:57
	return (struct fd){f,b};
    26ce:	mov    0xc(%rsp),%r15d
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1889
				return -ENOTDIR;
			}
		}

		nd->path = f.file->f_path;
		if (flags & LOOKUP_RCU) {
    26d3:	mov    $0xfffffff7,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1888
				fdput(f);
				return -ENOTDIR;
			}
		}

		nd->path = f.file->f_path;
    26d8:	test   %r14,%r14
    26db:	je     267d <path_init+0x8d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1893
		if (flags & LOOKUP_RCU) {
			if (f.need_put)
				*fp = f.file;
			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			rcu_read_lock();
    26dd:	cmpb   $0x0,0x0(%r13)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1891
		}

		nd->path = f.file->f_path;
		if (flags & LOOKUP_RCU) {
			if (f.need_put)
				*fp = f.file;
    26e2:	mov    0x18(%r14),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1893
			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			rcu_read_lock();
    26e6:	mov    (%rsp),%r8
    26ea:	je     2900 <path_init+0x310>
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    26f0:	mov    (%rax),%eax
    26f2:	and    $0x700000,%eax
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1894
		} else {
    26f7:	cmp    $0x100000,%eax
    26fc:	je     2900 <path_init+0x310>
fdput():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/file.h:36
	int need_put;
};

static inline void fdput(struct fd fd)
{
	if (fd.need_put)
    2702:	test   %r15d,%r15d
    2705:	jne    2a90 <path_init+0x4a0>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1914
	nd->flags &= ~LOOKUP_PARENT;
	return walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);
}

/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
    270b:	add    $0x10,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1896
				*fp = f.file;
			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			rcu_read_lock();
		} else {
			path_get(&nd->path);
			fdput(f);
    270f:	mov    $0xffffffec,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1914
	nd->flags &= ~LOOKUP_PARENT;
	return walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);
}

/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
    2714:	pop    %rbx
    2715:	pop    %r12
    2717:	pop    %r13
    2719:	pop    %r14
    271b:	pop    %r15
    271d:	pop    %rbp
    271e:	retq   
    271f:	nop
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    2720:	mov    (%rax),%eax
    2722:	and    $0x700000,%eax
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1838
		nd->inode = inode;
		if (flags & LOOKUP_RCU) {
			rcu_read_lock();
			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			nd->m_seq = read_seqbegin(&mount_lock);
		} else {
    2727:	cmp    $0x100000,%eax
    272c:	jne    270b <path_init+0x11b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1840
			path_get(&nd->path);
		}
    272e:	mov    $0x1,%esi
    2733:	mov    %r14,%rdi
    2736:	callq  273b <path_init+0x14b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1841
		return 0;
    273b:	test   %eax,%eax
    273d:	je     263b <path_init+0x4b>
    2743:	jmpq   267d <path_init+0x8d>
    2748:	nopl   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2750:	mov    %gs:0x0,%rdx
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1870
				nd->path = fs->pwd;
				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			} while (read_seqcount_retry(&fs->seq, seq));
		} else {
			get_fs_pwd(current->fs, &nd->path);
		}
    2759:	add    $0x4a8,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1869
				seq = read_seqcount_begin(&fs->seq);
				nd->path = fs->pwd;
				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			} while (read_seqcount_retry(&fs->seq, seq));
		} else {
			get_fs_pwd(current->fs, &nd->path);
    2760:	and    $0x40,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1870
		}
    2764:	mov    $0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1869
				seq = read_seqcount_begin(&fs->seq);
				nd->path = fs->pwd;
				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			} while (read_seqcount_retry(&fs->seq, seq));
		} else {
			get_fs_pwd(current->fs, &nd->path);
    276b:	je     27e0 <path_init+0x1f0>
    276d:	jmp    2778 <path_init+0x188>
    276f:	nop
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2770:	test   %cl,%cl
    2772:	je     2ab8 <path_init+0x4c8>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2778:	add    $0x1,%rdx
    277c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    2780:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    2784:	cmp    -0x1(%rax),%cl
    2787:	je     2770 <path_init+0x180>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1870
		}
    2789:	mov    %gs:0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1870 (discriminator 3)
    2792:	mov    0x588(%rax),%rcx
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2799:	mov    0x8(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    279c:	test   $0x1,%sil
    27a0:	jne    2e14 <path_init+0x824>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1877
		/* Caller must check execute permissions on the starting path component */
		struct fd f = fdget_raw(dfd);
		struct dentry *dentry;

		if (!f.file)
			return -EBADF;
    27a6:	mov    0x30(%rcx),%rdx
    27aa:	mov    0x28(%rcx),%rax
    27ae:	mov    %rdx,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1878

    27b2:	mov    0x8(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1877
		/* Caller must check execute permissions on the starting path component */
		struct fd f = fdget_raw(dfd);
		struct dentry *dentry;

		if (!f.file)
			return -EBADF;
    27b6:	mov    %rax,(%rbx)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    27b9:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    27bc:	test   $0x1,%al
    27be:	jne    2e05 <path_init+0x815>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1878

    27c4:	mov    %eax,0x3c(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1879
		dentry = f.file->f_path.dentry;
    27c7:	cmp    0x8(%rcx),%esi
    27ca:	je     28dc <path_init+0x2ec>
    27d0:	jmp    2799 <path_init+0x1a9>
    27d2:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
			return c1 < c2 ? -1 : 1;
		if (!c1)
    27d8:	test   %cl,%cl
    27da:	je     2ad8 <path_init+0x4e8>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    27e0:	add    $0x1,%rdx
    27e4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    27e8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    27ec:	cmp    -0x1(%rax),%cl
    27ef:	je     27d8 <path_init+0x1e8>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1881

		if (*name) {
    27f1:	mov    %gs:0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1881 (discriminator 3)
    27fa:	mov    0x588(%rax),%r13
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293 (discriminator 3)
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    2801:	lea    0x4(%r13),%r12
    2805:	mov    %r12,%rdi
    2808:	callq  280d <path_init+0x21d>
get_fs_pwd():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:37 (discriminator 3)
}

static inline void get_fs_pwd(struct fs_struct *fs, struct path *pwd)
{
	spin_lock(&fs->lock);
	*pwd = fs->pwd;
    280d:	mov    0x28(%r13),%rax
    2811:	mov    0x30(%r13),%rdx
    2815:	mov    %rax,%rdi
    2818:	mov    %rdx,0x8(%rbx)
    281c:	mov    %rax,(%rbx)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475 (discriminator 3)
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    281f:	callq  2824 <path_init+0x234>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19 (discriminator 3)

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    2824:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476 (discriminator 3)
EXPORT_SYMBOL(path_get);
    282d:	mov    0x8(%rbx),%r13
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360 (discriminator 3)
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    2831:	add    $0x4a8,%rdx
    2838:	mov    $0x0,%rax
    283f:	jmp    2850 <path_init+0x260>
    2841:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2848:	test   %cl,%cl
    284a:	je     2d00 <path_init+0x710>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2850:	add    $0x1,%rdx
    2854:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2858:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    285c:	cmp    -0x1(%rax),%cl
    285f:	je     2848 <path_init+0x258>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2861:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    286a:	mov    $0x0,%rax
    2871:	add    $0x4a8,%rdx
    2878:	jmp    2888 <path_init+0x298>
    287a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2880:	test   %cl,%cl
    2882:	je     2d00 <path_init+0x710>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2888:	add    $0x1,%rdx
    288c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2890:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2894:	cmp    -0x1(%rax),%cl
    2897:	je     2880 <path_init+0x290>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    2899:	test   %r13,%r13
    289c:	je     28a7 <path_init+0x2b7>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    289e:	lea    0x58(%r13),%rdi
    28a2:	callq  28a7 <path_init+0x2b7>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    28a7:	mov    %r12,%rdi
    28aa:	callq  28af <path_init+0x2bf>
    28af:	jmp    28dc <path_init+0x2ec>
    28b1:	nopl   0x0(%rax)
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1860
		nd->path = nd->root;
	} else if (dfd == AT_FDCWD) {
		if (flags & LOOKUP_RCU) {
			struct fs_struct *fs = current->fs;
			unsigned seq;

    28b8:	and    $0x40,%r12d
    28bc:	je     29e0 <path_init+0x3f0>
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:659

static __always_inline void set_root_rcu(struct nameidata *nd)
{
	if (!nd->root.mnt) {
		struct fs_struct *fs = current->fs;
		unsigned seq;
    28c2:	cmpq   $0x0,0x20(%rbx)
    28c7:	je     2b96 <path_init+0x5a6>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1867 (discriminator 1)

			do {
				seq = read_seqcount_begin(&fs->seq);
				nd->path = fs->pwd;
				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			} while (read_seqcount_retry(&fs->seq, seq));
    28cd:	mov    0x20(%rbx),%rax
    28d1:	mov    0x28(%rbx),%rdx
    28d5:	mov    %rax,(%rbx)
    28d8:	mov    %rdx,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1912
		nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;

	nd->flags &= ~LOOKUP_PARENT;
	return walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);
}

    28dc:	mov    0x8(%rbx),%rax
    28e0:	mov    0x30(%rax),%rax
    28e4:	mov    %rax,0x30(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1914
/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
    28e8:	add    $0x10,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1913

	nd->flags &= ~LOOKUP_PARENT;
	return walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);
}

/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
    28ec:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1914
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
    28ee:	pop    %rbx
    28ef:	pop    %r12
    28f1:	pop    %r13
    28f3:	pop    %r14
    28f5:	pop    %r15
    28f7:	pop    %rbp
    28f8:	retq   
    28f9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1900
			path_get(&nd->path);
			fdput(f);
		}
	}

	nd->inode = nd->path.dentry->d_inode;
    2900:	mov    0x10(%r14),%rsi
    2904:	mov    0x18(%r14),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1901
	return 0;
    2908:	and    $0x40,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1900
			path_get(&nd->path);
			fdput(f);
		}
	}

	nd->inode = nd->path.dentry->d_inode;
    290c:	mov    %rsi,(%rbx)
    290f:	mov    %rdi,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1901
	return 0;
    2913:	je     2af8 <path_init+0x508>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1902
}
    2919:	test   %r15d,%r15d
    291c:	jne    2a80 <path_init+0x490>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1904

static inline int lookup_last(struct nameidata *nd, struct path *path)
    2922:	mov    0x8(%rbx),%rdx
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2926:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2929:	test   $0x1,%al
    292b:	jne    2df6 <path_init+0x806>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1904
    2931:	mov    %eax,0x3c(%rbx)
__rcu_read_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/rcupdate.h:198

#else /* #ifdef CONFIG_PREEMPT_RCU */

static inline void __rcu_read_lock(void)
{
	preempt_disable();
    2934:	jmp    28dc <path_init+0x2ec>
    2936:	nopw   %cs:0x0(%rax,%rax,1)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    2940:	mov    (%rbx),%rdi
    2943:	callq  2948 <path_init+0x358>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2948:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    2951:	mov    0x8(%rbx),%rbx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    2955:	add    $0x4a8,%rdx
    295c:	mov    $0x0,%rax
    2963:	jmp    2970 <path_init+0x380>
    2965:	nopl   (%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2968:	test   %cl,%cl
    296a:	je     2d54 <path_init+0x764>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2970:	add    $0x1,%rdx
    2974:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2978:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    297c:	cmp    -0x1(%rax),%cl
    297f:	je     2968 <path_init+0x378>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2981:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    298a:	mov    $0x0,%rax
    2991:	add    $0x4a8,%rdx
    2998:	jmp    29a8 <path_init+0x3b8>
    299a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    29a0:	test   %cl,%cl
    29a2:	je     2d54 <path_init+0x764>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    29a8:	add    $0x1,%rdx
    29ac:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    29b0:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    29b4:	cmp    -0x1(%rax),%cl
    29b7:	je     29a0 <path_init+0x3b0>
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1853
		if (flags & LOOKUP_RCU) {
			rcu_read_lock();
			set_root_rcu(nd);
		} else {
			set_root(nd);
			path_get(&nd->root);
    29b9:	xor    %eax,%eax
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    29bb:	test   %rbx,%rbx
    29be:	je     267d <path_init+0x8d>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    29c4:	lea    0x58(%rbx),%rdi
    29c8:	mov    %eax,(%rsp)
    29cb:	callq  29d0 <path_init+0x3e0>
    29d0:	mov    (%rsp),%eax
    29d3:	jmpq   267d <path_init+0x8d>
    29d8:	nopl   0x0(%rax,%rax,1)
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    29e0:	mov    0x20(%rbx),%rdi
    29e4:	test   %rdi,%rdi
    29e7:	je     2c10 <path_init+0x620>
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    29ed:	callq  29f2 <path_init+0x402>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    29f2:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    29fb:	mov    0x28(%rbx),%r12
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    29ff:	add    $0x4a8,%rdx
    2a06:	mov    $0x0,%rax
    2a0d:	jmp    2a18 <path_init+0x428>
    2a0f:	nop
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2a10:	test   %cl,%cl
    2a12:	je     2d2a <path_init+0x73a>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2a18:	add    $0x1,%rdx
    2a1c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2a20:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2a24:	cmp    -0x1(%rax),%cl
    2a27:	je     2a10 <path_init+0x420>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2a29:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    2a32:	mov    $0x0,%rax
    2a39:	add    $0x4a8,%rdx
    2a40:	jmp    2a50 <path_init+0x460>
    2a42:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2a48:	test   %cl,%cl
    2a4a:	je     2d2a <path_init+0x73a>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2a50:	add    $0x1,%rdx
    2a54:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2a58:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2a5c:	cmp    -0x1(%rax),%cl
    2a5f:	je     2a48 <path_init+0x458>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    2a61:	test   %r12,%r12
    2a64:	je     28cd <path_init+0x2dd>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    2a6a:	lea    0x58(%r12),%rdi
    2a6f:	callq  2a74 <path_init+0x484>
    2a74:	jmpq   28cd <path_init+0x2dd>
    2a79:	nopl   0x0(%rax)
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1903
	}

	nd->inode = nd->path.dentry->d_inode;
	return 0;
}

    2a80:	mov    %r14,(%r8)
    2a83:	jmpq   2922 <path_init+0x332>
    2a88:	nopl   0x0(%rax,%rax,1)
fdput():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/file.h:37
		fput(fd.file);
    2a90:	mov    %r14,%rdi
    2a93:	callq  2a98 <path_init+0x4a8>
    2a98:	jmpq   270b <path_init+0x11b>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    2a9d:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2a9f:	mov    0x0(%rip),%eax        # 2aa5 <path_init+0x4b5>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2aa5:	test   $0x1,%al
    2aa7:	je     26a6 <path_init+0xb6>
    2aad:	nopl   (%rax)
    2ab0:	jmp    2a9d <path_init+0x4ad>
    2ab2:	nopw   0x0(%rax,%rax,1)
path_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1870
				nd->path = fs->pwd;
				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
			} while (read_seqcount_retry(&fs->seq, seq));
		} else {
			get_fs_pwd(current->fs, &nd->path);
		}
    2ab8:	cmpb   $0x0,0x0(%rip)        # 2abf <path_init+0x4cf>
    2abf:	mov    0x0(%rip),%rax        # 2ac6 <path_init+0x4d6>
    2ac6:	jne    2792 <path_init+0x1a2>
    2acc:	jmpq   2789 <path_init+0x199>
    2ad1:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1881
		if (!f.file)
			return -EBADF;

		dentry = f.file->f_path.dentry;

		if (*name) {
    2ad8:	cmpb   $0x0,0x0(%rip)        # 2adf <path_init+0x4ef>
    2adf:	mov    0x0(%rip),%rax        # 2ae6 <path_init+0x4f6>
    2ae6:	jne    27fa <path_init+0x20a>
    2aec:	jmpq   27f1 <path_init+0x201>
    2af1:	nopl   0x0(%rax)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    2af8:	mov    (%rbx),%rdi
    2afb:	callq  2b00 <path_init+0x510>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2b00:	mov    %gs:0x0,%rax
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    2b09:	mov    0x8(%rbx),%r12
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    2b0d:	add    $0x4a8,%rax
    2b13:	mov    $0x0,%rdx
    2b1a:	jmp    2b28 <path_init+0x538>
    2b1c:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2b20:	test   %cl,%cl
    2b22:	je     2dcc <path_init+0x7dc>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2b28:	add    $0x1,%rax
    2b2c:	movzbl -0x1(%rax),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2b30:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2b34:	cmp    -0x1(%rdx),%cl
    2b37:	je     2b20 <path_init+0x530>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2b39:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    2b42:	mov    $0x0,%rax
    2b49:	add    $0x4a8,%rdx
    2b50:	jmp    2b60 <path_init+0x570>
    2b52:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2b58:	test   %cl,%cl
    2b5a:	je     2dcc <path_init+0x7dc>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2b60:	add    $0x1,%rdx
    2b64:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2b68:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2b6c:	cmp    -0x1(%rax),%cl
    2b6f:	je     2b58 <path_init+0x568>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    2b71:	test   %r12,%r12
    2b74:	je     2b80 <path_init+0x590>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    2b76:	lea    0x58(%r12),%rdi
    2b7b:	callq  2b80 <path_init+0x590>
fdput():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/file.h:36
	int need_put;
};

static inline void fdput(struct fd fd)
{
	if (fd.need_put)
    2b80:	test   %r15d,%r15d
    2b83:	je     28dc <path_init+0x2ec>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/file.h:37
		fput(fd.file);
    2b89:	mov    %r14,%rdi
    2b8c:	callq  2b91 <path_init+0x5a1>
    2b91:	jmpq   28dc <path_init+0x2ec>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2b96:	mov    %gs:0x0,%rdi
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:660
static __always_inline void set_root_rcu(struct nameidata *nd)
{
	if (!nd->root.mnt) {
		struct fs_struct *fs = current->fs;
		unsigned seq;

    2b9f:	add    $0x4a8,%rdi
    2ba6:	callq  1370 <my_strcmp_base.constprop.35>
    2bab:	test   %eax,%eax
    2bad:	jne    2bbf <path_init+0x5cf>
    2baf:	cmpb   $0x0,0x0(%rip)        # 2bb6 <path_init+0x5c6>
    2bb6:	mov    0x0(%rip),%rax        # 2bbd <path_init+0x5cd>
    2bbd:	jne    2bc8 <path_init+0x5d8>
    2bbf:	mov    %gs:0x0,%rax
    2bc8:	mov    0x588(%rax),%rcx
    2bcf:	jmp    2c03 <path_init+0x613>
    2bd1:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:665
		do {
			seq = read_seqcount_begin(&fs->seq);
			nd->root = fs->root;
			nd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
		} while (read_seqcount_retry(&fs->seq, seq));
    2bd8:	mov    0x20(%rcx),%rdx
    2bdc:	mov    0x18(%rcx),%rax
    2be0:	mov    %rdx,0x28(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:666
	}
    2be4:	mov    0x28(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:665

		do {
			seq = read_seqcount_begin(&fs->seq);
			nd->root = fs->root;
			nd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
		} while (read_seqcount_retry(&fs->seq, seq));
    2be8:	mov    %rax,0x20(%rbx)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2bec:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2bef:	test   $0x1,%al
    2bf1:	jne    2e1b <path_init+0x82b>
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:666
	}
    2bf7:	mov    %eax,0x3c(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:667
}
    2bfa:	cmp    0x8(%rcx),%esi
    2bfd:	je     28cd <path_init+0x2dd>
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2c03:	mov    0x8(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2c06:	test   $0x1,%sil
    2c0a:	je     2bd8 <path_init+0x5e8>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    2c0c:	pause  
    2c0e:	jmp    2c03 <path_init+0x613>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2c10:	mov    %gs:0x0,%rdi
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652
static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}

    2c19:	add    $0x4a8,%rdi
    2c20:	callq  1370 <my_strcmp_base.constprop.35>
    2c25:	test   %eax,%eax
    2c27:	jne    2c39 <path_init+0x649>
    2c29:	cmpb   $0x0,0x0(%rip)        # 2c30 <path_init+0x640>
    2c30:	mov    0x0(%rip),%rax        # 2c37 <path_init+0x647>
    2c37:	jne    2c42 <path_init+0x652>
    2c39:	mov    %gs:0x0,%rax
    2c42:	mov    0x588(%rax),%r13
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    2c49:	lea    0x4(%r13),%r12
    2c4d:	mov    %r12,%rdi
    2c50:	callq  2c55 <path_init+0x665>
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:29
extern int unshare_fs_struct(void);

static inline void get_fs_root(struct fs_struct *fs, struct path *root)
{
	spin_lock(&fs->lock);
	*root = fs->root;
    2c55:	mov    0x18(%r13),%rax
    2c59:	mov    0x20(%r13),%rdx
    2c5d:	mov    %rax,%rdi
    2c60:	mov    %rdx,0x28(%rbx)
    2c64:	mov    %rax,0x20(%rbx)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    2c68:	callq  2c6d <path_init+0x67d>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2c6d:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    2c76:	mov    0x28(%rbx),%r13
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    2c7a:	add    $0x4a8,%rdx
    2c81:	mov    $0x0,%rax
    2c88:	jmp    2c98 <path_init+0x6a8>
    2c8a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2c90:	test   %cl,%cl
    2c92:	je     2da2 <path_init+0x7b2>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2c98:	add    $0x1,%rdx
    2c9c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2ca0:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2ca4:	cmp    -0x1(%rax),%cl
    2ca7:	je     2c90 <path_init+0x6a0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2ca9:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    2cb2:	mov    $0x0,%rax
    2cb9:	add    $0x4a8,%rdx
    2cc0:	jmp    2cd0 <path_init+0x6e0>
    2cc2:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    2cc8:	test   %cl,%cl
    2cca:	je     2da2 <path_init+0x7b2>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    2cd0:	add    $0x1,%rdx
    2cd4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    2cd8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    2cdc:	cmp    -0x1(%rax),%cl
    2cdf:	je     2cc8 <path_init+0x6d8>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    2ce1:	test   %r13,%r13
    2ce4:	je     2cef <path_init+0x6ff>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    2ce6:	lea    0x58(%r13),%rdi
    2cea:	callq  2cef <path_init+0x6ff>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    2cef:	mov    %r12,%rdi
    2cf2:	callq  2cf7 <path_init+0x707>
    2cf7:	mov    0x20(%rbx),%rdi
    2cfb:	jmpq   29ed <path_init+0x3fd>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2d00:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    2d09:	mov    $0x0,%rsi
    2d10:	add    $0x4a8,%rdx
    2d17:	mov    $0x0,%rdi
    2d1e:	xor    %eax,%eax
    2d20:	callq  2d25 <path_init+0x735>
    2d25:	jmpq   2899 <path_init+0x2a9>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2d2a:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    2d33:	mov    $0x0,%rsi
    2d3a:	add    $0x4a8,%rdx
    2d41:	mov    $0x0,%rdi
    2d48:	xor    %eax,%eax
    2d4a:	callq  2d4f <path_init+0x75f>
    2d4f:	jmpq   2a61 <path_init+0x471>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2d54:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    2d5d:	mov    $0x0,%rsi
    2d64:	add    $0x4a8,%rdx
    2d6b:	mov    $0x0,%rdi
    2d72:	xor    %eax,%eax
    2d74:	callq  2d79 <path_init+0x789>
    2d79:	jmpq   29b9 <path_init+0x3c9>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    2d7e:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2d80:	mov    0x0(%rip),%eax        # 2d86 <path_init+0x796>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2d86:	test   $0x1,%al
    2d88:	je     2678 <path_init+0x88>
    2d8e:	xchg   %ax,%ax
    2d90:	jmp    2d7e <path_init+0x78e>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    2d92:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2d94:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2d97:	test   $0x1,%al
    2d99:	je     2667 <path_init+0x77>
    2d9f:	nop
    2da0:	jmp    2d92 <path_init+0x7a2>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2da2:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    2dab:	mov    $0x0,%rsi
    2db2:	add    $0x4a8,%rdx
    2db9:	mov    $0x0,%rdi
    2dc0:	xor    %eax,%eax
    2dc2:	callq  2dc7 <path_init+0x7d7>
    2dc7:	jmpq   2ce1 <path_init+0x6f1>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2dcc:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    2dd5:	mov    $0x0,%rsi
    2ddc:	add    $0x4a8,%rdx
    2de3:	mov    $0x0,%rdi
    2dea:	xor    %eax,%eax
    2dec:	callq  2df1 <path_init+0x801>
    2df1:	jmpq   2b71 <path_init+0x581>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    2df6:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2df8:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2dfb:	test   $0x1,%al
    2dfd:	je     2931 <path_init+0x341>
    2e03:	jmp    2df6 <path_init+0x806>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    2e05:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2e07:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2e0a:	test   $0x1,%al
    2e0c:	je     27c4 <path_init+0x1d4>
    2e12:	jmp    2e05 <path_init+0x815>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    2e14:	pause  
    2e16:	jmpq   2799 <path_init+0x1a9>
    2e1b:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    2e1d:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    2e20:	test   $0x1,%al
    2e22:	je     2bf7 <path_init+0x607>
    2e28:	jmp    2e1b <path_init+0x82b>
path_init():
    2e2a:	nopw   0x0(%rax,%rax,1)

0000000000002e30 <link_path_walk>:
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1747
	if (!*name)
		return 0;

	/* At this point we know we have a real path component. */
	for(;;) {
		struct qstr this;
    2e30:	callq  2e35 <link_path_walk+0x5>
    2e35:	push   %rbp
    2e36:	mov    %rsp,%rbp
    2e39:	push   %r15
    2e3b:	push   %r14
    2e3d:	push   %r13
    2e3f:	push   %r12
    2e41:	mov    %rdi,%r12
    2e44:	push   %rbx
    2e45:	mov    %rsi,%rbx
    2e48:	sub    $0x60,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1751
		long len;
		int type;

		err = may_lookup(nd);
    2e4c:	movzbl (%rdi),%eax
    2e4f:	cmp    $0x2f,%al
    2e51:	jne    2e65 <link_path_walk+0x35>
    2e53:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1752
 		if (err)
    2e58:	add    $0x1,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1751
	for(;;) {
		struct qstr this;
		long len;
		int type;

		err = may_lookup(nd);
    2e5c:	movzbl (%r12),%eax
    2e61:	cmp    $0x2f,%al
    2e63:	je     2e58 <link_path_walk+0x28>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1753
 		if (err)
			break;
    2e65:	test   %al,%al
    2e67:	je     30bd <link_path_walk+0x28d>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    2e6d:	mov    %gs:0x0,%r15
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    2e76:	lea    0x4a8(%r15),%rax
    2e7d:	mov    %rax,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

	touch_atime(link);
	nd_set_link(nd, NULL);

    2e82:	mov    %rax,0x10(%rsp)
    2e87:	nopw   0x0(%rax,%rax,1)
may_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1489
			return -ECHILD;
	}
	return inode_permission(nd->inode, MAY_EXEC);
}

static inline int handle_dots(struct nameidata *nd, int type)
    2e90:	testb  $0x40,0x38(%rbx)
    2e94:	je     3078 <link_path_walk+0x248>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1490
{
    2e9a:	mov    0x30(%rbx),%rdi
    2e9e:	mov    $0x81,%esi
    2ea3:	callq  2ea8 <link_path_walk+0x78>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1491
	if (type == LAST_DOTDOT) {
    2ea8:	cmp    $0xfffffff6,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1490
	}
	return inode_permission(nd->inode, MAY_EXEC);
}

static inline int handle_dots(struct nameidata *nd, int type)
{
    2eab:	mov    %eax,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1491
	if (type == LAST_DOTDOT) {
    2eae:	je     3066 <link_path_walk+0x236>
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1763

		type = LAST_NORM;
		if (name[0] == '.') switch (len) {
			case 2:
				if (name[1] == '.') {
					type = LAST_DOTDOT;
    2eb4:	test   %r14d,%r14d
    2eb7:	jne    304c <link_path_walk+0x21c>
    2ebd:	mov    $0xfffffffffffffff8,%rsi
    2ec4:	xor    %r10d,%r10d
    2ec7:	xor    %edx,%edx
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1692
	mask = create_zero_mask(adata | bdata);

	hash += a & zero_bytemask(mask);
	*hashp = fold_hash(hash);

	return len + find_zero(mask);
    2ec9:	movabs $0x2f2f2f2f2f2f2f2f,%r9
has_zero():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:48
#endif

/* Return nonzero if it has a zero */
static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
{
	unsigned long mask = ((a - c->one_bits) & ~a) & c->high_bits;
    2ed3:	movabs $0xfefefefefefefeff,%r8
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1693
}
    2edd:	movabs $0x8080808080808080,%rdi
    2ee7:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1689
	adata = prep_zero_mask(a, adata, &constants);
	bdata = prep_zero_mask(b, bdata, &constants);

	mask = create_zero_mask(adata | bdata);

	hash += a & zero_bytemask(mask);
    2ef0:	add    %r10,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1690
	*hashp = fold_hash(hash);
    2ef3:	add    $0x8,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1689
	adata = prep_zero_mask(a, adata, &constants);
	bdata = prep_zero_mask(b, bdata, &constants);

	mask = create_zero_mask(adata | bdata);

	hash += a & zero_bytemask(mask);
    2ef7:	lea    (%rdx,%rdx,8),%r10
load_unaligned_zeropad():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:83
 */
static inline unsigned long load_unaligned_zeropad(const void *addr)
{
	unsigned long ret, dummy;

	asm(
    2efb:	mov    (%r12,%rsi,1),%rdx
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1692
	*hashp = fold_hash(hash);

	return len + find_zero(mask);
    2eff:	mov    %rdx,%rcx
has_zero():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:48
#endif

/* Return nonzero if it has a zero */
static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
{
	unsigned long mask = ((a - c->one_bits) & ~a) & c->high_bits;
    2f02:	lea    (%rdx,%r8,1),%r11
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1692
    2f06:	xor    %r9,%rcx
has_zero():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:48
    2f09:	mov    %rcx,%rax
    2f0c:	add    %r8,%rcx
    2f0f:	not    %rax
    2f12:	and    %rcx,%rax
    2f15:	mov    %rdx,%rcx
    2f18:	not    %rcx
    2f1b:	and    %r11,%rcx
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1693
}
    2f1e:	or     %rcx,%rax
    2f21:	and    %rdi,%rax
    2f24:	je     2ef0 <link_path_walk+0xc0>
create_zero_mask():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:60
	return bits;
}

static inline unsigned long create_zero_mask(unsigned long bits)
{
	bits = (bits - 1) & ~bits;
    2f26:	mov    %rax,%rcx
    2f29:	sub    $0x1,%rax
count_masked_bytes():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:29
 * that works for the bytemasks without having to
 * mask them first.
 */
static inline long count_masked_bytes(unsigned long mask)
{
	return mask*0x0001020304050608ul >> 56;
    2f2d:	movabs $0x1020304050608,%r13
create_zero_mask():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:60
	return bits;
}

static inline unsigned long create_zero_mask(unsigned long bits)
{
	bits = (bits - 1) & ~bits;
    2f37:	not    %rcx
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1767
				if (name[1] == '.') {
					type = LAST_DOTDOT;
					nd->flags |= LOOKUP_JUMPED;
				}
				break;
			case 1:
    2f3a:	mov    %r12,0x48(%rsp)
create_zero_mask():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:60
    2f3f:	and    %rax,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:61
	return bits >> 7;
    2f42:	shr    $0x7,%rcx
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1700
#else

unsigned int full_name_hash(const unsigned char *name, unsigned int len)
{
	unsigned long hash = init_name_hash();
	while (len--)
    2f46:	and    %rcx,%rdx
find_zero():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:29
 * that works for the bytemasks without having to
 * mask them first.
 */
static inline long count_masked_bytes(unsigned long mask)
{
	return mask*0x0001020304050608ul >> 56;
    2f49:	imul   %r13,%rcx
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1700
    2f4d:	add    %rdx,%r10
fold_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1644
#define fold_hash(x) (x)

#endif

unsigned int full_name_hash(const unsigned char *name, unsigned int len)
{
    2f50:	mov    %r10,%rax
    2f53:	shr    $0x20,%rax
    2f57:	add    %rax,%r10
find_zero():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/word-at-a-time.h:29
    2f5a:	shr    $0x38,%rcx
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1771
				break;
			case 1:
				type = LAST_DOT;
		}
		if (likely(type == LAST_NORM)) {
			struct dentry *parent = nd->path.dentry;
    2f5e:	cmpb   $0x2e,(%r12)
hash_name():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1645

#endif

unsigned int full_name_hash(const unsigned char *name, unsigned int len)
{
	unsigned long a, mask;
    2f63:	mov    %r10d,0x40(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1703
{
	unsigned long hash = init_name_hash();
	while (len--)
		hash = partial_name_hash(*name++, hash);
	return end_name_hash(hash);
}
    2f68:	lea    (%rcx,%rsi,1),%r13
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1768
					type = LAST_DOTDOT;
					nd->flags |= LOOKUP_JUMPED;
				}
				break;
			case 1:
				type = LAST_DOT;
    2f6c:	mov    %r13d,0x44(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1771
		}
		if (likely(type == LAST_NORM)) {
			struct dentry *parent = nd->path.dentry;
    2f71:	je     3090 <link_path_walk+0x260>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1782
			}
		}

		nd->last = this;
		nd->last_type = type;

    2f77:	mov    0x8(%rbx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1783
		if (!name[len])
    2f7b:	andl   $0xffffefff,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1784
			return 0;
    2f82:	testb  $0x1,(%rdi)
    2f85:	jne    3173 <link_path_walk+0x343>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1763

		type = LAST_NORM;
		if (name[0] == '.') switch (len) {
			case 2:
				if (name[1] == '.') {
					type = LAST_DOTDOT;
    2f8b:	xor    %esi,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1791
		 * If it wasn't NUL, we know it was '/'. Skip that
		 * slash, and continue until no more slashes.
		 */
		do {
			len++;
		} while (unlikely(name[len] == '/'));
    2f8d:	mov    0x40(%rsp),%rax
    2f92:	mov    0x48(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1792
		if (!name[len])
    2f97:	mov    %esi,0x44(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1791
		 * If it wasn't NUL, we know it was '/'. Skip that
		 * slash, and continue until no more slashes.
		 */
		do {
			len++;
		} while (unlikely(name[len] == '/'));
    2f9a:	mov    %rax,0x10(%rbx)
    2f9e:	mov    %rdx,0x18(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1794
		if (!name[len])
			return 0;

    2fa2:	cmpb   $0x0,(%r12,%r13,1)
    2fa7:	je     30bd <link_path_walk+0x28d>
    2fad:	lea    0x1(%r12,%r13,1),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1802 (discriminator 1)
		err = walk_component(nd, &next, LOOKUP_FOLLOW);
		if (err < 0)
			return err;

		if (err) {
			err = nested_symlink(&next, nd);
    2fb2:	mov    %rax,%r12
    2fb5:	lea    0x1(%rax),%rax
    2fb9:	movzbl -0x1(%rax),%edx
    2fbd:	cmp    $0x2f,%dl
    2fc0:	je     2fb2 <link_path_walk+0x182>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1803
			if (err)
    2fc2:	test   %dl,%dl
    2fc4:	je     30bd <link_path_walk+0x28d>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1544

		err = lookup_slow(nd, path);
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
    2fca:	test   %esi,%esi
    2fcc:	jne    385d <link_path_walk+0xa2d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
	}
	err = -ENOENT;
    2fd2:	lea    0x20(%rsp),%rdx
    2fd7:	lea    0x30(%rsp),%rsi
    2fdc:	mov    %rbx,%rdi
    2fdf:	callq  19e0 <lookup_fast>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1547
	if (!inode)
    2fe4:	test   %eax,%eax
    2fe6:	jne    382f <link_path_walk+0x9ff>
    2fec:	mov    0x20(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1558
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
    2ff1:	test   %rdx,%rdx
    2ff4:	je     310c <link_path_walk+0x2dc>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1561
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
    2ffa:	mov    0x38(%rsp),%rsi
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    2fff:	mov    (%rsi),%eax
    3001:	and    $0x700000,%eax
should_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1531
	struct inode *inode;
	int err;
	/*
	 * "." and ".." are special - ".." especially so because it has
	 * to be able to know about the current root directory and
	 * parent relationships.
    3006:	cmp    $0x300000,%eax
    300b:	je     318f <link_path_walk+0x35f>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    3011:	testb  $0x40,0x38(%rbx)
    3015:	je     30e0 <link_path_walk+0x2b0>
    301b:	mov    0x30(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    3020:	mov    %rax,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    3023:	mov    %rsi,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1572
	terminate_walk(nd);
	return err;
}

/*
 * This limits recursive symlink follows to 8, while
    3027:	mov    %rdx,0x30(%rbx)
    302b:	nopl   0x0(%rax,%rax,1)
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:434
}

static inline bool d_is_directory(const struct dentry *dentry)
    3030:	mov    0x8(%rbx),%rax
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    3034:	mov    (%rax),%eax
    3036:	and    $0x700000,%eax
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1817
	return err;
}

static int path_init(int dfd, const char *name, unsigned int flags, struct nameidata *nd, struct file **fp)
{
	int retval = 0;
    303b:	cmp    $0x100000,%eax
    3040:	je     2e90 <link_path_walk+0x60>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1818

    3046:	mov    $0xffffffec,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1822
	nd->last_type = LAST_ROOT; /* if there are only slashes... */
	nd->flags = flags | LOOKUP_JUMPED;
	nd->depth = 0;
	if (flags & LOOKUP_ROOT) {
    304c:	mov    %rbx,%rdi
    304f:	callq  cc0 <terminate_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1824
		struct dentry *root = nd->root.dentry;
		struct inode *inode = root->d_inode;
    3054:	add    $0x60,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1823

	nd->last_type = LAST_ROOT; /* if there are only slashes... */
	nd->flags = flags | LOOKUP_JUMPED;
	nd->depth = 0;
	if (flags & LOOKUP_ROOT) {
		struct dentry *root = nd->root.dentry;
    3058:	mov    %r14d,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1824
		struct inode *inode = root->d_inode;
    305b:	pop    %rbx
    305c:	pop    %r12
    305e:	pop    %r13
    3060:	pop    %r14
    3062:	pop    %r15
    3064:	pop    %rbp
    3065:	retq   
may_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1493

static inline int handle_dots(struct nameidata *nd, int type)
{
	if (type == LAST_DOTDOT) {
		if (nd->flags & LOOKUP_RCU) {
			if (follow_dotdot_rcu(nd))
    3066:	xor    %esi,%esi
    3068:	mov    %rbx,%rdi
    306b:	callq  17c0 <unlazy_walk>
    3070:	test   %eax,%eax
    3072:	jne    304c <link_path_walk+0x21c>
    3074:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1496
				return -ECHILD;
		} else
			follow_dotdot(nd);
    3078:	mov    0x30(%rbx),%rdi
    307c:	mov    $0x1,%esi
    3081:	callq  3086 <link_path_walk+0x256>
    3086:	mov    %eax,%r14d
    3089:	jmpq   2eb4 <link_path_walk+0x84>
    308e:	xchg   %ax,%ax
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1771 (discriminator 1)
				break;
			case 1:
				type = LAST_DOT;
		}
		if (likely(type == LAST_NORM)) {
			struct dentry *parent = nd->path.dentry;
    3090:	cmp    $0x1,%r13
    3094:	je     30ce <link_path_walk+0x29e>
    3096:	cmp    $0x2,%r13
    309a:	jne    2f77 <link_path_walk+0x147>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1773
			nd->flags &= ~LOOKUP_JUMPED;
			if (unlikely(parent->d_flags & DCACHE_OP_HASH)) {
    30a0:	cmpb   $0x2e,0x1(%r12)
    30a6:	jne    2f77 <link_path_walk+0x147>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1775
				err = parent->d_op->d_hash(parent, &this);
				if (err < 0)
    30ac:	orl    $0x1000,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1774
		}
		if (likely(type == LAST_NORM)) {
			struct dentry *parent = nd->path.dentry;
			nd->flags &= ~LOOKUP_JUMPED;
			if (unlikely(parent->d_flags & DCACHE_OP_HASH)) {
				err = parent->d_op->d_hash(parent, &this);
    30b3:	mov    $0x3,%esi
    30b8:	jmpq   2f8d <link_path_walk+0x15d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1754
		int type;

		err = may_lookup(nd);
 		if (err)
			break;

    30bd:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1824
	nd->last_type = LAST_ROOT; /* if there are only slashes... */
	nd->flags = flags | LOOKUP_JUMPED;
	nd->depth = 0;
	if (flags & LOOKUP_ROOT) {
		struct dentry *root = nd->root.dentry;
		struct inode *inode = root->d_inode;
    30bf:	add    $0x60,%rsp
    30c3:	pop    %rbx
    30c4:	pop    %r12
    30c6:	pop    %r13
    30c8:	pop    %r14
    30ca:	pop    %r15
    30cc:	pop    %rbp
    30cd:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1779
				err = parent->d_op->d_hash(parent, &this);
				if (err < 0)
					break;
			}
		}

    30ce:	mov    $0x2,%esi
    30d3:	jmpq   2f8d <link_path_walk+0x15d>
    30d8:	nopl   0x0(%rax,%rax,1)
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    30e0:	mov    0x8(%rbx),%rdi
    30e4:	callq  30e9 <link_path_walk+0x2b9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    30e9:	mov    (%rbx),%rdi
    30ec:	cmp    0x30(%rsp),%rdi
    30f1:	je     3161 <link_path_walk+0x331>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    30f3:	callq  30f8 <link_path_walk+0x2c8>
    30f8:	mov    0x20(%rsp),%rdx
    30fd:	mov    0x30(%rsp),%rax
    3102:	mov    0x38(%rsp),%rsi
    3107:	jmpq   3020 <link_path_walk+0x1f0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    310c:	testb  $0x40,0x38(%rbx)
    3110:	je     3147 <link_path_walk+0x317>
    3112:	mov    0x30(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    3117:	mov    0x38(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
			mntput(nd->path.mnt);
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    311c:	mov    %rdi,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    311f:	mov    %rax,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1557
			if (unlikely(unlazy_walk(nd, path->dentry))) {
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
    3123:	mov    $0xfffffffe,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1578
 * limiting consecutive symlinks to 40.
 *
 * Without that kind of total limit, nasty chains of consecutive
 * symlinks can cause almost arbitrarily long lookups.
 */
static inline int nested_symlink(struct path *path, struct nameidata *nd)
    3128:	mov    %rbx,%rdi
    312b:	mov    %eax,0x18(%rsp)
    312f:	callq  cc0 <terminate_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1579
{
    3134:	mov    0x18(%rsp),%eax
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1824
	nd->last_type = LAST_ROOT; /* if there are only slashes... */
	nd->flags = flags | LOOKUP_JUMPED;
	nd->depth = 0;
	if (flags & LOOKUP_ROOT) {
		struct dentry *root = nd->root.dentry;
		struct inode *inode = root->d_inode;
    3138:	add    $0x60,%rsp
    313c:	pop    %rbx
    313d:	pop    %r12
    313f:	pop    %r13
    3141:	pop    %r14
    3143:	pop    %r15
    3145:	pop    %rbp
    3146:	retq   
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    3147:	mov    0x8(%rbx),%rdi
    314b:	callq  3150 <link_path_walk+0x320>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    3150:	mov    (%rbx),%rdi
    3153:	cmp    0x30(%rsp),%rdi
    3158:	je     3117 <link_path_walk+0x2e7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    315a:	callq  315f <link_path_walk+0x32f>
    315f:	jmp    3112 <link_path_walk+0x2e2>
    3161:	mov    0x20(%rsp),%rdx
    3166:	mov    0x38(%rsp),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
	nd->path.mnt = path->mnt;
    316b:	mov    %rdi,%rax
    316e:	jmpq   3020 <link_path_walk+0x1f0>
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1785
		nd->last = this;
		nd->last_type = type;

		if (!name[len])
			return 0;
		/*
    3173:	mov    0x60(%rdi),%rax
    3177:	lea    0x40(%rsp),%rsi
    317c:	callq  *0x10(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1786
		 * If it wasn't NUL, we know it was '/'. Skip that
    317f:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1785
		nd->last = this;
		nd->last_type = type;

		if (!name[len])
			return 0;
		/*
    3181:	mov    %eax,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1786
		 * If it wasn't NUL, we know it was '/'. Skip that
    3184:	jns    2f8b <link_path_walk+0x15b>
    318a:	jmpq   304c <link_path_walk+0x21c>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1562
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;
    318f:	testb  $0x40,0x38(%rbx)
    3193:	jne    356e <link_path_walk+0x73e>
    3199:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1568

out_path_put:
	path_to_nameidata(path, nd);
out_err:
	terminate_walk(nd);
	return err;
    31a0:	cmp    %rdx,0x30(%rsi)
    31a4:	jne    37dd <link_path_walk+0x9ad>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    31aa:	mov    %gs:0x0,%rdx
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1593

	nd->depth++;
	current->link_count++;

	do {
		struct path link = *path;
    31b3:	mov    $0x0,%rax
    31ba:	add    $0x4a8,%rdx
    31c1:	jmp    31d0 <link_path_walk+0x3a0>
    31c3:	nopl   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    31c8:	test   %cl,%cl
    31ca:	je     35b0 <link_path_walk+0x780>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    31d0:	add    $0x1,%rdx
    31d4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    31d8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    31dc:	cmp    -0x1(%rax),%cl
    31df:	je     31c8 <link_path_walk+0x398>
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1593
    31e1:	mov    %gs:0x0,%rax
    31ea:	cmpl   $0x7,0x4b8(%rax)
    31f1:	jg     387d <link_path_walk+0xa4d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1598
		void *cookie;

		res = follow_link(&link, nd, &cookie);
		if (res)
			break;
    31f7:	mov    0x48(%rbx),%eax
    31fa:	cmp    $0x7,%eax
    31fd:	ja     387b <link_path_walk+0xa4b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1600
		res = walk_component(nd, path, LOOKUP_FOLLOW);
		put_link(nd, &link, cookie);
    3203:	add    $0x1,%eax
    3206:	mov    %eax,0x48(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1601
	} while (res > 0);
    3209:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    3210:	mov    %gs:0x0,%rdx
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1601
    3219:	add    $0x4a8,%rdx
    3220:	jmp    3230 <link_path_walk+0x400>
    3222:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    3228:	test   %cl,%cl
    322a:	je     3590 <link_path_walk+0x760>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    3230:	add    $0x1,%rdx
    3234:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    3238:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    323c:	cmp    -0x1(%rax),%cl
    323f:	je     3228 <link_path_walk+0x3f8>
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1601
    3241:	mov    %gs:0x0,%rax
    324a:	addl   $0x1,0x4b8(%rax)
    3251:	jmpq   332b <link_path_walk+0x4fb>
    3256:	nopw   %cs:0x0(%rax,%rax,1)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:859
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;

	error = 0;
    3260:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}

    3263:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:887
out_put_nd_path:
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}
    3266:	xor    %r13d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888

    3269:	callq  326e <link_path_walk+0x43e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:889
static int follow_up_rcu(struct path *path)
    326e:	mov    %r14,%rdi
    3271:	callq  3276 <link_path_walk+0x446>
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1608
	current->link_count--;
	nd->depth--;
	return res;
}

/*
    3276:	test   %r15d,%r15d
    3279:	jne    3480 <link_path_walk+0x650>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1544

		err = lookup_slow(nd, path);
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
    327f:	mov    0x44(%rbx),%esi
    3282:	test   %esi,%esi
    3284:	jne    3791 <link_path_walk+0x961>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
	}
	err = -ENOENT;
    328a:	lea    0x28(%rsp),%rdx
    328f:	lea    0x30(%rsp),%rsi
    3294:	mov    %rbx,%rdi
    3297:	callq  19e0 <lookup_fast>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1547
	if (!inode)
    329c:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
    329e:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1547
	if (!inode)
    32a1:	jne    3760 <link_path_walk+0x930>
    32a7:	mov    0x28(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1558
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
    32ac:	test   %rdx,%rdx
    32af:	je     3540 <link_path_walk+0x710>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1561
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
    32b5:	mov    0x38(%rsp),%rsi
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    32ba:	mov    (%rsi),%eax
    32bc:	and    $0x700000,%eax
should_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1531
	struct inode *inode;
	int err;
	/*
	 * "." and ".." are special - ".." especially so because it has
	 * to be able to know about the current root directory and
	 * parent relationships.
    32c1:	cmp    $0x300000,%eax
    32c6:	je     37a3 <link_path_walk+0x973>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    32cc:	testb  $0x40,0x38(%rbx)
    32d0:	je     3500 <link_path_walk+0x6d0>
    32d6:	mov    0x30(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    32db:	mov    %rdi,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    32de:	mov    %rsi,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1573
	return err;
}

/*
 * This limits recursive symlink follows to 8, while
 * limiting consecutive symlinks to 40.
    32e2:	xor    %r15d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1572
	terminate_walk(nd);
	return err;
}

/*
 * This limits recursive symlink follows to 8, while
    32e5:	mov    %rdx,0x30(%rbx)
    32e9:	nopl   0x0(%rax)
put_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:705
static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
{
	struct inode *inode = link->dentry->d_inode;
	if (inode->i_op->put_link)
		inode->i_op->put_link(link->dentry, nd, cookie);
	path_put(link);
    32f0:	mov    0x58(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:706
}
    32f5:	mov    0x30(%rdi),%rdx
    32f9:	mov    0x20(%rdx),%rdx
    32fd:	mov    0x28(%rdx),%rcx
    3301:	test   %rcx,%rcx
    3304:	je     3313 <link_path_walk+0x4e3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:707

    3306:	mov    %r13,%rdx
    3309:	mov    %rbx,%rsi
    330c:	callq  *%rcx
    330e:	mov    0x58(%rsp),%rdi
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    3313:	callq  3318 <link_path_walk+0x4e8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    3318:	mov    0x50(%rsp),%rdi
    331d:	callq  3322 <link_path_walk+0x4f2>
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1612

/*
 * We can do the critical dentry name comparison and hashing
 * operations one word at a time, but we are limited to:
 *
 * - Architectures with fast unaligned word accesses. We could
    3322:	test   %r15d,%r15d
    3325:	jle    3480 <link_path_walk+0x650>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    332b:	testb  $0x40,0x38(%rbx)
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1604
		res = walk_component(nd, path, LOOKUP_FOLLOW);
		put_link(nd, &link, cookie);
	} while (res > 0);

	current->link_count--;
	nd->depth--;
    332f:	mov    0x30(%rsp),%rax
    3334:	mov    0x38(%rsp),%rdx
    3339:	mov    %rax,0x50(%rsp)
    333e:	mov    %rdx,0x58(%rsp)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:830
{
	struct dentry *dentry = link->dentry;
	int error;
	char *s;

	BUG_ON(nd->flags & LOOKUP_RCU);
    3343:	mov    0x58(%rsp),%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    3348:	jne    37a1 <link_path_walk+0x971>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:836
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
    334e:	mov    0x50(%rsp),%rdi
    3353:	cmp    (%rbx),%rdi
    3356:	je     3530 <link_path_walk+0x700>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    335c:	mov    0x18(%rsp),%rdi
    3361:	callq  1370 <my_strcmp_base.constprop.35>
    3366:	test   %eax,%eax
    3368:	jne    337a <link_path_walk+0x54a>
    336a:	cmpb   $0x0,0x0(%rip)        # 3371 <link_path_walk+0x541>
    3371:	mov    0x0(%rip),%rax        # 3378 <link_path_walk+0x548>
    3378:	jne    3383 <link_path_walk+0x553>
    337a:	mov    %gs:0x0,%rax
    3383:	cmpl   $0x27,0x4bc(%rax)
    338a:	jg     3750 <link_path_walk+0x920>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:843

	touch_atime(link);
	nd_set_link(nd, NULL);
    3390:	callq  3395 <link_path_walk+0x565>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

    3395:	mov    0x10(%rsp),%rdi
    339a:	callq  1370 <my_strcmp_base.constprop.35>
    339f:	test   %eax,%eax
    33a1:	jne    33b3 <link_path_walk+0x583>
    33a3:	cmpb   $0x0,0x0(%rip)        # 33aa <link_path_walk+0x57a>
    33aa:	mov    0x0(%rip),%rax        # 33b1 <link_path_walk+0x581>
    33b1:	jne    33bc <link_path_walk+0x58c>
    33b3:	mov    %gs:0x0,%rax
    33bc:	addl   $0x1,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:846
	// error = security_inode_follow_link(link->dentry, nd);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    33c3:	lea    0x50(%rsp),%r14
    33c8:	mov    %r14,%rdi
    33cb:	callq  33d0 <link_path_walk+0x5a0>
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88
    33d0:	mov    0x48(%rbx),%eax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    33d3:	mov    %gs:0x0,%rdi
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
    33dc:	add    $0x4a8,%rdi
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88
    33e3:	movq   $0x0,0x50(%rbx,%rax,8)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    33ec:	callq  1330 <my_strcmp.constprop.33>
    33f1:	test   %eax,%eax
    33f3:	jne    34e0 <link_path_walk+0x6b0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:857

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;
    33f9:	movl   $0x4,0x44(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858

    3400:	mov    0x30(%r13),%rax
    3404:	mov    %r13,%rdi
    3407:	mov    %rbx,%rsi
    340a:	mov    0x20(%rax),%rax
    340e:	callq  *0x8(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	error = 0;
	s = nd_get_link(nd);
    3411:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858
	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;

    3417:	mov    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	error = 0;
	s = nd_get_link(nd);
    341a:	ja     3260 <link_path_walk+0x430>
nd_get_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:93
}

static inline char *nd_get_link(struct nameidata *nd)
{
	return nd->saved_names[nd->depth];
    3420:	mov    0x48(%rbx),%eax
    3423:	mov    0x50(%rbx,%rax,8),%r15
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:865
	if (s) {
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
    3428:	test   %r15,%r15
    342b:	je     327f <link_path_walk+0x44f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:866
		}
    3431:	cmp    $0xfffffffffffff000,%r15
    3438:	ja     3814 <link_path_walk+0x9e4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:871
		if (*s == '/') {
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
    343e:	cmpb   $0x2f,(%r15)
    3442:	je     35f0 <link_path_walk+0x7c0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    3448:	mov    0x8(%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    344c:	mov    %r15,%rdi
    344f:	mov    %rbx,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    3452:	mov    0x30(%rax),%rax
    3456:	mov    %rax,0x30(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    345a:	callq  2e30 <link_path_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    345f:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}

    3461:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    3464:	je     327f <link_path_walk+0x44f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:881

    346a:	mov    %r13,%rdx
    346d:	mov    %r14,%rsi
    3470:	mov    %rbx,%rdi
    3473:	callq  220 <put_link>
    3478:	nopl   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    3480:	mov    %gs:0x0,%rcx
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1614
 * We can do the critical dentry name comparison and hashing
 * operations one word at a time, but we are limited to:
 *
 * - Architectures with fast unaligned word accesses. We could
 *   do a "get_unaligned()" if this helps and is sufficiently
 *   fast.
    3489:	mov    $0x0,%rdx
    3490:	add    $0x4a8,%rcx
    3497:	jmp    34a9 <link_path_walk+0x679>
    3499:	nopl   0x0(%rax)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    34a0:	test   %sil,%sil
    34a3:	je     35d0 <link_path_walk+0x7a0>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    34a9:	add    $0x1,%rcx
    34ad:	movzbl -0x1(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    34b1:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    34b5:	cmp    -0x1(%rdx),%sil
    34b9:	je     34a0 <link_path_walk+0x670>
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1614
    34bb:	mov    %gs:0x0,%rdx
    34c4:	subl   $0x1,0x4b8(%rdx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1615
 *
    34cb:	subl   $0x1,0x48(%rbx)
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1814
		}
	}
	terminate_walk(nd);
	return err;
}

    34cf:	test   %r15d,%r15d
    34d2:	je     3030 <link_path_walk+0x200>
    34d8:	mov    %r15d,%eax
    34db:	jmpq   30bf <link_path_walk+0x28f>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    34e0:	mov    0x58(%rsp),%rdi
    34e5:	mov    %rbx,%rsi
    34e8:	callq  34ed <link_path_walk+0x6bd>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    34ed:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    34ef:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    34f2:	jne    3263 <link_path_walk+0x433>
    34f8:	jmpq   33f9 <link_path_walk+0x5c9>
    34fd:	nopl   (%rax)
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    3500:	mov    0x8(%rbx),%rdi
    3504:	callq  3509 <link_path_walk+0x6d9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    3509:	mov    (%rbx),%rdi
    350c:	cmp    0x30(%rsp),%rdi
    3511:	je     3649 <link_path_walk+0x819>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    3517:	callq  351c <link_path_walk+0x6ec>
    351c:	mov    0x28(%rsp),%rdx
    3521:	mov    0x30(%rsp),%rdi
    3526:	mov    0x38(%rsp),%rsi
    352b:	jmpq   32db <link_path_walk+0x4ab>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:837
	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;
    3530:	callq  3535 <link_path_walk+0x705>
    3535:	jmpq   335c <link_path_walk+0x52c>
    353a:	nopw   0x0(%rax,%rax,1)
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    3540:	testb  $0x40,0x38(%rbx)
    3544:	je     3628 <link_path_walk+0x7f8>
    354a:	mov    0x30(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    354f:	mov    0x38(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
			mntput(nd->path.mnt);
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    3554:	mov    %rdi,(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1557
			if (unlikely(unlazy_walk(nd, path->dentry))) {
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
    3557:	mov    $0xfffffffe,%r15d
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    355d:	mov    %rax,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1578
 * limiting consecutive symlinks to 40.
 *
 * Without that kind of total limit, nasty chains of consecutive
 * symlinks can cause almost arbitrarily long lookups.
 */
static inline int nested_symlink(struct path *path, struct nameidata *nd)
    3561:	mov    %rbx,%rdi
    3564:	callq  cc0 <terminate_walk>
    3569:	jmpq   32f0 <link_path_walk+0x4c0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1563
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;

    356e:	mov    %rbx,%rdi
    3571:	callq  17c0 <unlazy_walk>
    3576:	test   %eax,%eax
    3578:	jne    38a5 <link_path_walk+0xa75>
    357e:	mov    0x38(%rsp),%rsi
    3583:	mov    0x20(%rsp),%rdx
    3588:	jmpq   31a0 <link_path_walk+0x370>
    358d:	nopl   (%rax)
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1601
		res = follow_link(&link, nd, &cookie);
		if (res)
			break;
		res = walk_component(nd, path, LOOKUP_FOLLOW);
		put_link(nd, &link, cookie);
	} while (res > 0);
    3590:	cmpb   $0x0,0x0(%rip)        # 3597 <link_path_walk+0x767>
    3597:	mov    0x0(%rip),%rax        # 359e <link_path_walk+0x76e>
    359e:	jne    324a <link_path_walk+0x41a>
    35a4:	jmpq   3241 <link_path_walk+0x411>
    35a9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1593

	nd->depth++;
	current->link_count++;

	do {
		struct path link = *path;
    35b0:	cmpb   $0x0,0x0(%rip)        # 35b7 <link_path_walk+0x787>
    35b7:	mov    0x0(%rip),%rax        # 35be <link_path_walk+0x78e>
    35be:	jne    31ea <link_path_walk+0x3ba>
    35c4:	jmpq   31e1 <link_path_walk+0x3b1>
    35c9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1614
 * We can do the critical dentry name comparison and hashing
 * operations one word at a time, but we are limited to:
 *
 * - Architectures with fast unaligned word accesses. We could
 *   do a "get_unaligned()" if this helps and is sufficiently
 *   fast.
    35d0:	cmpb   $0x0,0x0(%rip)        # 35d7 <link_path_walk+0x7a7>
    35d7:	mov    0x0(%rip),%rdx        # 35de <link_path_walk+0x7ae>
    35de:	jne    34c4 <link_path_walk+0x694>
    35e4:	jmpq   34bb <link_path_walk+0x68b>
    35e9:	nopl   0x0(%rax)
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    35f0:	cmpq   $0x0,0x20(%rbx)
    35f5:	je     3658 <link_path_walk+0x828>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:873
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
    35f7:	mov    %rbx,%rdi
    35fa:	callq  35ff <link_path_walk+0x7cf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
		nd->inode = nd->path.dentry->d_inode;
    35ff:	mov    0x20(%rbx),%rax
    3603:	mov    0x28(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    3607:	lea    0x20(%rbx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
		nd->inode = nd->path.dentry->d_inode;
    360b:	mov    %rax,(%rbx)
    360e:	mov    %rdx,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    3612:	callq  3617 <link_path_walk+0x7e7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:876
		if (unlikely(error))
    3617:	orl    $0x1000,0x38(%rbx)
    361e:	jmpq   3448 <link_path_walk+0x618>
    3623:	nopl   0x0(%rax,%rax,1)
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    3628:	mov    0x8(%rbx),%rdi
    362c:	callq  3631 <link_path_walk+0x801>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    3631:	mov    (%rbx),%rdi
    3634:	cmp    0x30(%rsp),%rdi
    3639:	je     354f <link_path_walk+0x71f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    363f:	callq  3644 <link_path_walk+0x814>
    3644:	jmpq   354a <link_path_walk+0x71a>
    3649:	mov    0x28(%rsp),%rdx
    364e:	mov    0x38(%rsp),%rsi
    3653:	jmpq   32db <link_path_walk+0x4ab>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    3658:	mov    %gs:0x0,%rdi
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652
static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}

    3661:	add    $0x4a8,%rdi
    3668:	callq  1370 <my_strcmp_base.constprop.35>
    366d:	test   %eax,%eax
    366f:	jne    3681 <link_path_walk+0x851>
    3671:	cmpb   $0x0,0x0(%rip)        # 3678 <link_path_walk+0x848>
    3678:	mov    0x0(%rip),%rax        # 367f <link_path_walk+0x84f>
    367f:	jne    368a <link_path_walk+0x85a>
    3681:	mov    %gs:0x0,%rax
    368a:	mov    0x588(%rax),%rax
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    3691:	lea    0x4(%rax),%rsi
    3695:	mov    %rax,(%rsp)
    3699:	mov    %rsi,%rdi
    369c:	mov    %rsi,0x8(%rsp)
    36a1:	callq  36a6 <link_path_walk+0x876>
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:29
    36a6:	mov    (%rsp),%rax
    36aa:	mov    0x18(%rax),%rdx
    36ae:	mov    0x20(%rax),%rax
    36b2:	mov    %rdx,%rdi
    36b5:	mov    %rdx,0x20(%rbx)
    36b9:	mov    %rax,0x28(%rbx)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    36bd:	callq  36c2 <link_path_walk+0x892>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    36c2:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    36cb:	mov    0x28(%rbx),%r8
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    36cf:	add    $0x4a8,%rdx
    36d6:	mov    $0x0,%rax
    36dd:	jmp    36e9 <link_path_walk+0x8b9>
    36df:	nop
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    36e0:	test   %sil,%sil
    36e3:	je     37e2 <link_path_walk+0x9b2>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    36e9:	add    $0x1,%rdx
    36ed:	movzbl -0x1(%rdx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    36f1:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    36f5:	cmp    -0x1(%rax),%sil
    36f9:	je     36e0 <link_path_walk+0x8b0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    36fb:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    3704:	mov    $0x0,%rax
    370b:	add    $0x4a8,%rdx
    3712:	jmp    3721 <link_path_walk+0x8f1>
    3714:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    3718:	test   %sil,%sil
    371b:	je     37e2 <link_path_walk+0x9b2>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    3721:	add    $0x1,%rdx
    3725:	movzbl -0x1(%rdx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    3729:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    372d:	cmp    -0x1(%rax),%sil
    3731:	je     3718 <link_path_walk+0x8e8>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    3733:	test   %r8,%r8
    3736:	je     3741 <link_path_walk+0x911>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    3738:	lea    0x58(%r8),%rdi
    373c:	callq  3741 <link_path_walk+0x911>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    3741:	mov    0x8(%rsp),%rdi
    3746:	callq  374b <link_path_walk+0x91b>
    374b:	jmpq   35f7 <link_path_walk+0x7c7>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:839

	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
    3750:	mov    $0xffffffd8,%r15d
    3756:	lea    0x50(%rsp),%r14
    375b:	jmpq   3263 <link_path_walk+0x433>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1548

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
	if (!inode)
		goto out_path_put;
    3760:	js     3561 <link_path_walk+0x731>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1551

	if (should_follow_link(path->dentry, follow)) {
		if (nd->flags & LOOKUP_RCU) {
    3766:	lea    0x30(%rsp),%rsi
    376b:	mov    %rbx,%rdi
    376e:	callq  3773 <link_path_walk+0x943>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1552
			if (unlikely(unlazy_walk(nd, path->dentry))) {
    3773:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1551
	err = -ENOENT;
	if (!inode)
		goto out_path_put;

	if (should_follow_link(path->dentry, follow)) {
		if (nd->flags & LOOKUP_RCU) {
    3775:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1552
			if (unlikely(unlazy_walk(nd, path->dentry))) {
    3778:	js     3561 <link_path_walk+0x731>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1555
				err = -ECHILD;
				goto out_err;
			}
    377e:	mov    0x38(%rsp),%rax
    3783:	mov    0x30(%rax),%rdx
    3787:	mov    %rdx,0x28(%rsp)
    378c:	jmpq   32ac <link_path_walk+0x47c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1545
		err = lookup_slow(nd, path);
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
    3791:	mov    %rbx,%rdi
    3794:	callq  1ca0 <handle_dots>
    3799:	mov    %eax,%r15d
    379c:	jmpq   32f0 <link_path_walk+0x4c0>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    37a1:	ud2    
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1562
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;
    37a3:	testb  $0x40,0x38(%rbx)
    37a7:	jne    37c1 <link_path_walk+0x991>
    37a9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1568

out_path_put:
	path_to_nameidata(path, nd);
out_err:
	terminate_walk(nd);
	return err;
    37b0:	cmp    0x30(%rsi),%rdx
    37b4:	jne    37dd <link_path_walk+0x9ad>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1569
}
    37b6:	mov    $0x1,%r15d
    37bc:	jmpq   32f0 <link_path_walk+0x4c0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1563
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;

    37c1:	mov    %rbx,%rdi
    37c4:	callq  17c0 <unlazy_walk>
    37c9:	test   %eax,%eax
    37cb:	jne    38af <link_path_walk+0xa7f>
    37d1:	mov    0x38(%rsp),%rsi
    37d6:	mov    0x28(%rsp),%rdx
    37db:	jmp    37b0 <link_path_walk+0x980>
    37dd:	callq  37e2 <link_path_walk+0x9b2>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    37e2:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    37eb:	mov    $0x0,%rsi
    37f2:	add    $0x4a8,%rdx
    37f9:	mov    $0x0,%rdi
    3800:	xor    %eax,%eax
    3802:	mov    %r8,(%rsp)
    3806:	callq  380b <link_path_walk+0x9db>
    380b:	mov    (%rsp),%r8
    380f:	jmpq   3733 <link_path_walk+0x903>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:867
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
		}
		if (*s == '/') {
    3814:	mov    %rbx,%rdi
    3817:	callq  381c <link_path_walk+0x9ec>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:868
			set_root(nd);
    381c:	mov    %r13,%rdx
    381f:	mov    %r14,%rsi
    3822:	mov    %rbx,%rdi
    3825:	callq  220 <put_link>
    382a:	jmpq   3276 <link_path_walk+0x446>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1548

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
	if (!inode)
		goto out_path_put;
    382f:	js     3128 <link_path_walk+0x2f8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1551

	if (should_follow_link(path->dentry, follow)) {
		if (nd->flags & LOOKUP_RCU) {
    3835:	lea    0x30(%rsp),%rsi
    383a:	mov    %rbx,%rdi
    383d:	callq  3842 <link_path_walk+0xa12>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1552
			if (unlikely(unlazy_walk(nd, path->dentry))) {
    3842:	test   %eax,%eax
    3844:	js     3128 <link_path_walk+0x2f8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1555
				err = -ECHILD;
				goto out_err;
			}
    384a:	mov    0x38(%rsp),%rax
    384f:	mov    0x30(%rax),%rdx
    3853:	mov    %rdx,0x20(%rsp)
    3858:	jmpq   2ff1 <link_path_walk+0x1c1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1545
		err = lookup_slow(nd, path);
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
    385d:	mov    %rbx,%rdi
    3860:	callq  1ca0 <handle_dots>
link_path_walk():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1809
				return err;
		}
		if (!d_is_directory(nd->path.dentry)) {
			err = -ENOTDIR; 
			break;
		}
    3865:	test   %eax,%eax
    3867:	js     30bf <link_path_walk+0x28f>
    386d:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1812
	}
	terminate_walk(nd);
	return err;
    3870:	je     3030 <link_path_walk+0x200>
    3876:	jmpq   31aa <link_path_walk+0x37a>
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1598
		struct path link = *path;
		void *cookie;

		res = follow_link(&link, nd, &cookie);
		if (res)
			break;
    387b:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1594
	nd->depth++;
	current->link_count++;

	do {
		struct path link = *path;
		void *cookie;
    387d:	lea    0x30(%rsp),%rdi
    3882:	mov    %rbx,%rsi
    3885:	callq  d10 <path_put_conditional.isra.13>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    388a:	mov    0x8(%rbx),%rdi
    388e:	callq  3893 <link_path_walk+0xa63>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    3893:	mov    (%rbx),%rdi
    3896:	callq  389b <link_path_walk+0xa6b>
nested_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1596

	do {
		struct path link = *path;
		void *cookie;

		res = follow_link(&link, nd, &cookie);
    389b:	mov    $0xffffffd8,%eax
    38a0:	jmpq   30bf <link_path_walk+0x28f>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1564
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;

out_path_put:
    38a5:	mov    $0xfffffff6,%eax
    38aa:	jmpq   3128 <link_path_walk+0x2f8>
nested_symlink():
    38af:	mov    $0xfffffff6,%r15d
    38b5:	jmpq   3561 <link_path_walk+0x731>
link_path_walk():
    38ba:	nopw   0x0(%rax,%rax,1)

00000000000038c0 <path_lookupat>:
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1928
	 * Documentation/filesystems/path-lookup.txt). These share much of the
	 * path walk code, but some things particularly setup, cleanup, and
	 * following mounts are sufficiently divergent that functions are
	 * duplicated. Typically there is a function foo(), and its RCU
	 * analogue, foo_rcu().
	 *
    38c0:	callq  38c5 <path_lookupat+0x5>
    38c5:	push   %rbp
    38c6:	mov    %rsp,%rbp
    38c9:	push   %r15
    38cb:	push   %r14
    38cd:	push   %r13
    38cf:	mov    %rsi,%r13
    38d2:	push   %r12
    38d4:	mov    %edx,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1947
	if (!err && !(flags & LOOKUP_PARENT)) {
		err = lookup_last(nd, &path);
		while (err > 0) {
			void *cookie;
			struct path link = path;
			err = may_follow_link(&link, nd);
    38d7:	or     $0x10,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1928
	 * Documentation/filesystems/path-lookup.txt). These share much of the
	 * path walk code, but some things particularly setup, cleanup, and
	 * following mounts are sufficiently divergent that functions are
	 * duplicated. Typically there is a function foo(), and its RCU
	 * analogue, foo_rcu().
	 *
    38da:	push   %rbx
    38db:	mov    %rcx,%rbx
    38de:	sub    $0x50,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1947
	if (!err && !(flags & LOOKUP_PARENT)) {
		err = lookup_last(nd, &path);
		while (err > 0) {
			void *cookie;
			struct path link = path;
			err = may_follow_link(&link, nd);
    38e2:	lea    0x18(%rsp),%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1929
	 * path walk code, but some things particularly setup, cleanup, and
	 * following mounts are sufficiently divergent that functions are
	 * duplicated. Typically there is a function foo(), and its RCU
	 * analogue, foo_rcu().
	 *
	 * -ECHILD is the error number of choice (just to avoid clashes) that
    38e7:	movq   $0x0,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1947
	if (!err && !(flags & LOOKUP_PARENT)) {
		err = lookup_last(nd, &path);
		while (err > 0) {
			void *cookie;
			struct path link = path;
			err = may_follow_link(&link, nd);
    38f0:	callq  25f0 <path_init>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1949
			if (unlikely(err))
				break;
    38f5:	test   %eax,%eax
    38f7:	jne    39c7 <path_lookupat+0x107>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    38fd:	mov    %gs:0x0,%rcx
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1952
			nd->flags |= LOOKUP_PARENT;
			err = follow_link(&link, nd, &cookie);
			if (err)
    3906:	mov    $0x0,%rax
    390d:	add    $0x4a8,%rcx
    3914:	jmp    3929 <path_lookupat+0x69>
    3916:	nopw   %cs:0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    3920:	test   %r8b,%r8b
    3923:	je     3a18 <path_lookupat+0x158>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    3929:	add    $0x1,%rcx
    392d:	movzbl -0x1(%rcx),%r8d
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    3932:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    3936:	cmp    -0x1(%rax),%r8b
    393a:	je     3920 <path_lookupat+0x60>
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1952
    393c:	mov    %gs:0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1953 (discriminator 3)
				break;
    3945:	mov    %r13,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1952 (discriminator 3)
			err = may_follow_link(&link, nd);
			if (unlikely(err))
				break;
			nd->flags |= LOOKUP_PARENT;
			err = follow_link(&link, nd, &cookie);
			if (err)
    3948:	movl   $0x0,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1953 (discriminator 3)
				break;
    3952:	mov    %rbx,%rsi
    3955:	callq  2e30 <link_path_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1955 (discriminator 3)
			err = lookup_last(nd, &path);
			put_link(nd, &link, cookie);
    395a:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1953 (discriminator 3)
			if (unlikely(err))
				break;
			nd->flags |= LOOKUP_PARENT;
			err = follow_link(&link, nd, &cookie);
			if (err)
				break;
    395c:	mov    %eax,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1955 (discriminator 3)
			err = lookup_last(nd, &path);
			put_link(nd, &link, cookie);
    395f:	jne    39a8 <path_lookupat+0xe8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1955 (discriminator 1)
    3961:	and    $0x10,%r12d
    3965:	je     3a31 <path_lookupat+0x171>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1973

	if (base)
		fput(base);

	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {
		path_put(&nd->root);
    396b:	mov    %rbx,%rdi
    396e:	callq  410 <complete_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1975
		nd->root.mnt = NULL;
	}
    3973:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1973

	if (base)
		fput(base);

	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {
		path_put(&nd->root);
    3975:	mov    %eax,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1975
		nd->root.mnt = NULL;
	}
    3978:	jne    39a8 <path_lookupat+0xe8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1975 (discriminator 1)
    397a:	testb  $0x2,0x38(%rbx)
    397e:	je     39a8 <path_lookupat+0xe8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1976
	return err;
    3980:	mov    0x8(%rbx),%rdi
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    3984:	mov    (%rdi),%eax
    3986:	and    $0x700000,%eax
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1976
    398b:	cmp    $0x100000,%eax
    3990:	je     39a8 <path_lookupat+0xe8>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    3992:	callq  3997 <path_lookupat+0xd7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    3997:	mov    (%rbx),%rdi
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1978
		path_put(&nd->root);
		nd->root.mnt = NULL;
	}
	return err;
}

    399a:	mov    $0xffffffec,%r13d
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
EXPORT_SYMBOL(path_put);
    39a0:	callq  39a5 <path_lookupat+0xe5>
    39a5:	nopl   (%rax)
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1982
}

static int filename_lookup(int dfd, struct filename *name, unsigned int flags, struct nameidata *nd)
{
	int retval = path_lookupat(dfd, name->name, flags | LOOKUP_RCU, nd);
	if (unlikely(retval == -ECHILD))
    39a8:	mov    0x18(%rsp),%rdi
    39ad:	test   %rdi,%rdi
    39b0:	je     39b7 <path_lookupat+0xf7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1983
		retval = path_lookupat(dfd, name->name, flags, nd);
    39b2:	callq  39b7 <path_lookupat+0xf7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1985
	if (unlikely(retval == -ESTALE))
		retval = path_lookupat(dfd, name->name,
    39b7:	cmpq   $0x0,0x20(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1989
						flags | LOOKUP_REVAL, nd);

	if (likely(!retval))
		audit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);
    39bc:	mov    %r13d,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1985
{
	int retval = path_lookupat(dfd, name->name, flags | LOOKUP_RCU, nd);
	if (unlikely(retval == -ECHILD))
		retval = path_lookupat(dfd, name->name, flags, nd);
	if (unlikely(retval == -ESTALE))
		retval = path_lookupat(dfd, name->name,
    39bf:	je     39c7 <path_lookupat+0x107>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1985 (discriminator 1)
    39c1:	testb  $0x20,0x39(%rbx)
    39c5:	je     39e0 <path_lookupat+0x120>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1990
						flags | LOOKUP_REVAL, nd);

	if (likely(!retval))
		audit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);
	return retval;
    39c7:	add    $0x50,%rsp
    39cb:	pop    %rbx
    39cc:	pop    %r12
    39ce:	pop    %r13
    39d0:	pop    %r14
    39d2:	pop    %r15
    39d4:	pop    %rbp
    39d5:	retq   
    39d6:	nopw   %cs:0x0(%rax,%rax,1)
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    39e0:	mov    0x28(%rbx),%rdi
    39e4:	mov    %r13d,0x10(%rsp)
    39e9:	callq  39ee <path_lookupat+0x12e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    39ee:	mov    0x20(%rbx),%rdi
    39f2:	callq  39f7 <path_lookupat+0x137>
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1987
	if (unlikely(retval == -ECHILD))
		retval = path_lookupat(dfd, name->name, flags, nd);
	if (unlikely(retval == -ESTALE))
		retval = path_lookupat(dfd, name->name,
						flags | LOOKUP_REVAL, nd);

    39f7:	movq   $0x0,0x20(%rbx)
    39ff:	mov    0x10(%rsp),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1990
	if (likely(!retval))
		audit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);
	return retval;
    3a03:	add    $0x50,%rsp
    3a07:	pop    %rbx
    3a08:	pop    %r12
    3a0a:	pop    %r13
    3a0c:	pop    %r14
    3a0e:	pop    %r15
    3a10:	pop    %rbp
    3a11:	retq   
    3a12:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1952
			err = may_follow_link(&link, nd);
			if (unlikely(err))
				break;
			nd->flags |= LOOKUP_PARENT;
			err = follow_link(&link, nd, &cookie);
			if (err)
    3a18:	cmpb   $0x0,0x0(%rip)        # 3a1f <path_lookupat+0x15f>
    3a1f:	mov    0x0(%rip),%rax        # 3a26 <path_lookupat+0x166>
    3a26:	jne    3945 <path_lookupat+0x85>
    3a2c:	jmpq   393c <path_lookupat+0x7c>
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1918
/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
	struct file *base = NULL;
	struct path path;
	int err;
    3a31:	mov    0x44(%rbx),%esi
    3a34:	test   %esi,%esi
    3a36:	jne    3ab2 <path_lookupat+0x1f2>
    3a38:	mov    0x14(%rbx),%eax
    3a3b:	mov    0x18(%rbx),%rdx
    3a3f:	cmpb   $0x0,(%rdx,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1919

    3a43:	mov    0x38(%rbx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1918
/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
	struct file *base = NULL;
	struct path path;
	int err;
    3a46:	je     3a4b <path_lookupat+0x18b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1919

    3a48:	or     $0x3,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1921
	/*
	 * Path walking is largely split up into 2 different synchronisation
    3a4b:	and    $0xffffffef,%eax
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
    3a4e:	lea    0x20(%rsp),%rdx
    3a53:	lea    0x30(%rsp),%rsi
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1921
	struct file *base = NULL;
	struct path path;
	int err;

	/*
	 * Path walking is largely split up into 2 different synchronisation
    3a58:	mov    %eax,0x38(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
    3a5b:	mov    %rbx,%rdi
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1921
	struct file *base = NULL;
	struct path path;
	int err;

	/*
	 * Path walking is largely split up into 2 different synchronisation
    3a5e:	mov    %eax,%r12d
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
    3a61:	callq  19e0 <lookup_fast>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1547
	if (!inode)
    3a66:	test   %eax,%eax
    3a68:	jne    41c1 <path_lookupat+0x901>
    3a6e:	mov    0x20(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1558
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
    3a73:	test   %rdx,%rdx
    3a76:	je     3f59 <path_lookupat+0x699>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1561
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
    3a7c:	mov    0x38(%rsp),%rsi
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    3a81:	mov    (%rsi),%eax
    3a83:	and    $0x700000,%eax
should_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1531
	struct inode *inode;
	int err;
	/*
	 * "." and ".." are special - ".." especially so because it has
	 * to be able to know about the current root directory and
	 * parent relationships.
    3a88:	cmp    $0x300000,%eax
    3a8d:	je     4187 <path_lookupat+0x8c7>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    3a93:	testb  $0x40,0x38(%rbx)
    3a97:	je     3f29 <path_lookupat+0x669>
    3a9d:	mov    0x30(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    3aa2:	mov    %rax,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    3aa5:	mov    %rsi,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1572
	terminate_walk(nd);
	return err;
}

/*
 * This limits recursive symlink follows to 8, while
    3aa9:	mov    %rdx,0x30(%rbx)
    3aad:	jmpq   396b <path_lookupat+0xab>
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1921
	struct file *base = NULL;
	struct path path;
	int err;

	/*
	 * Path walking is largely split up into 2 different synchronisation
    3ab2:	andl   $0xffffffef,0x38(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1545
		err = lookup_slow(nd, path);
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
    3ab6:	mov    %rbx,%rdi
    3ab9:	callq  1ca0 <handle_dots>
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1957
			if (err)
				break;
			err = lookup_last(nd, &path);
			put_link(nd, &link, cookie);
		}
	}
    3abe:	test   %eax,%eax
    3ac0:	jle    4142 <path_lookupat+0x882>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    3ac6:	mov    %gs:0x0,%r14
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    3acf:	add    $0x4a8,%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

	touch_atime(link);
	nd_set_link(nd, NULL);

    3ad6:	mov    %r14,0x10(%rsp)
    3adb:	nopl   0x0(%rax,%rax,1)
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1959
			err = lookup_last(nd, &path);
			put_link(nd, &link, cookie);
		}
	}

	if (!err)
    3ae0:	mov    0x30(%rsp),%rax
    3ae5:	mov    0x38(%rsp),%rdx
    3aea:	mov    %rax,0x40(%rsp)
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:735
	const struct inode *parent;

	if (!sysctl_protected_symlinks)
		return 0;

	/* Allowed if owner and follower match. */
    3aef:	mov    0x0(%rip),%eax        # 3af5 <path_lookupat+0x235>
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1959
			err = lookup_last(nd, &path);
			put_link(nd, &link, cookie);
		}
	}

	if (!err)
    3af5:	mov    %rdx,0x48(%rsp)
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:735
	const struct inode *parent;

	if (!sysctl_protected_symlinks)
		return 0;

	/* Allowed if owner and follower match. */
    3afa:	test   %eax,%eax
    3afc:	je     3d50 <path_lookupat+0x490>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:739
	inode = link->dentry->d_inode;
	if (uid_eq(current_cred()->fsuid, inode->i_uid))
		return 0;

    3b02:	mov    0x48(%rsp),%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
	/* Allowed if parent directory not sticky and world-writable. */
    3b07:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    3b0e:	mov    %gs:0x0,%rdx
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
    3b17:	add    $0x4a8,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:739

	/* Allowed if owner and follower match. */
	inode = link->dentry->d_inode;
	if (uid_eq(current_cred()->fsuid, inode->i_uid))
		return 0;

    3b1e:	mov    0x30(%r12),%rsi
    3b23:	jmp    3b30 <path_lookupat+0x270>
    3b25:	nopl   (%rax)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    3b28:	test   %cl,%cl
    3b2a:	je     3d78 <path_lookupat+0x4b8>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    3b30:	add    $0x1,%rdx
    3b34:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    3b38:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    3b3c:	cmp    -0x1(%rax),%cl
    3b3f:	je     3b28 <path_lookupat+0x268>
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
	/* Allowed if parent directory not sticky and world-writable. */
    3b41:	mov    %gs:0x0,%rax
    3b4a:	mov    0x4a0(%rax),%rax
    3b51:	mov    0x4(%rsi),%edx
    3b54:	cmp    %edx,0x1c(%rax)
    3b57:	je     3b72 <path_lookupat+0x2b2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:744
	parent = nd->path.dentry->d_inode;
	if ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
		return 0;

    3b59:	mov    0x8(%rbx),%rax
    3b5d:	mov    0x30(%rax),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:745
	/* Allowed if parent directory and link owner match. */
    3b61:	movzwl (%rcx),%eax
    3b64:	and    $0x202,%ax
    3b68:	cmp    $0x202,%ax
    3b6c:	je     3db8 <path_lookupat+0x4f8>
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1963

	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY) {
		if (!d_is_directory(nd->path.dentry)) {
    3b72:	mov    0x38(%rbx),%eax
    3b75:	mov    %eax,%edx
    3b77:	or     $0x10,%edx
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    3b7a:	test   $0x40,%al
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1963

	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY) {
		if (!d_is_directory(nd->path.dentry)) {
    3b7c:	mov    %edx,0x38(%rbx)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    3b7f:	jne    4130 <path_lookupat+0x870>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:836
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
    3b85:	mov    0x40(%rsp),%rdi
    3b8a:	cmp    (%rbx),%rdi
    3b8d:	je     3e90 <path_lookupat+0x5d0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    3b93:	mov    %r14,%rdi
    3b96:	callq  1370 <my_strcmp_base.constprop.35>
    3b9b:	test   %eax,%eax
    3b9d:	jne    3baf <path_lookupat+0x2ef>
    3b9f:	cmpb   $0x0,0x0(%rip)        # 3ba6 <path_lookupat+0x2e6>
    3ba6:	mov    0x0(%rip),%rax        # 3bad <path_lookupat+0x2ed>
    3bad:	jne    3bb8 <path_lookupat+0x2f8>
    3baf:	mov    %gs:0x0,%rax
    3bb8:	cmpl   $0x27,0x4bc(%rax)
    3bbf:	jg     4132 <path_lookupat+0x872>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:843

	touch_atime(link);
	nd_set_link(nd, NULL);
    3bc5:	callq  3bca <path_lookupat+0x30a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

    3bca:	mov    0x10(%rsp),%rdi
    3bcf:	callq  1370 <my_strcmp_base.constprop.35>
    3bd4:	test   %eax,%eax
    3bd6:	jne    3be8 <path_lookupat+0x328>
    3bd8:	cmpb   $0x0,0x0(%rip)        # 3bdf <path_lookupat+0x31f>
    3bdf:	mov    0x0(%rip),%rax        # 3be6 <path_lookupat+0x326>
    3be6:	jne    3bf1 <path_lookupat+0x331>
    3be8:	mov    %gs:0x0,%rax
    3bf1:	addl   $0x1,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:846
	// error = security_inode_follow_link(link->dentry, nd);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    3bf8:	lea    0x40(%rsp),%r13
    3bfd:	mov    %r13,%rdi
    3c00:	callq  3c05 <path_lookupat+0x345>
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88

extern void nd_jump_link(struct nameidata *nd, struct path *path);

static inline void nd_set_link(struct nameidata *nd, char *path)
{
	nd->saved_names[nd->depth] = path;
    3c05:	mov    0x48(%rbx),%eax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    3c08:	mov    %gs:0x0,%rdi
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
    3c11:	add    $0x4a8,%rdi
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88
    3c18:	movq   $0x0,0x50(%rbx,%rax,8)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    3c21:	callq  1330 <my_strcmp.constprop.33>
    3c26:	test   %eax,%eax
    3c28:	jne    3d98 <path_lookupat+0x4d8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:857

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;
    3c2e:	movl   $0x4,0x44(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858

    3c35:	mov    0x30(%r12),%rax
    3c3a:	mov    %r12,%rdi
    3c3d:	mov    %rbx,%rsi
    3c40:	mov    0x20(%rax),%rax
    3c44:	callq  *0x8(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	error = 0;
	s = nd_get_link(nd);
    3c47:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858
	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;

    3c4d:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	error = 0;
	s = nd_get_link(nd);
    3c50:	jbe    3e00 <path_lookupat+0x540>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:859
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;

	error = 0;
    3c56:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}

    3c59:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:887
out_put_nd_path:
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}
    3c5c:	xor    %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888

    3c5f:	callq  3c64 <path_lookupat+0x3a4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:889
static int follow_up_rcu(struct path *path)
    3c64:	mov    %r13,%rdi
    3c67:	callq  3c6c <path_lookupat+0x3ac>
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1965
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY) {
		if (!d_is_directory(nd->path.dentry)) {
			path_put(&nd->path);
			err = -ENOTDIR;
    3c6c:	test   %r15d,%r15d
    3c6f:	jne    3d3b <path_lookupat+0x47b>
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1918
/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
	struct file *base = NULL;
	struct path path;
	int err;
    3c75:	mov    0x44(%rbx),%esi
    3c78:	test   %esi,%esi
    3c7a:	jne    3d60 <path_lookupat+0x4a0>
    3c80:	mov    0x14(%rbx),%eax
    3c83:	mov    0x18(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1919

    3c87:	mov    0x38(%rbx),%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1918
/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
static int path_lookupat(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
	struct file *base = NULL;
	struct path path;
	int err;
    3c8b:	cmpb   $0x0,(%rdx,%rax,1)
    3c8f:	je     3c95 <path_lookupat+0x3d5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1919

    3c91:	or     $0x3,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1921
	/*
	 * Path walking is largely split up into 2 different synchronisation
    3c95:	and    $0xffffffef,%r13d
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
    3c99:	lea    0x28(%rsp),%rdx
    3c9e:	lea    0x30(%rsp),%rsi
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1921
	struct file *base = NULL;
	struct path path;
	int err;

	/*
	 * Path walking is largely split up into 2 different synchronisation
    3ca3:	mov    %r13d,0x38(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
    3ca7:	mov    %rbx,%rdi
    3caa:	callq  19e0 <lookup_fast>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1547
	if (!inode)
    3caf:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1546
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
    3cb1:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1547
	if (!inode)
    3cb4:	jne    40f8 <path_lookupat+0x838>
    3cba:	mov    0x28(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1558
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
    3cbf:	test   %rdx,%rdx
    3cc2:	je     3e9a <path_lookupat+0x5da>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1561
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
    3cc8:	mov    0x38(%rsp),%rsi
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    3ccd:	mov    (%rsi),%eax
    3ccf:	and    $0x700000,%eax
should_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1531
	struct inode *inode;
	int err;
	/*
	 * "." and ".." are special - ".." especially so because it has
	 * to be able to know about the current root directory and
	 * parent relationships.
    3cd4:	cmp    $0x300000,%eax
    3cd9:	je     40b3 <path_lookupat+0x7f3>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    3cdf:	testb  $0x40,0x38(%rbx)
    3ce3:	je     3e60 <path_lookupat+0x5a0>
    3ce9:	mov    0x30(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    3cee:	mov    %rax,(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    3cf1:	mov    %rsi,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1573
	return err;
}

/*
 * This limits recursive symlink follows to 8, while
 * limiting consecutive symlinks to 40.
    3cf5:	xor    %r15d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1572
	terminate_walk(nd);
	return err;
}

/*
 * This limits recursive symlink follows to 8, while
    3cf8:	mov    %rdx,0x30(%rbx)
    3cfc:	nopl   0x0(%rax)
put_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:705
static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
{
	struct inode *inode = link->dentry->d_inode;
	if (inode->i_op->put_link)
		inode->i_op->put_link(link->dentry, nd, cookie);
	path_put(link);
    3d00:	mov    0x48(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:706
}
    3d05:	mov    0x30(%rdi),%rdx
    3d09:	mov    0x20(%rdx),%rdx
    3d0d:	mov    0x28(%rdx),%rcx
    3d11:	test   %rcx,%rcx
    3d14:	je     3d23 <path_lookupat+0x463>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:707

    3d16:	mov    %r12,%rdx
    3d19:	mov    %rbx,%rsi
    3d1c:	callq  *%rcx
    3d1e:	mov    0x48(%rsp),%rdi
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    3d23:	callq  3d28 <path_lookupat+0x468>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    3d28:	mov    0x40(%rsp),%rdi
    3d2d:	callq  3d32 <path_lookupat+0x472>
path_lookupat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1957
			if (err)
				break;
			err = lookup_last(nd, &path);
			put_link(nd, &link, cookie);
		}
	}
    3d32:	test   %r15d,%r15d
    3d35:	jg     3ae0 <path_lookupat+0x220>
    3d3b:	mov    %r15d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1972
	}

	if (base)
		fput(base);

	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {
    3d3e:	test   %r13d,%r13d
    3d41:	jne    39a8 <path_lookupat+0xe8>
    3d47:	jmpq   396b <path_lookupat+0xab>
    3d4c:	nopl   0x0(%rax)
    3d50:	mov    0x48(%rsp),%r12
    3d55:	jmpq   3b72 <path_lookupat+0x2b2>
    3d5a:	nopw   0x0(%rax,%rax,1)
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1921
	struct file *base = NULL;
	struct path path;
	int err;

	/*
	 * Path walking is largely split up into 2 different synchronisation
    3d60:	andl   $0xffffffef,0x38(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1545
		err = lookup_slow(nd, path);
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
    3d64:	mov    %rbx,%rdi
    3d67:	callq  1ca0 <handle_dots>
    3d6c:	mov    %eax,%r15d
    3d6f:	jmp    3d00 <path_lookupat+0x440>
    3d71:	nopl   0x0(%rax)
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
	/* Allowed if owner and follower match. */
	inode = link->dentry->d_inode;
	if (uid_eq(current_cred()->fsuid, inode->i_uid))
		return 0;

	/* Allowed if parent directory not sticky and world-writable. */
    3d78:	cmpb   $0x0,0x0(%rip)        # 3d7f <path_lookupat+0x4bf>
    3d7f:	mov    0x0(%rip),%rax        # 3d86 <path_lookupat+0x4c6>
    3d86:	jne    3b4a <path_lookupat+0x28a>
    3d8c:	jmpq   3b41 <path_lookupat+0x281>
    3d91:	nopl   0x0(%rax)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    3d98:	mov    0x48(%rsp),%rdi
    3d9d:	mov    %rbx,%rsi
    3da0:	callq  3da5 <path_lookupat+0x4e5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    3da5:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    3da7:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    3daa:	jne    3c59 <path_lookupat+0x399>
    3db0:	jmpq   3c2e <path_lookupat+0x36e>
    3db5:	nopl   (%rax)
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:749

	/* Allowed if parent directory and link owner match. */
	if (uid_eq(parent->i_uid, inode->i_uid))
		return 0;

	audit_log_link_denied("follow_link", link);
    3db8:	cmp    0x4(%rcx),%edx
    3dbb:	je     3b72 <path_lookupat+0x2b2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:752
	path_put_conditional(link, nd);
	path_put(&nd->path);
	return -EACCES;
    3dc1:	lea    0x40(%rsp),%rsi
    3dc6:	mov    $0x0,%rdi
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
EXPORT_SYMBOL(path_put);
    3dcd:	mov    $0xfffffff3,%r15d
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:752
		return 0;

	audit_log_link_denied("follow_link", link);
	path_put_conditional(link, nd);
	path_put(&nd->path);
	return -EACCES;
    3dd3:	callq  3dd8 <path_lookupat+0x518>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:753
}
    3dd8:	lea    0x40(%rsp),%rdi
    3ddd:	mov    %rbx,%rsi
    3de0:	callq  d10 <path_put_conditional.isra.13>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    3de5:	mov    0x8(%rbx),%rdi
    3de9:	callq  3dee <path_lookupat+0x52e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    3dee:	mov    (%rbx),%rdi
    3df1:	callq  3df6 <path_lookupat+0x536>
    3df6:	jmpq   3d3b <path_lookupat+0x47b>
    3dfb:	nopl   0x0(%rax,%rax,1)
nd_get_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:93
}

static inline char *nd_get_link(struct nameidata *nd)
{
	return nd->saved_names[nd->depth];
    3e00:	mov    0x48(%rbx),%eax
    3e03:	mov    0x50(%rbx,%rax,8),%r15
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:865
	s = nd_get_link(nd);
	if (s) {
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
    3e08:	test   %r15,%r15
    3e0b:	je     3c75 <path_lookupat+0x3b5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:866
		}
    3e11:	cmp    $0xfffffffffffff000,%r15
    3e18:	ja     41a6 <path_lookupat+0x8e6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:871
		if (*s == '/') {
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
    3e1e:	cmpb   $0x2f,(%r15)
    3e22:	je     3ec6 <path_lookupat+0x606>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    3e28:	mov    0x8(%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    3e2c:	mov    %r15,%rdi
    3e2f:	mov    %rbx,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    3e32:	mov    0x30(%rax),%rax
    3e36:	mov    %rax,0x30(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    3e3a:	callq  2e30 <link_path_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    3e3f:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}

    3e41:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    3e44:	je     3c75 <path_lookupat+0x3b5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:881

    3e4a:	mov    %r12,%rdx
    3e4d:	mov    %r13,%rsi
    3e50:	mov    %rbx,%rdi
    3e53:	callq  220 <put_link>
    3e58:	jmpq   3d3b <path_lookupat+0x47b>
    3e5d:	nopl   (%rax)
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    3e60:	mov    0x8(%rbx),%rdi
    3e64:	callq  3e69 <path_lookupat+0x5a9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    3e69:	mov    (%rbx),%rdi
    3e6c:	cmp    0x30(%rsp),%rdi
    3e71:	je     3f17 <path_lookupat+0x657>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    3e77:	callq  3e7c <path_lookupat+0x5bc>
    3e7c:	mov    0x28(%rsp),%rdx
    3e81:	mov    0x30(%rsp),%rax
    3e86:	mov    0x38(%rsp),%rsi
    3e8b:	jmpq   3cee <path_lookupat+0x42e>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:837
	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;
    3e90:	callq  3e95 <path_lookupat+0x5d5>
    3e95:	jmpq   3b93 <path_lookupat+0x2d3>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    3e9a:	testb  $0x40,0x38(%rbx)
    3e9e:	xchg   %ax,%ax
    3ea0:	je     3efd <path_lookupat+0x63d>
    3ea2:	mov    0x30(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    3ea7:	mov    0x38(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
			mntput(nd->path.mnt);
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    3eac:	mov    %rdi,(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1557
			if (unlikely(unlazy_walk(nd, path->dentry))) {
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
    3eaf:	mov    $0xfffffffe,%r15d
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    3eb5:	mov    %rax,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1578
 * limiting consecutive symlinks to 40.
 *
 * Without that kind of total limit, nasty chains of consecutive
 * symlinks can cause almost arbitrarily long lookups.
 */
static inline int nested_symlink(struct path *path, struct nameidata *nd)
    3eb9:	mov    %rbx,%rdi
    3ebc:	callq  cc0 <terminate_walk>
    3ec1:	jmpq   3d00 <path_lookupat+0x440>
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    3ec6:	cmpq   $0x0,0x20(%rbx)
    3ecb:	je     3f87 <path_lookupat+0x6c7>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:873
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
    3ed1:	mov    %rbx,%rdi
    3ed4:	callq  3ed9 <path_lookupat+0x619>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
		nd->inode = nd->path.dentry->d_inode;
    3ed9:	mov    0x20(%rbx),%rax
    3edd:	mov    0x28(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    3ee1:	lea    0x20(%rbx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
		nd->inode = nd->path.dentry->d_inode;
    3ee5:	mov    %rax,(%rbx)
    3ee8:	mov    %rdx,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    3eec:	callq  3ef1 <path_lookupat+0x631>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:876
		if (unlikely(error))
    3ef1:	orl    $0x1000,0x38(%rbx)
    3ef8:	jmpq   3e28 <path_lookupat+0x568>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    3efd:	mov    0x8(%rbx),%rdi
    3f01:	callq  3f06 <path_lookupat+0x646>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    3f06:	mov    (%rbx),%rdi
    3f09:	cmp    0x30(%rsp),%rdi
    3f0e:	je     3ea7 <path_lookupat+0x5e7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    3f10:	callq  3f15 <path_lookupat+0x655>
    3f15:	jmp    3ea2 <path_lookupat+0x5e2>
    3f17:	mov    0x28(%rsp),%rdx
    3f1c:	mov    0x38(%rsp),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
	nd->path.mnt = path->mnt;
    3f21:	mov    %rdi,%rax
    3f24:	jmpq   3cee <path_lookupat+0x42e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    3f29:	mov    0x8(%rbx),%rdi
    3f2d:	callq  3f32 <path_lookupat+0x672>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    3f32:	mov    (%rbx),%rdi
    3f35:	cmp    0x30(%rsp),%rdi
    3f3a:	je     40a1 <path_lookupat+0x7e1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    3f40:	callq  3f45 <path_lookupat+0x685>
    3f45:	mov    0x20(%rsp),%rdx
    3f4a:	mov    0x30(%rsp),%rax
    3f4f:	mov    0x38(%rsp),%rsi
    3f54:	jmpq   3aa2 <path_lookupat+0x1e2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    3f59:	testb  $0x40,0x38(%rbx)
    3f5d:	je     4080 <path_lookupat+0x7c0>
    3f63:	mov    0x30(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    3f68:	mov    0x38(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
			mntput(nd->path.mnt);
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    3f6d:	mov    %rdi,(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1557
			if (unlikely(unlazy_walk(nd, path->dentry))) {
				err = -ECHILD;
				goto out_err;
			}
		}
		BUG_ON(inode != path->dentry->d_inode);
    3f70:	mov    $0xfffffffe,%r13d
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    3f76:	mov    %rax,0x8(%rbx)
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1578
 * limiting consecutive symlinks to 40.
 *
 * Without that kind of total limit, nasty chains of consecutive
 * symlinks can cause almost arbitrarily long lookups.
 */
static inline int nested_symlink(struct path *path, struct nameidata *nd)
    3f7a:	mov    %rbx,%rdi
    3f7d:	callq  cc0 <terminate_walk>
    3f82:	jmpq   3d3e <path_lookupat+0x47e>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    3f87:	mov    %gs:0x0,%rdi
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652
static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}

    3f90:	add    $0x4a8,%rdi
    3f97:	callq  1370 <my_strcmp_base.constprop.35>
    3f9c:	test   %eax,%eax
    3f9e:	jne    3fb0 <path_lookupat+0x6f0>
    3fa0:	cmpb   $0x0,0x0(%rip)        # 3fa7 <path_lookupat+0x6e7>
    3fa7:	mov    0x0(%rip),%rax        # 3fae <path_lookupat+0x6ee>
    3fae:	jne    3fb9 <path_lookupat+0x6f9>
    3fb0:	mov    %gs:0x0,%rax
    3fb9:	mov    0x588(%rax),%rax
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    3fc0:	lea    0x4(%rax),%rsi
    3fc4:	mov    %rax,(%rsp)
    3fc8:	mov    %rsi,%rdi
    3fcb:	mov    %rsi,0x8(%rsp)
    3fd0:	callq  3fd5 <path_lookupat+0x715>
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:29
    3fd5:	mov    (%rsp),%rax
    3fd9:	mov    0x18(%rax),%rdx
    3fdd:	mov    0x20(%rax),%rax
    3fe1:	mov    %rdx,%rdi
    3fe4:	mov    %rdx,0x20(%rbx)
    3fe8:	mov    %rax,0x28(%rbx)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    3fec:	callq  3ff1 <path_lookupat+0x731>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    3ff1:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    3ffa:	mov    0x28(%rbx),%r8
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    3ffe:	add    $0x4a8,%rdx
    4005:	mov    $0x0,%rax
    400c:	jmp    4017 <path_lookupat+0x757>
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    400e:	test   %sil,%sil
    4011:	je     4155 <path_lookupat+0x895>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4017:	add    $0x1,%rdx
    401b:	movzbl -0x1(%rdx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    401f:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    4023:	cmp    -0x1(%rax),%sil
    4027:	je     400e <path_lookupat+0x74e>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4029:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    4032:	mov    $0x0,%rax
    4039:	add    $0x4a8,%rdx
    4040:	jmp    4051 <path_lookupat+0x791>
    4042:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4048:	test   %sil,%sil
    404b:	je     4155 <path_lookupat+0x895>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4051:	add    $0x1,%rdx
    4055:	movzbl -0x1(%rdx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    4059:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    405d:	cmp    -0x1(%rax),%sil
    4061:	je     4048 <path_lookupat+0x788>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    4063:	test   %r8,%r8
    4066:	je     4071 <path_lookupat+0x7b1>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    4068:	lea    0x58(%r8),%rdi
    406c:	callq  4071 <path_lookupat+0x7b1>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    4071:	mov    0x8(%rsp),%rdi
    4076:	callq  407b <path_lookupat+0x7bb>
    407b:	jmpq   3ed1 <path_lookupat+0x611>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    4080:	mov    0x8(%rbx),%rdi
    4084:	callq  4089 <path_lookupat+0x7c9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    4089:	mov    (%rbx),%rdi
    408c:	cmp    0x30(%rsp),%rdi
    4091:	je     3f68 <path_lookupat+0x6a8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    4097:	callq  409c <path_lookupat+0x7dc>
    409c:	jmpq   3f63 <path_lookupat+0x6a3>
    40a1:	mov    0x20(%rsp),%rdx
    40a6:	mov    0x38(%rsp),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
	nd->path.mnt = path->mnt;
    40ab:	mov    %rdi,%rax
    40ae:	jmpq   3aa2 <path_lookupat+0x1e2>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1561
		}
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
    40b3:	and    $0x1,%r13d
    40b7:	je     3cdf <path_lookupat+0x41f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1562
	return 0;
    40bd:	testb  $0x40,0x38(%rbx)
    40c1:	jne    40e0 <path_lookupat+0x820>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1568

out_path_put:
	path_to_nameidata(path, nd);
out_err:
	terminate_walk(nd);
	return err;
    40c3:	cmp    0x30(%rsi),%rdx
    40c7:	jne    41a1 <path_lookupat+0x8e1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1569
}
    40cd:	mov    $0x1,%r15d
    40d3:	jmpq   3d00 <path_lookupat+0x440>
    40d8:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1563
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;

    40e0:	mov    %rbx,%rdi
    40e3:	callq  17c0 <unlazy_walk>
    40e8:	test   %eax,%eax
    40ea:	jne    414a <path_lookupat+0x88a>
    40ec:	mov    0x38(%rsp),%rsi
    40f1:	mov    0x28(%rsp),%rdx
    40f6:	jmp    40c3 <path_lookupat+0x803>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1548

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
	if (!inode)
		goto out_path_put;
    40f8:	js     3eb9 <path_lookupat+0x5f9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1551

	if (should_follow_link(path->dentry, follow)) {
		if (nd->flags & LOOKUP_RCU) {
    40fe:	lea    0x30(%rsp),%rsi
    4103:	mov    %rbx,%rdi
    4106:	callq  410b <path_lookupat+0x84b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1552
			if (unlikely(unlazy_walk(nd, path->dentry))) {
    410b:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1551
	err = -ENOENT;
	if (!inode)
		goto out_path_put;

	if (should_follow_link(path->dentry, follow)) {
		if (nd->flags & LOOKUP_RCU) {
    410d:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1552
			if (unlikely(unlazy_walk(nd, path->dentry))) {
    4110:	js     3eb9 <path_lookupat+0x5f9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1555
				err = -ECHILD;
				goto out_err;
			}
    4116:	mov    0x38(%rsp),%rax
    411b:	mov    0x30(%rax),%rdx
    411f:	mov    %rdx,0x28(%rsp)
    4124:	jmpq   3cbf <path_lookupat+0x3ff>
    4129:	nopl   0x0(%rax)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    4130:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:839
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
    4132:	mov    $0xffffffd8,%r15d
    4138:	lea    0x40(%rsp),%r13
    413d:	jmpq   3c59 <path_lookupat+0x399>
lookup_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1545
		err = lookup_slow(nd, path);
		if (err < 0)
			goto out_err;

		inode = path->dentry->d_inode;
	}
    4142:	mov    %eax,%r13d
    4145:	jmpq   3d3e <path_lookupat+0x47e>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1564
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;

out_path_put:
    414a:	mov    $0xfffffff6,%r15d
    4150:	jmpq   3eb9 <path_lookupat+0x5f9>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4155:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    415e:	mov    $0x0,%rsi
    4165:	add    $0x4a8,%rdx
    416c:	mov    $0x0,%rdi
    4173:	xor    %eax,%eax
    4175:	mov    %r8,(%rsp)
    4179:	callq  417e <path_lookupat+0x8be>
    417e:	mov    (%rsp),%r8
    4182:	jmpq   4063 <path_lookupat+0x7a3>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1561
		}
		BUG_ON(inode != path->dentry->d_inode);
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
    4187:	and    $0x1,%r12d
    418b:	je     3a93 <path_lookupat+0x1d3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1562
	return 0;
    4191:	testb  $0x40,0x38(%rbx)
    4195:	jne    41f0 <path_lookupat+0x930>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1568

out_path_put:
	path_to_nameidata(path, nd);
out_err:
	terminate_walk(nd);
	return err;
    4197:	cmp    %rdx,0x30(%rsi)
    419b:	je     3ac6 <path_lookupat+0x206>
    41a1:	callq  41a6 <path_lookupat+0x8e6>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:867
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
		}
		if (*s == '/') {
    41a6:	mov    %rbx,%rdi
    41a9:	callq  41ae <path_lookupat+0x8ee>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:868
			set_root(nd);
    41ae:	mov    %r12,%rdx
    41b1:	mov    %r13,%rsi
    41b4:	mov    %rbx,%rdi
    41b7:	callq  220 <put_link>
    41bc:	jmpq   3c6c <path_lookupat+0x3ac>
walk_component():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1548

		inode = path->dentry->d_inode;
	}
	err = -ENOENT;
	if (!inode)
		goto out_path_put;
    41c1:	js     4208 <path_lookupat+0x948>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1551

	if (should_follow_link(path->dentry, follow)) {
		if (nd->flags & LOOKUP_RCU) {
    41c3:	lea    0x30(%rsp),%rsi
    41c8:	mov    %rbx,%rdi
    41cb:	callq  41d0 <path_lookupat+0x910>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1552
			if (unlikely(unlazy_walk(nd, path->dentry))) {
    41d0:	test   %eax,%eax
    41d2:	js     4208 <path_lookupat+0x948>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1555
				err = -ECHILD;
				goto out_err;
			}
    41d4:	mov    0x38(%rsp),%rax
    41d9:	mov    0x30(%rax),%rdx
    41dd:	mov    %rdx,0x20(%rsp)
    41e2:	jmpq   3a73 <path_lookupat+0x1b3>
    41e7:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1563
		return 1;
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;

    41f0:	mov    %rbx,%rdi
    41f3:	callq  17c0 <unlazy_walk>
    41f8:	test   %eax,%eax
    41fa:	jne    4210 <path_lookupat+0x950>
    41fc:	mov    0x38(%rsp),%rsi
    4201:	mov    0x20(%rsp),%rdx
    4206:	jmp    4197 <path_lookupat+0x8d7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1552
	if (!inode)
		goto out_path_put;

	if (should_follow_link(path->dentry, follow)) {
		if (nd->flags & LOOKUP_RCU) {
			if (unlikely(unlazy_walk(nd, path->dentry))) {
    4208:	mov    %eax,%r13d
    420b:	jmpq   3f7a <path_lookupat+0x6ba>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1564
	}
	path_to_nameidata(path, nd);
	nd->inode = inode;
	return 0;

out_path_put:
    4210:	mov    $0xfffffff6,%r13d
    4216:	jmpq   3f7a <path_lookupat+0x6ba>
path_lookupat():
    421b:	nopl   0x0(%rax,%rax,1)

0000000000004220 <filename_lookup>:
filename_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1994
		audit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);
	return retval;
}

static int do_path_lookup(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
    4220:	callq  4225 <filename_lookup+0x5>
    4225:	push   %rbp
    4226:	mov    %rsp,%rbp
    4229:	push   %r15
    422b:	mov    %edi,%r15d
    422e:	push   %r14
    4230:	mov    %rcx,%r14
    4233:	push   %r13
    4235:	mov    %edx,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1995
	struct filename filename = { .name = name };
    4238:	or     $0x40,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1994
		audit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);
	return retval;
}

static int do_path_lookup(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
    423b:	push   %r12
    423d:	mov    %rsi,%r12
    4240:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1995
	struct filename filename = { .name = name };
    4241:	mov    (%rsi),%rsi
    4244:	callq  38c0 <path_lookupat>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1996

    4249:	cmp    $0xfffffff6,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1995
	return retval;
}

static int do_path_lookup(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
	struct filename filename = { .name = name };
    424c:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1996

    424e:	je     43ae <filename_lookup+0x18e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1998
	return filename_lookup(dfd, &filename, flags, nd);
}
    4254:	cmp    $0xffffff8c,%ebx
    4257:	je     4392 <filename_lookup+0x172>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2002

/* does lookup, returns the object with parent locked */
struct dentry *kern_path_locked(const char *name, struct path *path)
{
    425d:	test   %ebx,%ebx
    425f:	jne    433d <filename_lookup+0x11d>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4265:	mov    %gs:0x0,%r8
filename_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2003
	struct nameidata nd;
    426e:	mov    0x8(%r14),%r14
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    4272:	add    $0x4a8,%r8
    4279:	mov    $0x0,%rcx
    4280:	jmp    4290 <filename_lookup+0x70>
    4282:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4288:	test   %al,%al
    428a:	je     4368 <filename_lookup+0x148>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4290:	add    $0x1,%r8
    4294:	movzbl -0x1(%r8),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    4299:	add    $0x1,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    429d:	cmp    -0x1(%rcx),%al
    42a0:	je     4288 <filename_lookup+0x68>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    42a2:	mov    %gs:0x0,%r8
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    42ab:	mov    $0x0,%rcx
    42b2:	add    $0x4a8,%r8
    42b9:	jmp    42c8 <filename_lookup+0xa8>
    42bb:	nopl   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    42c0:	test   %al,%al
    42c2:	je     4368 <filename_lookup+0x148>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    42c8:	add    $0x1,%r8
    42cc:	movzbl -0x1(%r8),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    42d1:	add    $0x1,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    42d5:	cmp    -0x1(%rcx),%al
    42d8:	je     42c0 <filename_lookup+0xa0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    42da:	mov    %gs:0x0,%r8
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    42e3:	mov    $0x0,%rcx
    42ea:	add    $0x4a8,%r8
    42f1:	jmp    42fc <filename_lookup+0xdc>
    42f3:	nopl   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    42f8:	test   %al,%al
    42fa:	je     4350 <filename_lookup+0x130>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    42fc:	add    $0x1,%r8
    4300:	movzbl -0x1(%r8),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    4305:	add    $0x1,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    4309:	cmp    -0x1(%rcx),%al
    430c:	je     42f8 <filename_lookup+0xd8>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    430e:	mov    %gs:0x0,%rax
    4317:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    431e:	test   %rax,%rax
    4321:	je     433d <filename_lookup+0x11d>
    4323:	mov    (%rax),%eax
    4325:	test   %eax,%eax
    4327:	jne    433d <filename_lookup+0x11d>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:165
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context())) {
		unsigned int flags = 0;
		if (parent)
    4329:	mov    %r13d,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:167
			flags |= AUDIT_INODE_PARENT;
		__audit_inode(name, dentry, flags);
    432c:	mov    %r14,%rsi
    432f:	mov    %r12,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:165
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context())) {
		unsigned int flags = 0;
		if (parent)
    4332:	shr    $0x4,%edx
    4335:	and    $0x1,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:167
			flags |= AUDIT_INODE_PARENT;
		__audit_inode(name, dentry, flags);
    4338:	callq  433d <filename_lookup+0x11d>
filename_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2005
	struct dentry *d;
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
    433d:	mov    %ebx,%eax
    433f:	pop    %rbx
    4340:	pop    %r12
    4342:	pop    %r13
    4344:	pop    %r14
    4346:	pop    %r15
    4348:	pop    %rbp
    4349:	retq   
    434a:	nopw   0x0(%rax,%rax,1)
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    4350:	cmpb   $0x0,0x0(%rip)        # 4357 <filename_lookup+0x137>
    4357:	mov    0x0(%rip),%rax        # 435e <filename_lookup+0x13e>
    435e:	jne    4317 <filename_lookup+0xf7>
    4360:	jmp    430e <filename_lookup+0xee>
    4362:	nopw   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    4368:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    4371:	mov    $0x0,%rsi
    4378:	add    $0x4a8,%rdx
    437f:	mov    $0x0,%rdi
    4386:	xor    %eax,%eax
    4388:	callq  438d <filename_lookup+0x16d>
    438d:	jmpq   42da <filename_lookup+0xba>
filename_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1999
{
	struct filename filename = { .name = name };

	return filename_lookup(dfd, &filename, flags, nd);
}

    4392:	mov    (%r12),%rsi
    4396:	mov    %r13d,%edx
    4399:	mov    %r14,%rcx
    439c:	or     $0x20,%edx
    439f:	mov    %r15d,%edi
    43a2:	callq  38c0 <path_lookupat>
    43a7:	mov    %eax,%ebx
    43a9:	jmpq   425d <filename_lookup+0x3d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1997

static int do_path_lookup(int dfd, const char *name, unsigned int flags, struct nameidata *nd)
{
	struct filename filename = { .name = name };

	return filename_lookup(dfd, &filename, flags, nd);
    43ae:	mov    (%r12),%rsi
    43b2:	mov    %r14,%rcx
    43b5:	mov    %r13d,%edx
    43b8:	mov    %r15d,%edi
    43bb:	callq  38c0 <path_lookupat>
    43c0:	mov    %eax,%ebx
    43c2:	jmpq   4254 <filename_lookup+0x34>
    43c7:	nopw   0x0(%rax,%rax,1)

00000000000043d0 <kern_path>:
kern_path():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2039
 * @dentry:  pointer to dentry of the base directory
 * @mnt: pointer to vfs mount of the base directory
 * @name: pointer to file name
 * @flags: lookup flags
 * @path: pointer to struct path to fill
 */
    43d0:	callq  43d5 <kern_path+0x5>
    43d5:	push   %rbp
    43d6:	mov    %rsp,%rbp
    43d9:	push   %rbx
    43da:	mov    %rdx,%rbx
do_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    43dd:	mov    %esi,%edx
kern_path():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2039
 * @dentry:  pointer to dentry of the base directory
 * @mnt: pointer to vfs mount of the base directory
 * @name: pointer to file name
 * @flags: lookup flags
 * @path: pointer to struct path to fill
 */
    43df:	and    $0xfffffffffffffff0,%rsp
    43e3:	sub    $0xc0,%rsp
do_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    43ea:	lea    0x20(%rsp),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    43ef:	mov    %rdi,(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    43f3:	mov    %rsp,%rsi
    43f6:	mov    $0xffffff9c,%edi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    43fb:	movq   $0x0,0x8(%rsp)
    4404:	movq   $0x0,0x10(%rsp)
    440d:	movq   $0x0,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    4416:	callq  4220 <filename_lookup>
kern_path():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2042
 * @flags: lookup flags
 * @path: pointer to struct path to fill
 */
int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt, const char *name, unsigned int flags, struct path *path)
{
	struct nameidata nd;
    441b:	test   %eax,%eax
    441d:	jne    4430 <kern_path+0x60>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2043
	int err;
    441f:	mov    0x20(%rsp),%rsi
    4424:	mov    0x28(%rsp),%rdi
    4429:	mov    %rsi,(%rbx)
    442c:	mov    %rdi,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2045
	nd.root.dentry = dentry;
	nd.root.mnt = mnt;
    4430:	mov    -0x8(%rbp),%rbx
    4434:	leaveq 
    4435:	retq   
    4436:	nopw   %cs:0x0(%rax,%rax,1)

0000000000004440 <vfs_path_lookup>:
vfs_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2058

/*
 * Restricted form of lookup. Doesn't follow links, single-component only,
 * needs parent already locked. Doesn't follow mounts.
 * SMP-safe.
 */
    4440:	callq  4445 <vfs_path_lookup+0x5>
    4445:	push   %rbp
    4446:	mov    %rsp,%rbp
    4449:	push   %rbx
    444a:	and    $0xfffffffffffffff0,%rsp
    444e:	sub    $0xc0,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2063
static struct dentry *lookup_hash(struct nameidata *nd)
{
	return __lookup_hash(&nd->last, nd->path.dentry, nd->flags);
}

    4455:	test   $0x10,%cl
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2061
 * needs parent already locked. Doesn't follow mounts.
 * SMP-safe.
 */
static struct dentry *lookup_hash(struct nameidata *nd)
{
	return __lookup_hash(&nd->last, nd->path.dentry, nd->flags);
    4458:	mov    %rdi,0x48(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2062
}
    445d:	mov    %rsi,0x40(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2063

    4462:	jne    44b8 <vfs_path_lookup+0x78>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2065
/**
 * lookup_one_len - filesystem helper to lookup single pathname component
    4464:	or     $0x20,%ch
do_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    4467:	mov    %rdx,(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    446b:	mov    %rsp,%rsi
vfs_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2065
{
	return __lookup_hash(&nd->last, nd->path.dentry, nd->flags);
}

/**
 * lookup_one_len - filesystem helper to lookup single pathname component
    446e:	mov    %ecx,%edx
do_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    4470:	lea    0x20(%rsp),%rcx
    4475:	mov    $0xffffff9c,%edi
    447a:	mov    %r8,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    447d:	movq   $0x0,0x8(%rsp)
    4486:	movq   $0x0,0x10(%rsp)
    448f:	movq   $0x0,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    4498:	callq  4220 <filename_lookup>
vfs_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2066
	return __lookup_hash(&nd->last, nd->path.dentry, nd->flags);
}

/**
 * lookup_one_len - filesystem helper to lookup single pathname component
 * @name:	pathname component to lookup
    449d:	test   %eax,%eax
    449f:	jne    44b2 <vfs_path_lookup+0x72>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2067
 * @base:	base directory to lookup from
    44a1:	mov    0x20(%rsp),%rsi
    44a6:	mov    0x28(%rsp),%rdi
    44ab:	mov    %rsi,(%rbx)
    44ae:	mov    %rdi,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2069
 * @len:	maximum length @len should be interpreted to
 *
    44b2:	mov    -0x8(%rbp),%rbx
    44b6:	leaveq 
    44b7:	retq   
    44b8:	callq  44bd <vfs_path_lookup+0x7d>
    44bd:	nopl   (%rax)

00000000000044c0 <kern_path_create>:
kern_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3309
	 * Special case - lookup gave negative, but... we had foo/bar/
	 * From the vfs_mknod() POV we just have a negative dentry -
	 * all is fine. Let's be bastards - you had / on the end, you've
	 * been asking for (non-existent) directory. -ENOENT for you.
	 */
	if (unlikely(!is_dir && nd.last.name[nd.last.len])) {
    44c0:	callq  44c5 <kern_path_create+0x5>
    44c5:	push   %rbp
    44c6:	mov    %rsp,%rbp
    44c9:	push   %r13
    44cb:	push   %r12
    44cd:	mov    %ecx,%r12d
    44d0:	push   %rbx
    44d1:	mov    %rdx,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3320
		goto fail;
	}
	*path = nd.path;
	return dentry;
fail:
	dput(dentry);
    44d4:	mov    %ecx,%edx
    44d6:	and    $0x20,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3309
	 * Special case - lookup gave negative, but... we had foo/bar/
	 * From the vfs_mknod() POV we just have a negative dentry -
	 * all is fine. Let's be bastards - you had / on the end, you've
	 * been asking for (non-existent) directory. -ENOENT for you.
	 */
	if (unlikely(!is_dir && nd.last.name[nd.last.len])) {
    44d9:	and    $0xfffffffffffffff0,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3322
	*path = nd.path;
	return dentry;
fail:
	dput(dentry);
	dentry = ERR_PTR(error);
unlock:
    44dd:	or     $0x10,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3309
	 * Special case - lookup gave negative, but... we had foo/bar/
	 * From the vfs_mknod() POV we just have a negative dentry -
	 * all is fine. Let's be bastards - you had / on the end, you've
	 * been asking for (non-existent) directory. -ENOENT for you.
	 */
	if (unlikely(!is_dir && nd.last.name[nd.last.len])) {
    44e0:	sub    $0xc0,%rsp
do_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    44e7:	lea    0x20(%rsp),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    44ec:	mov    %rsi,(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    44f0:	mov    %rsp,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    44f3:	movq   $0x0,0x8(%rsp)
    44fc:	movq   $0x0,0x10(%rsp)
    4505:	movq   $0x0,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    450e:	callq  4220 <filename_lookup>
kern_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3323
	return dentry;
fail:
	dput(dentry);
	dentry = ERR_PTR(error);
unlock:
	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
    4513:	test   %eax,%eax
    4515:	jne    45e0 <kern_path_create+0x120>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3330
		mnt_drop_write(nd.path.mnt);
out:
	path_put(&nd.path);
	return dentry;
}
EXPORT_SYMBOL(kern_path_create);
    451b:	mov    0x64(%rsp),%eax
    451f:	test   %eax,%eax
    4521:	jne    45b0 <kern_path_create+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3332

void done_path_create(struct path *path, struct dentry *dentry)
    4527:	mov    0x58(%rsp),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3336
{
	dput(dentry);
	mutex_unlock(&path->dentry->d_inode->i_mutex);
	mnt_drop_write(path->mnt);
    452b:	mov    0x20(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3332
	path_put(&nd.path);
	return dentry;
}
EXPORT_SYMBOL(kern_path_create);

void done_path_create(struct path *path, struct dentry *dentry)
    4530:	and    $0xffffffef,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3333
{
    4533:	or     $0x6,%ah
    4536:	mov    %eax,0x58(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3336
	dput(dentry);
	mutex_unlock(&path->dentry->d_inode->i_mutex);
	mnt_drop_write(path->mnt);
    453a:	callq  453f <kern_path_create+0x7f>
    453f:	mov    %eax,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3340
	path_put(path);
}
EXPORT_SYMBOL(done_path_create);

    4542:	mov    0x28(%rsp),%rax
    4547:	mov    0x30(%rax),%rdi
    454b:	add    $0xa8,%rdi
    4552:	callq  4557 <kern_path_create+0x97>
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    4557:	mov    0x58(%rsp),%edx
    455b:	mov    0x28(%rsp),%rsi
    4560:	lea    0x30(%rsp),%rdi
    4565:	callq  9a0 <__lookup_hash>
kern_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3342
	path_put(path);
}
EXPORT_SYMBOL(done_path_create);

struct dentry *user_path_create(int dfd, const char __user *pathname, struct path *path, unsigned int lookup_flags)
{
    456a:	cmp    $0xfffffffffffff000,%rax
    4570:	ja     4646 <kern_path_create+0x186>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3346
	struct filename *tmp = getname(pathname);
	struct dentry *res;
	if (IS_ERR(tmp))
		return ERR_CAST(tmp);
    4576:	testl  $0x700000,(%rax)
    457c:	jne    45f0 <kern_path_create+0x130>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3355
}
EXPORT_SYMBOL(user_path_create);

int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
{
	int error = may_create(dir, dentry);
    457e:	and    $0x2,%r12d
    4582:	je     4625 <kern_path_create+0x165>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3359

	if (error)
		return error;

    4588:	test   %r13d,%r13d
    458b:	jne    4641 <kern_path_create+0x181>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3363
	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))
		return -EPERM;

	if (!dir->i_op->mknod)
    4591:	mov    0x20(%rsp),%rsi
    4596:	mov    0x28(%rsp),%rdi
    459b:	mov    %rsi,(%rbx)
    459e:	mov    %rdi,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3375
	error = security_inode_mknod(dir, dentry, mode, dev);
	if (error)
		return error;

	error = dir->i_op->mknod(dir, dentry, mode, dev);
	if (!error)
    45a2:	lea    -0x18(%rbp),%rsp
    45a6:	pop    %rbx
    45a7:	pop    %r12
    45a9:	pop    %r13
    45ab:	pop    %rbp
    45ac:	retq   
    45ad:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3310
	 * From the vfs_mknod() POV we just have a negative dentry -
	 * all is fine. Let's be bastards - you had / on the end, you've
	 * been asking for (non-existent) directory. -ENOENT for you.
	 */
	if (unlikely(!is_dir && nd.last.name[nd.last.len])) {
		error = -ENOENT;
    45b0:	mov    $0xffffffffffffffef,%rbx
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    45b7:	mov    0x28(%rsp),%rdi
    45bc:	callq  45c1 <kern_path_create+0x101>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    45c1:	mov    0x20(%rsp),%rdi
    45c6:	callq  45cb <kern_path_create+0x10b>
kern_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3375
	error = security_inode_mknod(dir, dentry, mode, dev);
	if (error)
		return error;

	error = dir->i_op->mknod(dir, dentry, mode, dev);
	if (!error)
    45cb:	lea    -0x18(%rbp),%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3374

	error = security_inode_mknod(dir, dentry, mode, dev);
	if (error)
		return error;

	error = dir->i_op->mknod(dir, dentry, mode, dev);
    45cf:	mov    %rbx,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3375
	if (!error)
    45d2:	pop    %rbx
    45d3:	pop    %r12
    45d5:	pop    %r13
    45d7:	pop    %rbp
    45d8:	retq   
    45d9:	nopl   0x0(%rax)
    45e0:	lea    -0x18(%rbp),%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3324
fail:
	dput(dentry);
	dentry = ERR_PTR(error);
unlock:
	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
	if (!err2)
    45e4:	cltq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3375
	error = security_inode_mknod(dir, dentry, mode, dev);
	if (error)
		return error;

	error = dir->i_op->mknod(dir, dentry, mode, dev);
	if (!error)
    45e6:	pop    %rbx
    45e7:	pop    %r12
    45e9:	pop    %r13
    45eb:	pop    %rbp
    45ec:	retq   
    45ed:	nopl   (%rax)
    45f0:	mov    $0xffffffffffffffef,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3366
		return -EPERM;

	if (!dir->i_op->mknod)
		return -EPERM;

	error = devcgroup_inode_mknod(mode, dev);
    45f7:	mov    %rax,%rdi
    45fa:	callq  45ff <kern_path_create+0x13f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3369
	if (error)
		return error;

    45ff:	mov    0x28(%rsp),%rax
    4604:	mov    0x30(%rax),%rdi
    4608:	add    $0xa8,%rdi
    460f:	callq  4614 <kern_path_create+0x154>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3370
	error = security_inode_mknod(dir, dentry, mode, dev);
    4614:	test   %r13d,%r13d
    4617:	jne    45b7 <kern_path_create+0xf7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3371
	if (error)
    4619:	mov    0x20(%rsp),%rdi
    461e:	callq  4623 <kern_path_create+0x163>
    4623:	jmp    45b7 <kern_path_create+0xf7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3355 (discriminator 1)
}
EXPORT_SYMBOL(user_path_create);

int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
{
	int error = may_create(dir, dentry);
    4625:	mov    0x34(%rsp),%edx
    4629:	mov    0x38(%rsp),%rcx
    462e:	cmpb   $0x0,(%rcx,%rdx,1)
    4632:	je     4588 <kern_path_create+0xc8>
    4638:	mov    $0xfffffffffffffffe,%rbx
    463f:	jmp    45f7 <kern_path_create+0x137>
    4641:	movslq %r13d,%rbx
    4644:	jmp    45f7 <kern_path_create+0x137>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3341
	mnt_drop_write(path->mnt);
	path_put(path);
}
EXPORT_SYMBOL(done_path_create);

struct dentry *user_path_create(int dfd, const char __user *pathname, struct path *path, unsigned int lookup_flags)
    4646:	mov    %rax,%rbx
    4649:	jmp    45ff <kern_path_create+0x13f>
    464b:	nopl   0x0(%rax,%rax,1)

0000000000004650 <user_path_create>:
user_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3389
	case S_IFCHR:
	case S_IFBLK:
	case S_IFIFO:
	case S_IFSOCK:
	case 0: /* zero mode translates to S_IFREG */
		return 0;
    4650:	callq  4655 <user_path_create+0x5>
    4655:	push   %rbp
    4656:	mov    %rsp,%rbp
    4659:	push   %r14
    465b:	mov    %ecx,%r14d
    465e:	push   %r13
    4660:	mov    %rdx,%r13
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    4663:	xor    %edx,%edx
user_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3389
	case S_IFCHR:
	case S_IFBLK:
	case S_IFIFO:
	case S_IFSOCK:
	case 0: /* zero mode translates to S_IFREG */
		return 0;
    4665:	push   %r12
    4667:	mov    %edi,%r12d
    466a:	mov    %rsi,%rdi
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    466d:	xor    %esi,%esi
user_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3389
	case S_IFCHR:
	case S_IFBLK:
	case S_IFIFO:
	case S_IFSOCK:
	case 0: /* zero mode translates to S_IFREG */
		return 0;
    466f:	push   %rbx
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    4670:	callq  2290 <getname_flags>
user_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3392
	case S_IFSOCK:
	case 0: /* zero mode translates to S_IFREG */
		return 0;
	case S_IFDIR:
		return -EPERM;
	default:
    4675:	cmp    $0xfffffffffffff000,%rax
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    467b:	mov    %rax,%rbx
user_path_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3392
	case S_IFSOCK:
	case 0: /* zero mode translates to S_IFREG */
		return 0;
	case S_IFDIR:
		return -EPERM;
	default:
    467e:	ja     469f <user_path_create+0x4f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3394
		return -EINVAL;
	}
    4680:	mov    (%rax),%rsi
    4683:	mov    %r12d,%edi
    4686:	mov    %r14d,%ecx
    4689:	mov    %r13,%rdx
    468c:	callq  4691 <user_path_create+0x41>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3395
}
    4691:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3394
		return 0;
	case S_IFDIR:
		return -EPERM;
	default:
		return -EINVAL;
	}
    4694:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3395
}
    4697:	callq  469c <user_path_create+0x4c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3396

    469c:	mov    %r12,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3397
SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev)
    469f:	pop    %rbx
    46a0:	pop    %r12
    46a2:	pop    %r13
    46a4:	pop    %r14
    46a6:	pop    %rbp
    46a7:	retq   
    46a8:	nopl   0x0(%rax,%rax,1)

00000000000046b0 <user_path_parent>:
user_path_parent():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2166
	return s;
}

/**
 * mountpoint_last - look up last component for umount
 * @nd:   pathwalk nameidata - currently pointing at parent directory of "last"
    46b0:	callq  46b5 <user_path_parent+0x5>
    46b5:	push   %rbp
    46b6:	mov    %rsp,%rbp
    46b9:	push   %r14
    46bb:	mov    %rdx,%r14
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    46be:	xor    %edx,%edx
user_path_parent():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2166
	return s;
}

/**
 * mountpoint_last - look up last component for umount
 * @nd:   pathwalk nameidata - currently pointing at parent directory of "last"
    46c0:	push   %r13
    46c2:	mov    %edi,%r13d
    46c5:	mov    %rsi,%rdi
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    46c8:	xor    %esi,%esi
user_path_parent():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2166
	return s;
}

/**
 * mountpoint_last - look up last component for umount
 * @nd:   pathwalk nameidata - currently pointing at parent directory of "last"
    46ca:	push   %r12
    46cc:	mov    %ecx,%r12d
    46cf:	push   %rbx
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    46d0:	callq  2290 <getname_flags>
user_path_parent():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2171
 * @nd:   pathwalk nameidata - currently pointing at parent directory of "last"
 * @path: pointer to container for result
 *
 * This is a special lookup_last function just for umount. In this case, we
 * need to resolve the path without doing any revalidation.
 *
    46d5:	mov    %r12d,%edx
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    46d8:	mov    %rax,%rbx
user_path_parent():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2171
 * @nd:   pathwalk nameidata - currently pointing at parent directory of "last"
 * @path: pointer to container for result
 *
 * This is a special lookup_last function just for umount. In this case, we
 * need to resolve the path without doing any revalidation.
 *
    46db:	and    $0x20,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2173
 * The nameidata should be the result of doing a LOOKUP_PARENT pathwalk. Since
 * mountpoints are always pinned in the dcache, their ancestors are too. Thus,
    46de:	cmp    $0xfffffffffffff000,%rax
    46e4:	ja     4709 <user_path_parent+0x59>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2176
 * in almost all cases, this lookup will be served out of the dcache. The only
 * cases where it won't are if nd->last refers to a symlink or the path is
 * bogus and it doesn't exist.
    46e6:	or     $0x10,%edx
    46e9:	mov    %r14,%rcx
    46ec:	mov    %rax,%rsi
    46ef:	mov    %r13d,%edi
    46f2:	callq  4220 <filename_lookup>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2177
 *
    46f7:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2176
 *
 * The nameidata should be the result of doing a LOOKUP_PARENT pathwalk. Since
 * mountpoints are always pinned in the dcache, their ancestors are too. Thus,
 * in almost all cases, this lookup will be served out of the dcache. The only
 * cases where it won't are if nd->last refers to a symlink or the path is
 * bogus and it doesn't exist.
    46f9:	mov    %eax,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2177
 *
    46fc:	je     4709 <user_path_parent+0x59>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2178
 * Returns:
    46fe:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2179
 * -error: if there was an error during lookup. This includes -ENOENT if the
    4701:	movslq %r12d,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2178
 * mountpoints are always pinned in the dcache, their ancestors are too. Thus,
 * in almost all cases, this lookup will be served out of the dcache. The only
 * cases where it won't are if nd->last refers to a symlink or the path is
 * bogus and it doesn't exist.
 *
 * Returns:
    4704:	callq  4709 <user_path_parent+0x59>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2183
 * -error: if there was an error during lookup. This includes -ENOENT if the
 *         lookup found a negative dentry. The nd->path reference will also be
 *         put in this case.
 *
 * 0:      if we successfully resolved nd->path and found it to not to be a
    4709:	mov    %rbx,%rax
    470c:	pop    %rbx
    470d:	pop    %r12
    470f:	pop    %r13
    4711:	pop    %r14
    4713:	pop    %rbp
    4714:	retq   
    4715:	data32 nopw %cs:0x0(%rax,%rax,1)

0000000000004720 <path_mountpoint>:
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2289
		err = may_follow_link(&link, &nd);
		if (unlikely(err))
			break;
		nd.flags |= LOOKUP_PARENT;
		err = follow_link(&link, &nd, &cookie);
		if (err)
    4720:	callq  4725 <path_mountpoint+0x5>
    4725:	push   %rbp
    4726:	mov    %rsp,%rbp
    4729:	push   %r15
    472b:	push   %r14
    472d:	mov    %rdx,%r14
    4730:	mov    %ecx,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2294
			break;
		err = mountpoint_last(&nd, path);
		put_link(&nd, &link, cookie);
	}
out:
    4732:	or     $0x10,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2289
		err = may_follow_link(&link, &nd);
		if (unlikely(err))
			break;
		nd.flags |= LOOKUP_PARENT;
		err = follow_link(&link, &nd, &cookie);
		if (err)
    4735:	push   %r13
    4737:	push   %r12
    4739:	push   %rbx
    473a:	mov    %rsi,%rbx
    473d:	and    $0xfffffffffffffff0,%rsp
    4741:	sub    $0xd0,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2294
			break;
		err = mountpoint_last(&nd, path);
		put_link(&nd, &link, cookie);
	}
out:
    4748:	lea    0x18(%rsp),%r8
    474d:	lea    0x30(%rsp),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2290
		if (unlikely(err))
			break;
		nd.flags |= LOOKUP_PARENT;
		err = follow_link(&link, &nd, &cookie);
		if (err)
			break;
    4752:	movq   $0x0,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2294
		err = mountpoint_last(&nd, path);
		put_link(&nd, &link, cookie);
	}
out:
    475b:	callq  25f0 <path_init>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2295
	if (base)
    4760:	test   %eax,%eax
    4762:	jne    47df <path_mountpoint+0xbf>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4764:	mov    %gs:0x0,%rdx
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2298
		fput(base);

	if (nd.root.mnt && !(nd.flags & LOOKUP_ROOT))
    476d:	mov    $0x0,%rax
    4774:	add    $0x4a8,%rdx
    477b:	jmp    4784 <path_mountpoint+0x64>
    477d:	nopl   (%rax)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4780:	test   %cl,%cl
    4782:	je     47f0 <path_mountpoint+0xd0>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4784:	add    $0x1,%rdx
    4788:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    478c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    4790:	cmp    -0x1(%rax),%cl
    4793:	je     4780 <path_mountpoint+0x60>
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2298
    4795:	mov    %gs:0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2299 (discriminator 3)
		path_put(&nd.root);
    479e:	lea    0x30(%rsp),%rsi
    47a3:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2298 (discriminator 3)
	}
out:
	if (base)
		fput(base);

	if (nd.root.mnt && !(nd.flags & LOOKUP_ROOT))
    47a6:	movl   $0x0,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2299 (discriminator 3)
		path_put(&nd.root);
    47b0:	callq  2e30 <link_path_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2300 (discriminator 3)

    47b5:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2299 (discriminator 3)
out:
	if (base)
		fput(base);

	if (nd.root.mnt && !(nd.flags & LOOKUP_ROOT))
		path_put(&nd.root);
    47b7:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2300 (discriminator 3)

    47b9:	je     4802 <path_mountpoint+0xe2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2318
	return error;
}

/**
 * user_path_mountpoint_at - lookup a path from userland in order to umount it
 * @dfd:	directory file descriptor
    47bb:	mov    0x18(%rsp),%rdi
    47c0:	test   %rdi,%rdi
    47c3:	je     47ca <path_mountpoint+0xaa>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2319
 * @name:	pathname from userland
    47c5:	callq  47ca <path_mountpoint+0xaa>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2321
 * @flags:	lookup flags
 * @path:	pointer to container to hold result
    47ca:	cmpq   $0x0,0x50(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2324
 *
 * A umount is a special case for path walking. We're not actually interested
 * in the inode in this situation, and ESTALE errors can be a problem. We
    47d0:	mov    %ebx,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2321
/**
 * user_path_mountpoint_at - lookup a path from userland in order to umount it
 * @dfd:	directory file descriptor
 * @name:	pathname from userland
 * @flags:	lookup flags
 * @path:	pointer to container to hold result
    47d2:	je     47df <path_mountpoint+0xbf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2321 (discriminator 1)
    47d4:	testb  $0x20,0x69(%rsp)
    47d9:	je     4b25 <path_mountpoint+0x405>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2325
 *
 * A umount is a special case for path walking. We're not actually interested
 * in the inode in this situation, and ESTALE errors can be a problem. We
 * simply want track down the dentry and vfsmount attached at the mountpoint
    47df:	lea    -0x28(%rbp),%rsp
    47e3:	pop    %rbx
    47e4:	pop    %r12
    47e6:	pop    %r13
    47e8:	pop    %r14
    47ea:	pop    %r15
    47ec:	pop    %rbp
    47ed:	retq   
    47ee:	xchg   %ax,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2298
	}
out:
	if (base)
		fput(base);

	if (nd.root.mnt && !(nd.flags & LOOKUP_ROOT))
    47f0:	cmpb   $0x0,0x0(%rip)        # 47f7 <path_mountpoint+0xd7>
    47f7:	mov    0x0(%rip),%rax        # 47fe <path_mountpoint+0xde>
    47fe:	jne    479e <path_mountpoint+0x7e>
    4800:	jmp    4795 <path_mountpoint+0x75>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2303
		path_put(&nd.root);

	return err;
}

    4802:	lea    0x30(%rsp),%rdi
    4807:	mov    %r14,%rsi
    480a:	callq  2010 <mountpoint_last>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2304
static int filename_mountpoint(int dfd, struct filename *s, struct path *path, unsigned int flags)
    480f:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2303
	if (nd.root.mnt && !(nd.flags & LOOKUP_ROOT))
		path_put(&nd.root);

	return err;
}

    4811:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2304
static int filename_mountpoint(int dfd, struct filename *s, struct path *path, unsigned int flags)
    4813:	jle    47bb <path_mountpoint+0x9b>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    4815:	mov    %gs:0x0,%r15
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    481e:	add    $0x4a8,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

	touch_atime(link);
	nd_set_link(nd, NULL);

    4825:	mov    %r15,0x10(%rsp)
    482a:	nopw   0x0(%rax,%rax,1)
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2306
	return err;
}

static int filename_mountpoint(int dfd, struct filename *s, struct path *path, unsigned int flags)
{
	int error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_RCU);
    4830:	mov    (%r14),%rax
    4833:	mov    0x8(%r14),%rdx
    4837:	mov    %rax,0x20(%rsp)
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:735
	const struct inode *parent;

	if (!sysctl_protected_symlinks)
		return 0;

	/* Allowed if owner and follower match. */
    483c:	mov    0x0(%rip),%eax        # 4842 <path_mountpoint+0x122>
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2306
	return err;
}

static int filename_mountpoint(int dfd, struct filename *s, struct path *path, unsigned int flags)
{
	int error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_RCU);
    4842:	mov    %rdx,0x28(%rsp)
    4847:	mov    0x28(%rsp),%r12
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:735
	const struct inode *parent;

	if (!sysctl_protected_symlinks)
		return 0;

	/* Allowed if owner and follower match. */
    484c:	test   %eax,%eax
    484e:	je     48bb <path_mountpoint+0x19b>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4850:	mov    %gs:0x0,%rdx
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:739
	inode = link->dentry->d_inode;
	if (uid_eq(current_cred()->fsuid, inode->i_uid))
		return 0;

    4859:	mov    0x30(%r12),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
	/* Allowed if parent directory not sticky and world-writable. */
    485e:	add    $0x4a8,%rdx
    4865:	mov    $0x0,%rax
    486c:	jmp    4878 <path_mountpoint+0x158>
    486e:	xchg   %ax,%ax
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4870:	test   %cl,%cl
    4872:	je     4a20 <path_mountpoint+0x300>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4878:	add    $0x1,%rdx
    487c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    4880:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    4884:	cmp    -0x1(%rax),%cl
    4887:	je     4870 <path_mountpoint+0x150>
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
    4889:	mov    %gs:0x0,%rax
    4892:	mov    0x4a0(%rax),%rax
    4899:	mov    0x4(%rsi),%edx
    489c:	cmp    %edx,0x1c(%rax)
    489f:	je     48bb <path_mountpoint+0x19b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:744
	parent = nd->path.dentry->d_inode;
	if ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
		return 0;

    48a1:	mov    0x38(%rsp),%rax
    48a6:	mov    0x30(%rax),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:745
	/* Allowed if parent directory and link owner match. */
    48aa:	movzwl (%rcx),%eax
    48ad:	and    $0x202,%ax
    48b1:	cmp    $0x202,%ax
    48b5:	je     4a60 <path_mountpoint+0x340>
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2310
{
	int error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_RCU);
	if (unlikely(error == -ECHILD))
		error = path_mountpoint(dfd, s->name, path, flags);
	if (unlikely(error == -ESTALE))
		error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_REVAL);
    48bb:	mov    0x68(%rsp),%eax
    48bf:	mov    %eax,%edx
    48c1:	or     $0x10,%edx
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    48c4:	test   $0x40,%al
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2310
{
	int error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_RCU);
	if (unlikely(error == -ECHILD))
		error = path_mountpoint(dfd, s->name, path, flags);
	if (unlikely(error == -ESTALE))
		error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_REVAL);
    48c6:	mov    %edx,0x68(%rsp)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    48ca:	jne    4c7a <path_mountpoint+0x55a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:836
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
    48d0:	mov    0x20(%rsp),%rdi
    48d5:	cmp    0x30(%rsp),%rdi
    48da:	je     4b18 <path_mountpoint+0x3f8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    48e0:	mov    %r15,%rdi
    48e3:	callq  1370 <my_strcmp_base.constprop.35>
    48e8:	test   %eax,%eax
    48ea:	jne    48fc <path_mountpoint+0x1dc>
    48ec:	cmpb   $0x0,0x0(%rip)        # 48f3 <path_mountpoint+0x1d3>
    48f3:	mov    0x0(%rip),%rax        # 48fa <path_mountpoint+0x1da>
    48fa:	jne    4905 <path_mountpoint+0x1e5>
    48fc:	mov    %gs:0x0,%rax
    4905:	cmpl   $0x27,0x4bc(%rax)
    490c:	jg     4c7c <path_mountpoint+0x55c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:843

	touch_atime(link);
	nd_set_link(nd, NULL);
    4912:	callq  4917 <path_mountpoint+0x1f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

    4917:	mov    0x10(%rsp),%rdi
    491c:	callq  1370 <my_strcmp_base.constprop.35>
    4921:	test   %eax,%eax
    4923:	jne    4935 <path_mountpoint+0x215>
    4925:	cmpb   $0x0,0x0(%rip)        # 492c <path_mountpoint+0x20c>
    492c:	mov    0x0(%rip),%rax        # 4933 <path_mountpoint+0x213>
    4933:	jne    493e <path_mountpoint+0x21e>
    4935:	mov    %gs:0x0,%rax
    493e:	addl   $0x1,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:846
	// error = security_inode_follow_link(link->dentry, nd);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    4945:	lea    0x20(%rsp),%r13
    494a:	mov    %r13,%rdi
    494d:	callq  4952 <path_mountpoint+0x232>
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88

extern void nd_jump_link(struct nameidata *nd, struct path *path);

static inline void nd_set_link(struct nameidata *nd, char *path)
{
	nd->saved_names[nd->depth] = path;
    4952:	mov    0x78(%rsp),%eax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    4956:	mov    %gs:0x0,%rdi
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
    495f:	add    $0x4a8,%rdi
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88
    4966:	movq   $0x0,0x80(%rsp,%rax,8)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    4972:	callq  1330 <my_strcmp.constprop.33>
    4977:	test   %eax,%eax
    4979:	jne    4a40 <path_mountpoint+0x320>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:857

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;
    497f:	movl   $0x4,0x74(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858

    4987:	mov    0x30(%r12),%rax
    498c:	mov    %r12,%rdi
    498f:	lea    0x30(%rsp),%rsi
    4994:	mov    0x20(%rax),%rax
    4998:	callq  *0x8(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	error = 0;
	s = nd_get_link(nd);
    499b:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858
	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;

    49a1:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	error = 0;
	s = nd_get_link(nd);
    49a4:	jbe    4ab0 <path_mountpoint+0x390>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:859
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;

	error = 0;
    49aa:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}

    49ac:	lea    0x30(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:887
out_put_nd_path:
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}
    49b1:	xor    %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888

    49b4:	callq  49b9 <path_mountpoint+0x299>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:889
static int follow_up_rcu(struct path *path)
    49b9:	mov    %r13,%rdi
    49bc:	callq  49c1 <path_mountpoint+0x2a1>
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2312
	if (unlikely(error == -ECHILD))
		error = path_mountpoint(dfd, s->name, path, flags);
	if (unlikely(error == -ESTALE))
		error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_REVAL);
	if (likely(!error))
		audit_inode(s, path->dentry, 0);
    49c1:	test   %ebx,%ebx
    49c3:	jne    47bb <path_mountpoint+0x9b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2314
	return error;
}
    49c9:	lea    0x30(%rsp),%rdi
    49ce:	mov    %r14,%rsi
    49d1:	callq  2010 <mountpoint_last>
put_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:705
static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
{
	struct inode *inode = link->dentry->d_inode;
	if (inode->i_op->put_link)
		inode->i_op->put_link(link->dentry, nd, cookie);
	path_put(link);
    49d6:	mov    0x28(%rsp),%rdi
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2314
	if (unlikely(error == -ESTALE))
		error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_REVAL);
	if (likely(!error))
		audit_inode(s, path->dentry, 0);
	return error;
}
    49db:	mov    %eax,%ebx
put_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:706
{
	struct inode *inode = link->dentry->d_inode;
	if (inode->i_op->put_link)
		inode->i_op->put_link(link->dentry, nd, cookie);
	path_put(link);
}
    49dd:	mov    0x30(%rdi),%rax
    49e1:	mov    0x20(%rax),%rax
    49e5:	mov    0x28(%rax),%rax
    49e9:	test   %rax,%rax
    49ec:	je     49fd <path_mountpoint+0x2dd>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:707

    49ee:	mov    %r12,%rdx
    49f1:	lea    0x30(%rsp),%rsi
    49f6:	callq  *%rax
    49f8:	mov    0x28(%rsp),%rdi
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    49fd:	callq  4a02 <path_mountpoint+0x2e2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    4a02:	mov    0x20(%rsp),%rdi
    4a07:	callq  4a0c <path_mountpoint+0x2ec>
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2304
		path_put(&nd.root);

	return err;
}

static int filename_mountpoint(int dfd, struct filename *s, struct path *path, unsigned int flags)
    4a0c:	test   %ebx,%ebx
    4a0e:	jg     4830 <path_mountpoint+0x110>
    4a14:	jmpq   47bb <path_mountpoint+0x9b>
    4a19:	nopl   0x0(%rax)
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
	/* Allowed if owner and follower match. */
	inode = link->dentry->d_inode;
	if (uid_eq(current_cred()->fsuid, inode->i_uid))
		return 0;

	/* Allowed if parent directory not sticky and world-writable. */
    4a20:	cmpb   $0x0,0x0(%rip)        # 4a27 <path_mountpoint+0x307>
    4a27:	mov    0x0(%rip),%rax        # 4a2e <path_mountpoint+0x30e>
    4a2e:	jne    4892 <path_mountpoint+0x172>
    4a34:	jmpq   4889 <path_mountpoint+0x169>
    4a39:	nopl   0x0(%rax)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    4a40:	mov    0x28(%rsp),%rdi
    4a45:	lea    0x30(%rsp),%rsi
    4a4a:	callq  4a4f <path_mountpoint+0x32f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    4a4f:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    4a51:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    4a53:	jne    49ac <path_mountpoint+0x28c>
    4a59:	jmpq   497f <path_mountpoint+0x25f>
    4a5e:	xchg   %ax,%ax
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:749

	/* Allowed if parent directory and link owner match. */
	if (uid_eq(parent->i_uid, inode->i_uid))
		return 0;

	audit_log_link_denied("follow_link", link);
    4a60:	cmp    0x4(%rcx),%edx
    4a63:	je     48bb <path_mountpoint+0x19b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:752
	path_put_conditional(link, nd);
	path_put(&nd->path);
	return -EACCES;
    4a69:	lea    0x20(%rsp),%rsi
    4a6e:	mov    $0x0,%rdi
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
EXPORT_SYMBOL(path_put);
    4a75:	mov    $0xfffffff3,%ebx
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:752
		return 0;

	audit_log_link_denied("follow_link", link);
	path_put_conditional(link, nd);
	path_put(&nd->path);
	return -EACCES;
    4a7a:	callq  4a7f <path_mountpoint+0x35f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:753
}
    4a7f:	lea    0x30(%rsp),%rsi
    4a84:	lea    0x20(%rsp),%rdi
    4a89:	callq  d10 <path_put_conditional.isra.13>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    4a8e:	mov    0x38(%rsp),%rdi
    4a93:	callq  4a98 <path_mountpoint+0x378>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    4a98:	mov    0x30(%rsp),%rdi
    4a9d:	callq  4aa2 <path_mountpoint+0x382>
    4aa2:	jmpq   47bb <path_mountpoint+0x9b>
    4aa7:	nopw   0x0(%rax,%rax,1)
nd_get_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:93
}

static inline char *nd_get_link(struct nameidata *nd)
{
	return nd->saved_names[nd->depth];
    4ab0:	mov    0x78(%rsp),%eax
    4ab4:	mov    0x80(%rsp,%rax,8),%rbx
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:865
	s = nd_get_link(nd);
	if (s) {
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
    4abc:	test   %rbx,%rbx
    4abf:	je     49c9 <path_mountpoint+0x2a9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:866
		}
    4ac5:	cmp    $0xfffffffffffff000,%rbx
    4acc:	ja     4cba <path_mountpoint+0x59a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:871
		if (*s == '/') {
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
    4ad2:	cmpb   $0x2f,(%rbx)
    4ad5:	je     4b50 <path_mountpoint+0x430>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    4ad7:	mov    0x38(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    4adc:	lea    0x30(%rsp),%rsi
    4ae1:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    4ae4:	mov    0x30(%rax),%rax
    4ae8:	mov    %rax,0x60(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    4aed:	callq  2e30 <link_path_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    4af2:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}

    4af4:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    4af6:	je     49c9 <path_mountpoint+0x2a9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:881

    4afc:	lea    0x30(%rsp),%rdi
    4b01:	mov    %r12,%rdx
    4b04:	mov    %r13,%rsi
    4b07:	callq  220 <put_link>
    4b0c:	jmpq   47bb <path_mountpoint+0x9b>
    4b11:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:837
	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;
    4b18:	callq  4b1d <path_mountpoint+0x3fd>
    4b1d:	nopl   (%rax)
    4b20:	jmpq   48e0 <path_mountpoint+0x1c0>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    4b25:	mov    0x58(%rsp),%rdi
    4b2a:	mov    %ebx,0x10(%rsp)
    4b2e:	callq  4b33 <path_mountpoint+0x413>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    4b33:	mov    0x50(%rsp),%rdi
    4b38:	callq  4b3d <path_mountpoint+0x41d>
    4b3d:	mov    0x10(%rsp),%eax
path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2325
 * @flags:	lookup flags
 * @path:	pointer to container to hold result
 *
 * A umount is a special case for path walking. We're not actually interested
 * in the inode in this situation, and ESTALE errors can be a problem. We
 * simply want track down the dentry and vfsmount attached at the mountpoint
    4b41:	lea    -0x28(%rbp),%rsp
    4b45:	pop    %rbx
    4b46:	pop    %r12
    4b48:	pop    %r13
    4b4a:	pop    %r14
    4b4c:	pop    %r15
    4b4e:	pop    %rbp
    4b4f:	retq   
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    4b50:	cmpq   $0x0,0x50(%rsp)
    4b56:	je     4b8d <path_mountpoint+0x46d>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:873
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
    4b58:	lea    0x30(%rsp),%rdi
    4b5d:	callq  4b62 <path_mountpoint+0x442>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
		nd->inode = nd->path.dentry->d_inode;
    4b62:	mov    0x50(%rsp),%rax
    4b67:	mov    0x58(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    4b6c:	lea    0x50(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
		nd->inode = nd->path.dentry->d_inode;
    4b71:	mov    %rax,0x30(%rsp)
    4b76:	mov    %rdx,0x38(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    4b7b:	callq  4b80 <path_mountpoint+0x460>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:876
		if (unlikely(error))
    4b80:	orl    $0x1000,0x68(%rsp)
    4b88:	jmpq   4ad7 <path_mountpoint+0x3b7>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4b8d:	mov    %gs:0x0,%rdi
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652
static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}

    4b96:	add    $0x4a8,%rdi
    4b9d:	callq  1370 <my_strcmp_base.constprop.35>
    4ba2:	test   %eax,%eax
    4ba4:	jne    4bb6 <path_mountpoint+0x496>
    4ba6:	cmpb   $0x0,0x0(%rip)        # 4bad <path_mountpoint+0x48d>
    4bad:	mov    0x0(%rip),%rax        # 4bb4 <path_mountpoint+0x494>
    4bb4:	jne    4bbf <path_mountpoint+0x49f>
    4bb6:	mov    %gs:0x0,%rax
    4bbf:	mov    0x588(%rax),%rdx
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    4bc6:	lea    0x4(%rdx),%rax
    4bca:	mov    %rdx,(%rsp)
    4bce:	mov    %rax,%rdi
    4bd1:	mov    %rax,0x8(%rsp)
    4bd6:	callq  4bdb <path_mountpoint+0x4bb>
get_fs_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs_struct.h:29
    4bdb:	mov    (%rsp),%rdx
    4bdf:	mov    0x18(%rdx),%rax
    4be3:	mov    0x20(%rdx),%rdx
    4be7:	mov    %rax,%rdi
    4bea:	mov    %rdx,0x58(%rsp)
    4bef:	mov    %rax,0x50(%rsp)
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:475
 */
void path_get(const struct path *path)
{
	mntget(path->mnt);
	dget(path->dentry);
}
    4bf4:	callq  4bf9 <path_mountpoint+0x4d9>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4bf9:	mov    %gs:0x0,%rdx
path_get():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:476
EXPORT_SYMBOL(path_get);
    4c02:	mov    0x58(%rsp),%r8
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    4c07:	add    $0x4a8,%rdx
    4c0e:	mov    $0x0,%rax
    4c15:	jmp    4c1b <path_mountpoint+0x4fb>
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4c17:	test   %cl,%cl
    4c19:	je     4c8b <path_mountpoint+0x56b>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4c1b:	add    $0x1,%rdx
    4c1f:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    4c23:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    4c27:	cmp    -0x1(%rax),%cl
    4c2a:	je     4c17 <path_mountpoint+0x4f7>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4c2c:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    4c35:	mov    $0x0,%rax
    4c3c:	add    $0x4a8,%rdx
    4c43:	jmp    4c4c <path_mountpoint+0x52c>
    4c45:	nopl   (%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4c48:	test   %cl,%cl
    4c4a:	je     4c8b <path_mountpoint+0x56b>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4c4c:	add    $0x1,%rdx
    4c50:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    4c54:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    4c58:	cmp    -0x1(%rax),%cl
    4c5b:	je     4c48 <path_mountpoint+0x528>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    4c5d:	test   %r8,%r8
    4c60:	je     4c6b <path_mountpoint+0x54b>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    4c62:	lea    0x58(%r8),%rdi
    4c66:	callq  4c6b <path_mountpoint+0x54b>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    4c6b:	mov    0x8(%rsp),%rdi
    4c70:	callq  4c75 <path_mountpoint+0x555>
    4c75:	jmpq   4b58 <path_mountpoint+0x438>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    4c7a:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:839
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
    4c7c:	mov    $0xffffffd8,%ebx
    4c81:	lea    0x20(%rsp),%r13
    4c86:	jmpq   49ac <path_mountpoint+0x28c>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4c8b:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    4c94:	mov    $0x0,%rsi
    4c9b:	add    $0x4a8,%rdx
    4ca2:	mov    $0x0,%rdi
    4ca9:	xor    %eax,%eax
    4cab:	mov    %r8,(%rsp)
    4caf:	callq  4cb4 <path_mountpoint+0x594>
    4cb4:	mov    (%rsp),%r8
    4cb8:	jmp    4c5d <path_mountpoint+0x53d>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:867
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
		}
		if (*s == '/') {
    4cba:	lea    0x30(%rsp),%rdi
    4cbf:	callq  4cc4 <path_mountpoint+0x5a4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:868
			set_root(nd);
    4cc4:	lea    0x30(%rsp),%rdi
    4cc9:	mov    %r12,%rdx
    4ccc:	mov    %r13,%rsi
    4ccf:	callq  220 <put_link>
    4cd4:	jmpq   49c1 <path_mountpoint+0x2a1>
path_mountpoint():
    4cd9:	nopl   0x0(%rax)

0000000000004ce0 <filename_mountpoint>:
filename_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2330
 * simply want track down the dentry and vfsmount attached at the mountpoint
 * and avoid revalidating the last component.
 *
 * Returns 0 and populates "path" on success.
 */
int user_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags, struct path *path)
    4ce0:	callq  4ce5 <filename_mountpoint+0x5>
    4ce5:	push   %rbp
    4ce6:	mov    %rsp,%rbp
    4ce9:	push   %r15
    4ceb:	mov    %ecx,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2331
{
    4cee:	or     $0x40,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2330
 * simply want track down the dentry and vfsmount attached at the mountpoint
 * and avoid revalidating the last component.
 *
 * Returns 0 and populates "path" on success.
 */
int user_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags, struct path *path)
    4cf1:	push   %r14
    4cf3:	mov    %edi,%r14d
    4cf6:	push   %r13
    4cf8:	mov    %rdx,%r13
    4cfb:	push   %r12
    4cfd:	mov    %rsi,%r12
    4d00:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2331
{
    4d01:	mov    (%rsi),%rsi
    4d04:	callq  4720 <path_mountpoint>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2332
	struct filename *s = getname(name);
    4d09:	cmp    $0xfffffff6,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2331
 * and avoid revalidating the last component.
 *
 * Returns 0 and populates "path" on success.
 */
int user_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags, struct path *path)
{
    4d0c:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2332
	struct filename *s = getname(name);
    4d0e:	je     4e66 <filename_mountpoint+0x186>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2334
	int error;
	if (IS_ERR(s))
    4d14:	cmp    $0xffffff8c,%ebx
    4d17:	je     4e4a <filename_mountpoint+0x16a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2336
		return PTR_ERR(s);
	error = filename_mountpoint(dfd, s, path, flags);
    4d1d:	test   %ebx,%ebx
    4d1f:	jne    4df8 <filename_mountpoint+0x118>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4d25:	mov    %gs:0x0,%rcx
filename_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2337
	putname(s);
    4d2e:	mov    0x8(%r13),%r13
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    4d32:	add    $0x4a8,%rcx
    4d39:	mov    $0x0,%rdx
    4d40:	jmp    4d50 <filename_mountpoint+0x70>
    4d42:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4d48:	test   %al,%al
    4d4a:	je     4e20 <filename_mountpoint+0x140>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4d50:	add    $0x1,%rcx
    4d54:	movzbl -0x1(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    4d58:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    4d5c:	cmp    -0x1(%rdx),%al
    4d5f:	je     4d48 <filename_mountpoint+0x68>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4d61:	mov    %gs:0x0,%rcx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    4d6a:	mov    $0x0,%rdx
    4d71:	add    $0x4a8,%rcx
    4d78:	jmp    4d88 <filename_mountpoint+0xa8>
    4d7a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4d80:	test   %al,%al
    4d82:	je     4e20 <filename_mountpoint+0x140>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4d88:	add    $0x1,%rcx
    4d8c:	movzbl -0x1(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    4d90:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    4d94:	cmp    -0x1(%rdx),%al
    4d97:	je     4d80 <filename_mountpoint+0xa0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    4d99:	mov    %gs:0x0,%rcx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    4da2:	mov    $0x0,%rdx
    4da9:	add    $0x4a8,%rcx
    4db0:	jmp    4dbd <filename_mountpoint+0xdd>
    4db2:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    4db8:	test   %r8b,%r8b
    4dbb:	je     4e08 <filename_mountpoint+0x128>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    4dbd:	add    $0x1,%rcx
    4dc1:	movzbl -0x1(%rcx),%r8d
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    4dc6:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    4dca:	cmp    -0x1(%rdx),%r8b
    4dce:	je     4db8 <filename_mountpoint+0xd8>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    4dd0:	mov    %gs:0x0,%rax
    4dd9:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    4de0:	test   %rax,%rax
    4de3:	je     4df8 <filename_mountpoint+0x118>
    4de5:	mov    (%rax),%eax
    4de7:	test   %eax,%eax
    4de9:	jne    4df8 <filename_mountpoint+0x118>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:167
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context())) {
		unsigned int flags = 0;
		if (parent)
			flags |= AUDIT_INODE_PARENT;
		__audit_inode(name, dentry, flags);
    4deb:	xor    %edx,%edx
    4ded:	mov    %r13,%rsi
    4df0:	mov    %r12,%rdi
    4df3:	callq  4df8 <filename_mountpoint+0x118>
filename_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2339
	return error;
}
    4df8:	mov    %ebx,%eax
    4dfa:	pop    %rbx
    4dfb:	pop    %r12
    4dfd:	pop    %r13
    4dff:	pop    %r14
    4e01:	pop    %r15
    4e03:	pop    %rbp
    4e04:	retq   
    4e05:	nopl   (%rax)
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    4e08:	cmpb   $0x0,0x0(%rip)        # 4e0f <filename_mountpoint+0x12f>
    4e0f:	mov    0x0(%rip),%rax        # 4e16 <filename_mountpoint+0x136>
    4e16:	jne    4dd9 <filename_mountpoint+0xf9>
    4e18:	jmp    4dd0 <filename_mountpoint+0xf0>
    4e1a:	nopw   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    4e20:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    4e29:	mov    $0x0,%rsi
    4e30:	add    $0x4a8,%rdx
    4e37:	mov    $0x0,%rdi
    4e3e:	xor    %eax,%eax
    4e40:	callq  4e45 <filename_mountpoint+0x165>
    4e45:	jmpq   4d99 <filename_mountpoint+0xb9>
filename_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2335
int user_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags, struct path *path)
{
	struct filename *s = getname(name);
	int error;
	if (IS_ERR(s))
		return PTR_ERR(s);
    4e4a:	mov    (%r12),%rsi
    4e4e:	mov    %r15d,%ecx
    4e51:	mov    %r13,%rdx
    4e54:	or     $0x20,%ecx
    4e57:	mov    %r14d,%edi
    4e5a:	callq  4720 <path_mountpoint>
    4e5f:	mov    %eax,%ebx
    4e61:	jmpq   4d1d <filename_mountpoint+0x3d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2333
 * Returns 0 and populates "path" on success.
 */
int user_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags, struct path *path)
{
	struct filename *s = getname(name);
	int error;
    4e66:	mov    (%r12),%rsi
    4e6a:	mov    %r15d,%ecx
    4e6d:	mov    %r13,%rdx
    4e70:	mov    %r14d,%edi
    4e73:	callq  4720 <path_mountpoint>
    4e78:	mov    %eax,%ebx
    4e7a:	jmpq   4d14 <filename_mountpoint+0x34>
    4e7f:	nop

0000000000004e80 <kern_path_mountpoint>:
kern_path_mountpoint():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2371
 *	Check whether we can remove a link victim from directory dir, check
 *  whether the type of victim is right.
 *  1. We can't do it if dir is read-only (done in permission())
 *  2. We should have write and exec permissions on dir
 *  3. We can't remove anything from append-only dir
 *  4. We can't do anything with immutable dir (done in permission())
    4e80:	callq  4e85 <kern_path_mountpoint+0x5>
    4e85:	push   %rbp
    4e86:	mov    %rsp,%rbp
    4e89:	sub    $0x20,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2372
 *  5. If the sticky bit on dir is set we should either
    4e8d:	mov    %rsi,-0x20(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2373
 *	a. be owner of dir, or
    4e91:	lea    -0x20(%rbp),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2372
 *  whether the type of victim is right.
 *  1. We can't do it if dir is read-only (done in permission())
 *  2. We should have write and exec permissions on dir
 *  3. We can't remove anything from append-only dir
 *  4. We can't do anything with immutable dir (done in permission())
 *  5. If the sticky bit on dir is set we should either
    4e95:	movq   $0x0,-0x18(%rbp)
    4e9d:	movq   $0x0,-0x10(%rbp)
    4ea5:	movq   $0x0,-0x8(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2373
 *	a. be owner of dir, or
    4ead:	callq  4ce0 <filename_mountpoint>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2374
 *	b. be owner of victim, or
    4eb2:	leaveq 
    4eb3:	retq   
    4eb4:	data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000004ec0 <lookup_one_len>:
lookup_one_len():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2093

	if (unlikely(name[0] == '.')) {
		if (len < 2 || (len == 2 && name[1] == '.'))
			return ERR_PTR(-EACCES);
	}

    4ec0:	callq  4ec5 <lookup_one_len+0x5>
    4ec5:	push   %rbp
    4ec6:	mov    %rsp,%rbp
    4ec9:	push   %r13
    4ecb:	mov    %rsi,%r13
    4ece:	push   %r12
    4ed0:	mov    %edx,%r12d
    4ed3:	push   %rbx
    4ed4:	mov    %rdi,%rbx
    4ed7:	sub    $0x10,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2098
	while (len--) {
		c = *(const unsigned char *)name++;
		if (c == '/' || c == '\0')
			return ERR_PTR(-EACCES);
	}
    4edb:	mov    0x30(%rsi),%rax
atomic_read():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/atomic.h:26
 *
 * Atomically reads the value of @v.
 */
static inline int atomic_read(const atomic_t *v)
{
	return (*(volatile int *)&(v)->counter);
    4edf:	mov    0xa8(%rax),%eax
lookup_one_len():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2098
    4ee5:	cmp    $0x1,%eax
    4ee8:	je     4fb1 <lookup_one_len+0xf1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2102 (discriminator 2)
	/*
	 * See if the low-level filesystem might want
	 * to use its own hash..
	 */
    4eee:	mov    %r12d,%esi
    4ef1:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2100 (discriminator 2)
		c = *(const unsigned char *)name++;
		if (c == '/' || c == '\0')
			return ERR_PTR(-EACCES);
	}
	/*
	 * See if the low-level filesystem might want
    4ef4:	mov    %rbx,-0x20(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2101 (discriminator 2)
	 * to use its own hash..
    4ef8:	mov    %r12d,-0x24(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2102 (discriminator 2)
	 */
    4efc:	callq  4f01 <lookup_one_len+0x41>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2103 (discriminator 2)
	if (base->d_flags & DCACHE_OP_HASH) {
    4f01:	test   %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2102 (discriminator 2)
			return ERR_PTR(-EACCES);
	}
	/*
	 * See if the low-level filesystem might want
	 * to use its own hash..
	 */
    4f04:	mov    %eax,-0x28(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2104 (discriminator 2)
	if (base->d_flags & DCACHE_OP_HASH) {
		int err = base->d_op->d_hash(base, &this);
    4f07:	mov    $0xfffffffffffffff3,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2103 (discriminator 2)
	}
	/*
	 * See if the low-level filesystem might want
	 * to use its own hash..
	 */
	if (base->d_flags & DCACHE_OP_HASH) {
    4f0e:	je     4f6b <lookup_one_len+0xab>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2106
		int err = base->d_op->d_hash(base, &this);
		if (err < 0)
			return ERR_PTR(err);
    4f10:	cmpb   $0x2e,(%rbx)
    4f13:	je     4fdb <lookup_one_len+0x11b>
    4f19:	mov    %r12d,%edx
    4f1c:	add    %rbx,%rdx
    4f1f:	jmp    4f39 <lookup_one_len+0x79>
    4f21:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2112
	}

	err = inode_permission(base->d_inode, MAY_EXEC);
	if (err)
		return ERR_PTR(err);

    4f28:	add    $0x1,%rbx
    4f2c:	movzbl -0x1(%rbx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2113
	return __lookup_hash(&this, base, 0);
    4f30:	test   %eax,%eax
    4f32:	je     4f80 <lookup_one_len+0xc0>
    4f34:	cmp    $0x2f,%eax
    4f37:	je     4f80 <lookup_one_len+0xc0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2111 (discriminator 1)
			return ERR_PTR(err);
	}

	err = inode_permission(base->d_inode, MAY_EXEC);
	if (err)
		return ERR_PTR(err);
    4f39:	cmp    %rdx,%rbx
    4f3c:	jne    4f28 <lookup_one_len+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2120

int user_path_at_empty(int dfd, const char __user *name, unsigned flags, struct path *path, int *empty)
{
	struct nameidata nd;
	struct filename *tmp = getname_flags(name, flags, empty);
	int err = PTR_ERR(tmp);
    4f3e:	testb  $0x1,0x0(%r13)
    4f43:	je     4f57 <lookup_one_len+0x97>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2121
	if (!IS_ERR(tmp)) {
    4f45:	mov    0x60(%r13),%rax
    4f49:	lea    -0x28(%rbp),%rsi
    4f4d:	mov    %r13,%rdi
    4f50:	callq  *0x10(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2122

    4f53:	test   %eax,%eax
    4f55:	js     4f69 <lookup_one_len+0xa9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2126
		BUG_ON(flags & LOOKUP_PARENT);

		err = filename_lookup(dfd, tmp, flags, &nd);
		putname(tmp);
    4f57:	mov    0x30(%r13),%rdi
    4f5b:	mov    $0x1,%esi
    4f60:	callq  4f65 <lookup_one_len+0xa5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2127
		if (!err)
    4f65:	test   %eax,%eax
    4f67:	je     4f98 <lookup_one_len+0xd8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2128
			*path = nd.path;
    4f69:	cltq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2131
	}
	return err;
}
    4f6b:	add    $0x10,%rsp
    4f6f:	pop    %rbx
    4f70:	pop    %r12
    4f72:	pop    %r13
    4f74:	pop    %rbp
    4f75:	retq   
    4f76:	nopw   %cs:0x0(%rax,%rax,1)
    4f80:	add    $0x10,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2104
	/*
	 * See if the low-level filesystem might want
	 * to use its own hash..
	 */
	if (base->d_flags & DCACHE_OP_HASH) {
		int err = base->d_op->d_hash(base, &this);
    4f84:	mov    $0xfffffffffffffff3,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2131
		putname(tmp);
		if (!err)
			*path = nd.path;
	}
	return err;
}
    4f8b:	pop    %rbx
    4f8c:	pop    %r12
    4f8e:	pop    %r13
    4f90:	pop    %rbp
    4f91:	retq   
    4f92:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2130
		err = filename_lookup(dfd, tmp, flags, &nd);
		putname(tmp);
		if (!err)
			*path = nd.path;
	}
	return err;
    4f98:	lea    -0x28(%rbp),%rdi
    4f9c:	mov    %r13,%rsi
    4f9f:	xor    %edx,%edx
    4fa1:	callq  9a0 <__lookup_hash>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2131
}
    4fa6:	add    $0x10,%rsp
    4faa:	pop    %rbx
    4fab:	pop    %r12
    4fad:	pop    %r13
    4faf:	pop    %rbp
    4fb0:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2098 (discriminator 1)

	while (len--) {
		c = *(const unsigned char *)name++;
		if (c == '/' || c == '\0')
			return ERR_PTR(-EACCES);
	}
    4fb1:	cmpb   $0x0,0x0(%rip)        # 4fb8 <lookup_one_len+0xf8>
    4fb8:	jne    4eee <lookup_one_len+0x2e>
    4fbe:	mov    $0x832,%esi
    4fc3:	mov    $0x0,%rdi
    4fca:	callq  4fcf <lookup_one_len+0x10f>
    4fcf:	movb   $0x1,0x0(%rip)        # 4fd6 <lookup_one_len+0x116>
    4fd6:	jmpq   4eee <lookup_one_len+0x2e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2107
	 */
	if (base->d_flags & DCACHE_OP_HASH) {
		int err = base->d_op->d_hash(base, &this);
		if (err < 0)
			return ERR_PTR(err);
	}
    4fdb:	cmp    $0x1,%r12d
    4fdf:	jle    4f6b <lookup_one_len+0xab>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2107 (discriminator 1)
    4fe1:	cmp    $0x2,%r12d
    4fe5:	jne    4f19 <lookup_one_len+0x59>
    4feb:	cmpb   $0x2e,0x1(%rbx)
    4fef:	jne    4f19 <lookup_one_len+0x59>
    4ff5:	jmpq   4f6b <lookup_one_len+0xab>
    4ffa:	nopw   0x0(%rax,%rax,1)

0000000000005000 <may_open>:
may_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2535
	case S_IFSOCK:
		flag &= ~O_TRUNC;
		break;
	}

	error = inode_permission(inode, acc_mode);
    5000:	callq  5005 <may_open+0x5>
    5005:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2541
	if (error)
		return error;

	/*
	 * An append-only file must be opened in append mode for writing.
	 */
    5006:	test   %esi,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2535
	case S_IFSOCK:
		flag &= ~O_TRUNC;
		break;
	}

	error = inode_permission(inode, acc_mode);
    5008:	mov    %rsp,%rbp
    500b:	push   %r12
    500d:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2537
	if (error)
		return error;
    500e:	mov    0x8(%rdi),%rax
    5012:	mov    0x30(%rax),%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2541

	/*
	 * An append-only file must be opened in append mode for writing.
	 */
    5016:	je     50b0 <may_open+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2544
	if (IS_APPEND(inode)) {
		if  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))
			return -EPERM;
    501c:	test   %rbx,%rbx
    501f:	je     5101 <may_open+0x101>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2547
		if (flag & O_TRUNC)
			return -EPERM;
	}
    5025:	movzwl (%rbx),%ecx
    5028:	mov    %edx,%r12d
    502b:	and    $0xf000,%cx
    5030:	cmp    $0x4000,%cx
    5035:	je     50c0 <may_open+0xc0>
    503b:	jbe    50d0 <may_open+0xd0>
    5041:	cmp    $0xa000,%cx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2549

	/* O_NOATIME can only be set by the owner or superuser */
    5046:	mov    $0xffffffd8,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2547
	if (IS_APPEND(inode)) {
		if  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))
			return -EPERM;
		if (flag & O_TRUNC)
			return -EPERM;
	}
    504b:	je     50b2 <may_open+0xb2>
    504d:	cmp    $0xc000,%cx
    5052:	je     50e7 <may_open+0xe7>
    5058:	cmp    $0x6000,%cx
    505d:	je     50de <may_open+0xde>
    505f:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2565
	int error = get_write_access(inode);
	if (error)
		return error;
	/*
	 * Refuse to truncate files with mandatory locks held on them.
	 */
    5060:	mov    %rbx,%rdi
    5063:	callq  5068 <may_open+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2566
	error = locks_verify_locked(inode);
    5068:	test   %eax,%eax
    506a:	jne    50b2 <may_open+0xb2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2572
	if (!error) {
		// error = security_path_truncate(path);
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
      error = security_path_truncate(path);
    else
      error = 0;
    506c:	testb  $0x4,0xc(%rbx)
    5070:	je     508a <may_open+0x8a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2573
  }
    5072:	test   $0x3,%r12b
    5076:	je     5081 <may_open+0x81>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2573 (discriminator 1)
    5078:	test   $0x400,%r12d
    507f:	je     50fa <may_open+0xfa>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2575
	if (!error) {
		error = do_truncate(path->dentry, 0,
    5081:	test   $0x200,%r12d
    5088:	jne    50fa <may_open+0xfa>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2580
				    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,
				    filp);
	}
	put_write_access(inode);
	return error;
    508a:	and    $0x40000,%r12d
    5091:	je     50b0 <may_open+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2580 (discriminator 1)
    5093:	mov    %rbx,%rdi
    5096:	callq  509b <may_open+0x9b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2584 (discriminator 1)
}

static inline int open_to_namei_flags(int flag)
{
    509b:	pop    %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2580 (discriminator 1)
		error = do_truncate(path->dentry, 0,
				    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,
				    filp);
	}
	put_write_access(inode);
	return error;
    509c:	xor    $0x1,%eax
    509f:	movzbl %al,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2584 (discriminator 1)
}

static inline int open_to_namei_flags(int flag)
{
    50a2:	pop    %r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2580 (discriminator 1)
		error = do_truncate(path->dentry, 0,
				    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,
				    filp);
	}
	put_write_access(inode);
	return error;
    50a4:	neg    %eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2584 (discriminator 1)
}

static inline int open_to_namei_flags(int flag)
{
    50a6:	pop    %rbp
    50a7:	retq   
    50a8:	nopl   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2542
		return error;

	/*
	 * An append-only file must be opened in append mode for writing.
	 */
	if (IS_APPEND(inode)) {
    50b0:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2584
	put_write_access(inode);
	return error;
}

static inline int open_to_namei_flags(int flag)
{
    50b2:	pop    %rbx
    50b3:	pop    %r12
    50b5:	pop    %rbp
    50b6:	retq   
    50b7:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2551
			return -EPERM;
	}

	/* O_NOATIME can only be set by the owner or superuser */
	if (flag & O_NOATIME && !inode_owner_or_capable(inode))
		return -EPERM;
    50c0:	test   $0x2,%sil
    50c4:	je     5060 <may_open+0x60>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2552

    50c6:	mov    $0xffffffeb,%eax
    50cb:	jmp    50b2 <may_open+0xb2>
    50cd:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2547
	if (IS_APPEND(inode)) {
		if  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))
			return -EPERM;
		if (flag & O_TRUNC)
			return -EPERM;
	}
    50d0:	cmp    $0x1000,%cx
    50d5:	je     50e7 <may_open+0xe7>
    50d7:	cmp    $0x2000,%cx
    50dc:	jne    5060 <may_open+0x60>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2556
		return -EPERM;

	return 0;
}

static int handle_truncate(struct file *filp)
    50de:	mov    (%rdi),%rax
    50e1:	testb  $0x2,0x10(%rax)
    50e5:	jne    50f3 <may_open+0xf3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2561
{
	struct path *path = &filp->f_path;
	struct inode *inode = path->dentry->d_inode;
	int error = get_write_access(inode);
	if (error)
    50e7:	and    $0xfffffdff,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2562
		return error;
    50ee:	jmpq   5060 <may_open+0x60>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2557

	return 0;
}

static int handle_truncate(struct file *filp)
{
    50f3:	mov    $0xfffffff3,%eax
    50f8:	jmp    50b2 <may_open+0xb2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2574
    if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
      error = security_path_truncate(path);
    else
      error = 0;
  }
	if (!error) {
    50fa:	mov    $0xffffffff,%eax
    50ff:	jmp    50b2 <may_open+0xb2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2545
	 * An append-only file must be opened in append mode for writing.
	 */
	if (IS_APPEND(inode)) {
		if  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))
			return -EPERM;
		if (flag & O_TRUNC)
    5101:	mov    $0xfffffffe,%eax
    5106:	jmp    50b2 <may_open+0xb2>
    5108:	nopl   0x0(%rax,%rax,1)

0000000000005110 <may_delete>:
may_delete():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2414
			return -EBUSY;
	} else if (d_is_directory(victim) || d_is_autodir(victim))
		return -EISDIR;
	if (IS_DEADDIR(dir))
		return -ENOENT;
	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
    5110:	callq  5115 <may_delete+0x5>
    5115:	push   %rbp
    5116:	mov    %rsp,%rbp
    5119:	push   %r14
    511b:	push   %r13
    511d:	mov    %rsi,%r13
    5120:	push   %r12
    5122:	push   %rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2418
		return -EBUSY;
	return 0;
}

    5123:	testl  $0x700000,(%rsi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2415
	} else if (d_is_directory(victim) || d_is_autodir(victim))
		return -EISDIR;
	if (IS_DEADDIR(dir))
		return -ENOENT;
	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
		return -EBUSY;
    5129:	mov    0x30(%rsi),%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2418
	return 0;
}

    512d:	je     5377 <may_delete+0x267>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2420
/*	Check whether we can create an object with dentry child in directory
 *  dir.
    5133:	test   %rbx,%rbx
    5136:	je     53bc <may_delete+0x2ac>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2422
 *  1. We can't do it if child already exists (open has special treatment for
 *     this case, but since we are inlined it's OK)
    513c:	mov    0x18(%rsi),%rax
    5140:	mov    0x30(%rax),%r14
    5144:	cmp    %rdi,%r14
    5147:	jne    53ba <may_delete+0x2aa>
    514d:	mov    %edx,%r12d
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    5150:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5157:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    5160:	add    $0x4a8,%rdx
    5167:	jmp    5178 <may_delete+0x68>
    5169:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5170:	test   %cl,%cl
    5172:	je     5390 <may_delete+0x280>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5178:	add    $0x1,%rdx
    517c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5180:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5184:	cmp    -0x1(%rax),%cl
    5187:	je     5170 <may_delete+0x60>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5189:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    5192:	mov    $0x0,%rax
    5199:	add    $0x4a8,%rdx
    51a0:	jmp    51b0 <may_delete+0xa0>
    51a2:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    51a8:	test   %cl,%cl
    51aa:	je     5390 <may_delete+0x280>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    51b0:	add    $0x1,%rdx
    51b4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    51b8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    51bc:	cmp    -0x1(%rax),%cl
    51bf:	je     51a8 <may_delete+0x98>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    51c1:	mov    %gs:0x0,%rcx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    51ca:	mov    $0x0,%rax
    51d1:	add    $0x4a8,%rcx
    51d8:	jmp    51e8 <may_delete+0xd8>
    51da:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    51e0:	test   %dl,%dl
    51e2:	je     5310 <may_delete+0x200>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    51e8:	add    $0x1,%rcx
    51ec:	movzbl -0x1(%rcx),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    51f0:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    51f4:	cmp    -0x1(%rax),%dl
    51f7:	je     51e0 <may_delete+0xd0>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    51f9:	mov    %gs:0x0,%rax
    5202:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    5209:	test   %rax,%rax
    520c:	je     5224 <may_delete+0x114>
    520e:	mov    (%rax),%eax
    5210:	test   %eax,%eax
    5212:	jne    5224 <may_delete+0x114>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    5214:	mov    $0x3,%edx
    5219:	mov    %r13,%rsi
    521c:	mov    %r14,%rdi
    521f:	callq  5224 <may_delete+0x114>
may_delete():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2425
 *  2. We can't do it if dir is read-only (done in permission())
 *  3. We should have write and exec permissions on dir
 *  4. We can't do it if dir is immutable (done in permission())
    5224:	mov    $0x3,%esi
    5229:	mov    %r14,%rdi
    522c:	callq  5231 <may_delete+0x121>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2426
 */
    5231:	test   %eax,%eax
    5233:	jne    5307 <may_delete+0x1f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2428
static inline int may_create(struct inode *dir, struct dentry *child)
{
    5239:	testb  $0x4,0xc(%r14)
    523e:	jne    5370 <may_delete+0x260>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    5244:	mov    %gs:0x0,%rdx
check_sticky():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2383
 *  7. If we were asked to remove a directory and victim isn't one - ENOTDIR.
 *  8. If we were asked to remove a non-directory and victim isn't one - EISDIR.
 *  9. We can't remove a root or mountpoint.
 * 10. We don't allow removal of NFS sillyrenamed files; it's handled by
 *     nfs_async_unlink().
 */
    524d:	mov    $0x0,%rax
    5254:	add    $0x4a8,%rdx
    525b:	jmp    5268 <may_delete+0x158>
    525d:	nopl   (%rax)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5260:	test   %cl,%cl
    5262:	je     5330 <may_delete+0x220>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5268:	add    $0x1,%rdx
    526c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    5270:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    5274:	cmp    -0x1(%rax),%cl
    5277:	je     5260 <may_delete+0x150>
check_sticky():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2383
    5279:	mov    %gs:0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2385
static int may_delete(struct inode *dir, struct dentry *victim, bool isdir)
{
    5282:	testw  $0x200,(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2383
 *  7. If we were asked to remove a directory and victim isn't one - ENOTDIR.
 *  8. If we were asked to remove a non-directory and victim isn't one - EISDIR.
 *  9. We can't remove a root or mountpoint.
 * 10. We don't allow removal of NFS sillyrenamed files; it's handled by
 *     nfs_async_unlink().
 */
    5288:	mov    0x4a0(%rax),%rax
    528f:	mov    0x1c(%rax),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2385
static int may_delete(struct inode *dir, struct dentry *victim, bool isdir)
{
    5292:	je     52b4 <may_delete+0x1a4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2387
	struct inode *inode = victim->d_inode;
	int error;
    5294:	cmp    0x4(%rbx),%eax
    5297:	je     52b4 <may_delete+0x1a4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2389

	if (d_is_negative(victim))
    5299:	cmp    0x4(%r14),%eax
    529d:	je     52b4 <may_delete+0x1a4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2391
		return -ENOENT;
	BUG_ON(!inode);
    529f:	mov    $0x3,%esi
    52a4:	mov    %rbx,%rdi
    52a7:	callq  52ac <may_delete+0x19c>
may_delete():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2431
 */
static inline int may_create(struct inode *dir, struct dentry *child)
{
	// audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);
	msg_audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	if (child->d_inode)
    52ac:	test   %al,%al
    52ae:	je     5370 <may_delete+0x260>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2432
		return -EEXIST;
    52b4:	testl  $0x10c,0xc(%rbx)
    52bb:	jne    5370 <may_delete+0x260>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2434
	if (IS_DEADDIR(dir))
		return -ENOENT;
    52c1:	test   %r12b,%r12b
    52c4:	je     5350 <may_delete+0x240>
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    52ca:	mov    0x0(%r13),%edx
    52ce:	and    $0x700000,%edx
may_delete():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2435
	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
    52d4:	cmp    $0x100000,%edx
    52da:	je     52e9 <may_delete+0x1d9>
    52dc:	cmp    $0x200000,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2436
}
    52e2:	mov    $0xffffffec,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2435
	msg_audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
	if (child->d_inode)
		return -EEXIST;
	if (IS_DEADDIR(dir))
		return -ENOENT;
	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
    52e7:	jne    5307 <may_delete+0x1f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2437
}

    52e9:	cmp    %r13,0x18(%r13)
    52ed:	je     5381 <may_delete+0x271>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2441
/*
 * p1 and p2 should be directories on the same fs.
 */
struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)
    52f3:	testb  $0x10,0xc(%r14)
    52f8:	jne    5377 <may_delete+0x267>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2443
{
	struct dentry *p;
    52fa:	mov    0x0(%r13),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2438
	if (IS_DEADDIR(dir))
		return -ENOENT;
	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
}

/*
    52fe:	shl    $0x13,%eax
    5301:	sar    $0x1f,%eax
    5304:	and    $0xfffffff0,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2446
struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)
{
	struct dentry *p;

	if (p1 == p2) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
    5307:	pop    %rbx
    5308:	pop    %r12
    530a:	pop    %r13
    530c:	pop    %r14
    530e:	pop    %rbp
    530f:	retq   
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    5310:	cmpb   $0x0,0x0(%rip)        # 5317 <may_delete+0x207>
    5317:	mov    0x0(%rip),%rax        # 531e <may_delete+0x20e>
    531e:	jne    5202 <may_delete+0xf2>
    5324:	jmpq   51f9 <may_delete+0xe9>
    5329:	nopl   0x0(%rax)
check_sticky():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2383
 *  7. If we were asked to remove a directory and victim isn't one - ENOTDIR.
 *  8. If we were asked to remove a non-directory and victim isn't one - EISDIR.
 *  9. We can't remove a root or mountpoint.
 * 10. We don't allow removal of NFS sillyrenamed files; it's handled by
 *     nfs_async_unlink().
 */
    5330:	cmpb   $0x0,0x0(%rip)        # 5337 <may_delete+0x227>
    5337:	mov    0x0(%rip),%rax        # 533e <may_delete+0x22e>
    533e:	jne    5282 <may_delete+0x172>
    5344:	jmpq   5279 <may_delete+0x169>
    5349:	nopl   0x0(%rax)
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    5350:	mov    0x0(%r13),%eax
    5354:	and    $0x700000,%eax
may_delete():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2439
		return -ENOENT;
	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
}

/*
 * p1 and p2 should be directories on the same fs.
    5359:	cmp    $0x100000,%eax
    535e:	je     5367 <may_delete+0x257>
    5360:	cmp    $0x200000,%eax
    5365:	jne    52f3 <may_delete+0x1e3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2440
 */
    5367:	mov    $0xffffffeb,%eax
    536c:	jmp    5307 <may_delete+0x1f7>
    536e:	xchg   %ax,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2429
 *  3. We should have write and exec permissions on dir
 *  4. We can't do it if dir is immutable (done in permission())
 */
static inline int may_create(struct inode *dir, struct dentry *child)
{
	// audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);
    5370:	mov    $0xffffffff,%eax
    5375:	jmp    5307 <may_delete+0x1f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2419
	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
		return -EBUSY;
	return 0;
}

/*	Check whether we can create an object with dentry child in directory
    5377:	mov    $0xfffffffe,%eax
    537c:	jmpq   5307 <may_delete+0x1f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2438
	if (IS_DEADDIR(dir))
		return -ENOENT;
	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
}

/*
    5381:	mov    $0xfffffff0,%eax
    5386:	jmpq   5307 <may_delete+0x1f7>
    538b:	nopl   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    5390:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    5399:	mov    $0x0,%rsi
    53a0:	add    $0x4a8,%rdx
    53a7:	mov    $0x0,%rdi
    53ae:	xor    %eax,%eax
    53b0:	callq  53b5 <may_delete+0x2a5>
    53b5:	jmpq   51c1 <may_delete+0xb1>
may_delete():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2422 (discriminator 1)
}

/*	Check whether we can create an object with dentry child in directory
 *  dir.
 *  1. We can't do it if child already exists (open has special treatment for
 *     this case, but since we are inlined it's OK)
    53ba:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2420 (discriminator 1)
		return -EBUSY;
	return 0;
}

/*	Check whether we can create an object with dentry child in directory
 *  dir.
    53bc:	ud2    
    53be:	xchg   %ax,%ax

00000000000053c0 <vfs_rmdir>:
vfs_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3571
retry:
	name = user_path_parent(dfd, pathname, &nd, lookup_flags);
	if (IS_ERR(name))
		return PTR_ERR(name);

	switch(nd.last_type) {
    53c0:	callq  53c5 <vfs_rmdir+0x5>
    53c5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3572
	case LAST_DOTDOT:
    53c6:	mov    $0x1,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3571
retry:
	name = user_path_parent(dfd, pathname, &nd, lookup_flags);
	if (IS_ERR(name))
		return PTR_ERR(name);

	switch(nd.last_type) {
    53cb:	mov    %rsp,%rbp
    53ce:	push   %r13
    53d0:	push   %r12
    53d2:	mov    %rsi,%r12
    53d5:	push   %rbx
    53d6:	mov    %rdi,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3572
	case LAST_DOTDOT:
    53d9:	callq  5110 <may_delete>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3574
		error = -ENOTEMPTY;
		goto exit1;
    53de:	test   %eax,%eax
    53e0:	jne    54ad <vfs_rmdir+0xed>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3577
	case LAST_DOT:
		error = -EINVAL;
		goto exit1;
    53e6:	mov    0x20(%rbx),%rax
    53ea:	cmpq   $0x0,0x58(%rax)
    53ef:	je     5532 <vfs_rmdir+0x172>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    53f5:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    53fe:	mov    $0x0,%rax
    5405:	add    $0x4a8,%rdx
    540c:	jmp    5418 <vfs_rmdir+0x58>
    540e:	xchg   %ax,%ax
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5410:	test   %cl,%cl
    5412:	je     5540 <vfs_rmdir+0x180>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5418:	add    $0x1,%rdx
    541c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5420:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5424:	cmp    -0x1(%rax),%cl
    5427:	je     5410 <vfs_rmdir+0x50>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5429:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    5432:	mov    $0x0,%rax
    5439:	add    $0x4a8,%rdx
    5440:	jmp    5450 <vfs_rmdir+0x90>
    5442:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5448:	test   %cl,%cl
    544a:	je     5540 <vfs_rmdir+0x180>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5450:	add    $0x1,%rdx
    5454:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5458:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    545c:	cmp    -0x1(%rax),%cl
    545f:	je     5448 <vfs_rmdir+0x88>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    5461:	test   %r12,%r12
    5464:	je     5470 <vfs_rmdir+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    5466:	lea    0x58(%r12),%rdi
    546b:	callq  5470 <vfs_rmdir+0xb0>
vfs_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3581
	case LAST_ROOT:
		error = -EBUSY;
		goto exit1;
	}
    5470:	mov    0x30(%r12),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3583

	nd.flags &= ~LOOKUP_PARENT;
    5475:	mov    $0xfffffff0,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3581
		error = -EINVAL;
		goto exit1;
	case LAST_ROOT:
		error = -EBUSY;
		goto exit1;
	}
    547b:	lea    0xa8(%rax),%rdi
    5482:	callq  5487 <vfs_rmdir+0xc7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3584

	nd.flags &= ~LOOKUP_PARENT;
	error = mnt_want_write(nd.path.mnt);
    5487:	testl  $0x10000,(%r12)
    548f:	je     54b8 <vfs_rmdir+0xf8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3600
		goto exit3;
	}
	error = security_path_rmdir(&nd.path, dentry);
	if (error)
		goto exit3;
	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
    5491:	mov    0x30(%r12),%rax
    5496:	lea    0xa8(%rax),%rdi
    549d:	callq  54a2 <vfs_rmdir+0xe2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3601
exit3:
    54a2:	mov    %r12,%rdi
    54a5:	callq  54aa <vfs_rmdir+0xea>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3578
		error = -ENOTEMPTY;
		goto exit1;
	case LAST_DOT:
		error = -EINVAL;
		goto exit1;
	case LAST_ROOT:
    54aa:	mov    %r13d,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3605
	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
exit3:
	dput(dentry);
exit2:
	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
	mnt_drop_write(nd.path.mnt);
    54ad:	pop    %rbx
    54ae:	pop    %r12
    54b0:	pop    %r13
    54b2:	pop    %rbp
    54b3:	retq   
    54b4:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3587

	nd.flags &= ~LOOKUP_PARENT;
	error = mnt_want_write(nd.path.mnt);
	if (error)
		goto exit1;

    54b8:	mov    %r12,%rsi
    54bb:	mov    %rbx,%rdi
    54be:	callq  54c3 <vfs_rmdir+0x103>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3588
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    54c3:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3587

	nd.flags &= ~LOOKUP_PARENT;
	error = mnt_want_write(nd.path.mnt);
	if (error)
		goto exit1;

    54c5:	mov    %eax,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3588
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    54c8:	jne    5491 <vfs_rmdir+0xd1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3591
	dentry = lookup_hash(&nd);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
    54ca:	mov    %r12,%rdi
    54cd:	callq  54d2 <vfs_rmdir+0x112>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3592
		goto exit2;
    54d2:	mov    0x20(%rbx),%rax
    54d6:	mov    %r12,%rsi
    54d9:	mov    %rbx,%rdi
    54dc:	callq  *0x58(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3593
	if (!dentry->d_inode) {
    54df:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3592

	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
	dentry = lookup_hash(&nd);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto exit2;
    54e1:	mov    %eax,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3593
	if (!dentry->d_inode) {
    54e4:	jne    5491 <vfs_rmdir+0xd1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3596
		error = -ENOENT;
		goto exit3;
	}
    54e6:	mov    0x30(%r12),%rax
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    54eb:	lea    0x58(%r12),%rbx
    54f0:	mov    %rbx,%rdi
vfs_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3596
    54f3:	orl    $0x10,0xc(%rax)
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
    54f7:	callq  54fc <vfs_rmdir+0x13c>
dont_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:393
}

static inline void dont_mount(struct dentry *dentry)
{
	spin_lock(&dentry->d_lock);
	dentry->d_flags |= DCACHE_CANT_MOUNT;
    54fc:	orl    $0x100,(%r12)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    5504:	mov    %rbx,%rdi
    5507:	callq  550c <vfs_rmdir+0x14c>
vfs_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3600
	error = security_path_rmdir(&nd.path, dentry);
	if (error)
		goto exit3;
	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
    550c:	mov    0x30(%r12),%rax
    5511:	lea    0xa8(%rax),%rdi
    5518:	callq  551d <vfs_rmdir+0x15d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3601
exit3:
    551d:	mov    %r12,%rdi
    5520:	callq  5525 <vfs_rmdir+0x165>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3603
	dput(dentry);
exit2:
    5525:	mov    %r12,%rdi
    5528:	callq  552d <vfs_rmdir+0x16d>
    552d:	jmpq   54aa <vfs_rmdir+0xea>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3578
		error = -ENOTEMPTY;
		goto exit1;
	case LAST_DOT:
		error = -EINVAL;
		goto exit1;
	case LAST_ROOT:
    5532:	mov    $0xffffffff,%eax
    5537:	jmpq   54ad <vfs_rmdir+0xed>
    553c:	nopl   0x0(%rax)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5540:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    5549:	mov    $0x0,%rsi
    5550:	add    $0x4a8,%rdx
    5557:	mov    $0x0,%rdi
    555e:	xor    %eax,%eax
    5560:	callq  5565 <vfs_rmdir+0x1a5>
    5565:	jmpq   5461 <vfs_rmdir+0xa1>
vfs_rmdir():
    556a:	nopw   0x0(%rax,%rax,1)

0000000000005570 <do_rmdir>:
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3608
exit2:
	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
	mnt_drop_write(nd.path.mnt);
exit1:
	path_put(&nd.path);
	putname(name);
    5570:	callq  5575 <do_rmdir+0x5>
    5575:	push   %rbp
    5576:	mov    %rsp,%rbp
    5579:	push   %r15
    557b:	push   %r14
    557d:	mov    %edi,%r14d
    5580:	push   %r13
    5582:	mov    %rsi,%r13
    5585:	push   %r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3613
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
	return error;
    5587:	xor    %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3608
exit2:
	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
	mnt_drop_write(nd.path.mnt);
exit1:
	path_put(&nd.path);
	putname(name);
    558a:	push   %rbx
    558b:	and    $0xfffffffffffffff0,%rsp
    558f:	sub    $0xb0,%rsp
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    5596:	lea    0x20(%rsp),%rax
    559b:	mov    %rax,0x8(%rsp)
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3615
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
	return error;
}

    55a0:	lea    0x10(%rsp),%rdx
    55a5:	mov    %r12d,%ecx
    55a8:	mov    %r13,%rsi
    55ab:	mov    %r14d,%edi
    55ae:	callq  46b0 <user_path_parent>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3616
SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
    55b3:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3615
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
	return error;
}

    55b9:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3616
SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
    55bc:	ja     573a <do_rmdir+0x1ca>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3619
{
	return do_rmdir(AT_FDCWD, pathname);
}
    55c2:	mov    0x54(%rsp),%eax
    55c6:	cmp    $0x2,%eax
    55c9:	je     5630 <do_rmdir+0xc0>
    55cb:	cmp    $0x3,%eax
    55ce:	je     5678 <do_rmdir+0x108>
    55d4:	cmp    $0x1,%eax
    55d7:	je     5668 <do_rmdir+0xf8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3632
 * The caller must hold dir->i_mutex.
 *
 * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
 * return a reference to the inode in delegated_inode.  The caller
 * should then break the delegation on that inode and retry.  Because
 * breaking a delegation may take a long time, the caller should drop
    55dd:	mov    0x10(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3631
 *
 * The caller must hold dir->i_mutex.
 *
 * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
 * return a reference to the inode in delegated_inode.  The caller
 * should then break the delegation on that inode and retry.  Because
    55e2:	andl   $0xffffffef,0x48(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3632
 * breaking a delegation may take a long time, the caller should drop
    55e7:	callq  55ec <do_rmdir+0x7c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3633
 * dir->i_mutex before doing so.
    55ec:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3632
 * The caller must hold dir->i_mutex.
 *
 * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
 * return a reference to the inode in delegated_inode.  The caller
 * should then break the delegation on that inode and retry.  Because
 * breaking a delegation may take a long time, the caller should drop
    55ee:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3633
 * dir->i_mutex before doing so.
    55f1:	je     5698 <do_rmdir+0x128>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    55f7:	mov    0x18(%rsp),%rdi
    55fc:	callq  5601 <do_rmdir+0x91>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    5601:	mov    0x10(%rsp),%rdi
    5606:	callq  560b <do_rmdir+0x9b>
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3656
	if (d_mountpoint(dentry))
		error = -EBUSY;
	else {
		error = security_inode_unlink(dir, dentry);
		if (!error) {
			error = try_break_deleg(target, delegated_inode);
    560b:	mov    %rbx,%rdi
    560e:	callq  5613 <do_rmdir+0xa3>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
 * Returns true if the caller should try the operation again.
 */
static inline bool
retry_estale(const long error, const unsigned int flags)
{
	return error == -ESTALE && !(flags & LOOKUP_REVAL);
    5613:	cmp    $0xffffff8c,%r15d
    5617:	jne    5747 <do_rmdir+0x1d7>
    561d:	test   %r12d,%r12d
    5620:	jne    5688 <do_rmdir+0x118>
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3658
			if (error)
				goto out;
    5622:	mov    $0x20,%r12b
    5625:	jmpq   55a0 <do_rmdir+0x30>
    562a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3619
}

SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
{
	return do_rmdir(AT_FDCWD, pathname);
}
    5630:	mov    $0xffffffffffffffea,%r12
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    5637:	mov    0x18(%rsp),%rdi
    563c:	callq  5641 <do_rmdir+0xd1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    5641:	mov    0x10(%rsp),%rdi
    5646:	callq  564b <do_rmdir+0xdb>
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3656
	if (d_mountpoint(dentry))
		error = -EBUSY;
	else {
		error = security_inode_unlink(dir, dentry);
		if (!error) {
			error = try_break_deleg(target, delegated_inode);
    564b:	mov    %rbx,%rdi
    564e:	callq  5653 <do_rmdir+0xe3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3662
			if (error)
				goto out;
			error = dir->i_op->unlink(dir, dentry);
			if (!error)
				dont_mount(dentry);
		}
    5653:	lea    -0x28(%rbp),%rsp
    5657:	mov    %r12,%rax
    565a:	pop    %rbx
    565b:	pop    %r12
    565d:	pop    %r13
    565f:	pop    %r14
    5661:	pop    %r15
    5663:	pop    %rbp
    5664:	retq   
    5665:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3628
 * @dir:	parent directory
 * @dentry:	victim
 * @delegated_inode: returns victim inode, if the inode is delegated.
 *
 * The caller must hold dir->i_mutex.
 *
    5668:	mov    $0xfffffffffffffff0,%r12
    566f:	jmp    5637 <do_rmdir+0xc7>
    5671:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3619
}

SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
{
	return do_rmdir(AT_FDCWD, pathname);
}
    5678:	mov    $0xffffffffffffffd9,%r12
    567f:	jmp    5637 <do_rmdir+0xc7>
    5681:	nopl   0x0(%rax)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    5688:	mov    $0xffffffffffffff8c,%r12
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3661
			error = try_break_deleg(target, delegated_inode);
			if (error)
				goto out;
			error = dir->i_op->unlink(dir, dentry);
			if (!error)
				dont_mount(dentry);
    568f:	jmp    5653 <do_rmdir+0xe3>
    5691:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3636
 * should then break the delegation on that inode and retry.  Because
 * breaking a delegation may take a long time, the caller should drop
 * dir->i_mutex before doing so.
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
    5698:	mov    0x18(%rsp),%rax
    569d:	mov    0x30(%rax),%rdi
    56a1:	add    $0xa8,%rdi
    56a8:	callq  56ad <do_rmdir+0x13d>
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    56ad:	mov    0x48(%rsp),%edx
    56b1:	mov    0x18(%rsp),%rsi
    56b6:	mov    0x8(%rsp),%rdi
    56bb:	callq  9a0 <__lookup_hash>
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3639
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 */
int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)
    56c0:	cmp    $0xfffffffffffff000,%rax
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    56c6:	mov    %rax,%rdx
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3639
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 */
int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)
    56c9:	ja     5742 <do_rmdir+0x1d2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3641
{
	struct inode *target = dentry->d_inode;
    56cb:	cmpq   $0x0,0x30(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3642
	int error = may_delete(dir, dentry, 0);
    56d0:	mov    $0xfffffffe,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3641
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 */
int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)
{
	struct inode *target = dentry->d_inode;
    56d6:	je     56f4 <do_rmdir+0x184>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3645
	int error = may_delete(dir, dentry, 0);

	if (error)
		return error;
    56d8:	lea    0x10(%rsp),%rdi
    56dd:	mov    %rax,%rsi
    56e0:	mov    %rax,(%rsp)
    56e4:	callq  56e9 <do_rmdir+0x179>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3646

    56e9:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3645
{
	struct inode *target = dentry->d_inode;
	int error = may_delete(dir, dentry, 0);

	if (error)
		return error;
    56eb:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3646

    56ee:	mov    (%rsp),%rdx
    56f2:	je     5720 <do_rmdir+0x1b0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3650
	if (!dir->i_op->unlink)
		return -EPERM;

	mutex_lock(&target->i_mutex);
    56f4:	mov    %rdx,%rdi
    56f7:	callq  56fc <do_rmdir+0x18c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3652
	if (d_mountpoint(dentry))
		error = -EBUSY;
    56fc:	mov    0x18(%rsp),%rdx
    5701:	mov    0x30(%rdx),%rdi
    5705:	add    $0xa8,%rdi
    570c:	callq  5711 <do_rmdir+0x1a1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3653
	else {
    5711:	mov    0x10(%rsp),%rdi
    5716:	callq  571b <do_rmdir+0x1ab>
    571b:	jmpq   55f7 <do_rmdir+0x87>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3648

	if (error)
		return error;

	if (!dir->i_op->unlink)
		return -EPERM;
    5720:	mov    0x18(%rsp),%rax
    5725:	mov    %rdx,%rsi
    5728:	mov    0x30(%rax),%rdi
    572c:	callq  5731 <do_rmdir+0x1c1>
    5731:	mov    (%rsp),%rdx
    5735:	mov    %eax,%r15d
    5738:	jmp    56f4 <do_rmdir+0x184>
PTR_ERR():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/err.h:29
	return (void *) error;
}

static inline long __must_check PTR_ERR(__force const void *ptr)
{
	return (long) ptr;
    573a:	mov    %rax,%r12
do_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3617
	}
	return error;
}

SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
{
    573d:	jmpq   5653 <do_rmdir+0xe3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3638
 * dir->i_mutex before doing so.
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 */
    5742:	mov    %eax,%r15d
    5745:	jmp    56fc <do_rmdir+0x18c>
    5747:	movslq %r15d,%r12
    574a:	jmpq   5653 <do_rmdir+0xe3>
    574f:	nop

0000000000005750 <vfs_unlink>:
vfs_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3688
{
	int error;
	struct filename *name;
	struct dentry *dentry;
	struct nameidata nd;
	struct inode *inode = NULL;
    5750:	callq  5755 <vfs_unlink+0x5>
    5755:	push   %rbp
    5756:	mov    %rsp,%rbp
    5759:	push   %r15
    575b:	mov    %rdx,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3690
	struct inode *delegated_inode = NULL;
	unsigned int lookup_flags = 0;
    575e:	xor    %edx,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3688
{
	int error;
	struct filename *name;
	struct dentry *dentry;
	struct nameidata nd;
	struct inode *inode = NULL;
    5760:	push   %r14
    5762:	push   %r13
    5764:	mov    %rdi,%r13
    5767:	push   %r12
    5769:	mov    %rsi,%r12
    576c:	push   %rbx
    576d:	sub    $0x8,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3689
	struct inode *delegated_inode = NULL;
    5771:	mov    0x30(%rsi),%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3690
	unsigned int lookup_flags = 0;
    5775:	callq  5110 <may_delete>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3692
retry:
	name = user_path_parent(dfd, pathname, &nd, lookup_flags);
    577a:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3690
	struct filename *name;
	struct dentry *dentry;
	struct nameidata nd;
	struct inode *inode = NULL;
	struct inode *delegated_inode = NULL;
	unsigned int lookup_flags = 0;
    577c:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3692
retry:
	name = user_path_parent(dfd, pathname, &nd, lookup_flags);
    577e:	jne    57bd <vfs_unlink+0x6d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3695
	if (IS_ERR(name))
		return PTR_ERR(name);

    5780:	mov    0x20(%r13),%rax
    5784:	cmpq   $0x0,0x40(%rax)
    5789:	je     5896 <vfs_unlink+0x146>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3698
	error = -EISDIR;
	if (nd.last_type != LAST_NORM)
		goto exit1;
    578f:	lea    0xa8(%r14),%rbx
    5796:	mov    %rbx,%rdi
    5799:	callq  579e <vfs_unlink+0x4e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3699

    579e:	testl  $0x10000,(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3700
	nd.flags &= ~LOOKUP_PARENT;
    57a6:	mov    $0xfffffff0,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3699
		return PTR_ERR(name);

	error = -EISDIR;
	if (nd.last_type != LAST_NORM)
		goto exit1;

    57ab:	je     57d0 <vfs_unlink+0x80>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3713
	if (!IS_ERR(dentry)) {
		/* Why not before? Because we want correct error value */
		if (nd.last.name[nd.last.len])
			goto slashes;
		inode = dentry->d_inode;
		if (d_is_negative(dentry))
    57ad:	mov    %rbx,%rdi
    57b0:	mov    %eax,-0x2c(%rbp)
    57b3:	callq  57b8 <vfs_unlink+0x68>
    57b8:	mov    -0x2c(%rbp),%eax
    57bb:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3722
		if (error)
			goto exit2;
		error = vfs_unlink(nd.path.dentry->d_inode, dentry, &delegated_inode);
exit2:
		dput(dentry);
	}
    57bd:	add    $0x8,%rsp
    57c1:	mov    %ebx,%eax
    57c3:	pop    %rbx
    57c4:	pop    %r12
    57c6:	pop    %r13
    57c8:	pop    %r14
    57ca:	pop    %r15
    57cc:	pop    %rbp
    57cd:	retq   
    57ce:	xchg   %ax,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3702
	if (nd.last_type != LAST_NORM)
		goto exit1;

	nd.flags &= ~LOOKUP_PARENT;
	error = mnt_want_write(nd.path.mnt);
	if (error)
    57d0:	mov    %r12,%rsi
    57d3:	mov    %r13,%rdi
    57d6:	callq  57db <vfs_unlink+0x8b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3703
		goto exit1;
    57db:	test   %eax,%eax
    57dd:	jne    57ad <vfs_unlink+0x5d>
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    57df:	cmpq   $0x0,0x148(%r14)
    57e7:	je     5824 <vfs_unlink+0xd4>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    57e9:	mov    $0x4,%edx
    57ee:	mov    $0x801,%esi
    57f3:	mov    %r14,%rdi
    57f6:	callq  57fb <vfs_unlink+0xab>
try_break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1983
static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(inode, O_WRONLY|O_NONBLOCK);
	if (ret == -EWOULDBLOCK && delegated_inode) {
    57fb:	cmp    $0xfffffff5,%eax
    57fe:	jne    5820 <vfs_unlink+0xd0>
    5800:	test   %r15,%r15
    5803:	je     5820 <vfs_unlink+0xd0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1984
		*delegated_inode = inode;
    5805:	mov    %r14,(%r15)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1985
		ihold(inode);
    5808:	mov    %r14,%rdi
    580b:	callq  5810 <vfs_unlink+0xc0>
    5810:	mov    $0xfffffff5,%eax
    5815:	jmp    57ad <vfs_unlink+0x5d>
    5817:	nopw   0x0(%rax,%rax,1)
vfs_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3705
retry_deleg:
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    5820:	test   %eax,%eax
    5822:	jne    57ad <vfs_unlink+0x5d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3707
	dentry = lookup_hash(&nd);
	error = PTR_ERR(dentry);
    5824:	mov    0x20(%r13),%rax
    5828:	mov    %r12,%rsi
    582b:	mov    %r13,%rdi
    582e:	callq  *0x40(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3708
	if (!IS_ERR(dentry)) {
    5831:	test   %eax,%eax
    5833:	jne    57ad <vfs_unlink+0x5d>
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    5839:	lea    0x58(%r12),%r13
    583e:	mov    %r13,%rdi
    5841:	callq  5846 <vfs_unlink+0xf6>
dont_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:393
}

static inline void dont_mount(struct dentry *dentry)
{
	spin_lock(&dentry->d_lock);
	dentry->d_flags |= DCACHE_CANT_MOUNT;
    5846:	orl    $0x100,(%r12)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    584e:	mov    %r13,%rdi
    5851:	callq  5856 <vfs_unlink+0x106>
vfs_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3713
		/* Why not before? Because we want correct error value */
		if (nd.last.name[nd.last.len])
			goto slashes;
		inode = dentry->d_inode;
		if (d_is_negative(dentry))
    5856:	mov    %rbx,%rdi
    5859:	xor    %ebx,%ebx
    585b:	callq  5860 <vfs_unlink+0x110>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3716
			goto slashes;
		ihold(inode);
		error = security_path_unlink(&nd.path, dentry);
    5860:	testl  $0x1000,(%r12)
    5868:	jne    57bd <vfs_unlink+0x6d>
fsnotify_link_count():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:82
/*
 * fsnotify_link_count - inode's link count changed
 */
static inline void fsnotify_link_count(struct inode *inode)
{
	fsnotify(inode, FS_ATTRIB, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
    586e:	mov    %r14,%rdi
    5871:	xor    %r9d,%r9d
    5874:	xor    %r8d,%r8d
    5877:	mov    $0x2,%ecx
    587c:	mov    %r14,%rdx
    587f:	mov    $0x4,%esi
    5884:	callq  5889 <vfs_unlink+0x139>
vfs_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3718
		if (error)
			goto exit2;
    5889:	mov    %r12,%rdi
    588c:	callq  5891 <vfs_unlink+0x141>
    5891:	jmpq   57bd <vfs_unlink+0x6d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3696
retry:
	name = user_path_parent(dfd, pathname, &nd, lookup_flags);
	if (IS_ERR(name))
		return PTR_ERR(name);

	error = -EISDIR;
    5896:	mov    $0xffffffff,%ebx
    589b:	jmpq   57bd <vfs_unlink+0x6d>

00000000000058a0 <do_unlinkat>:
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3731
	inode = NULL;
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry_deleg;
	}
    58a0:	callq  58a5 <do_unlinkat+0x5>
    58a5:	push   %rbp
    58a6:	mov    %rsp,%rbp
    58a9:	push   %r15
    58ab:	push   %r14
    58ad:	push   %r13
    58af:	push   %r12
    58b1:	push   %rbx
    58b2:	and    $0xfffffffffffffff0,%rsp
    58b6:	sub    $0xb8,%rsp
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    58bd:	lea    0x28(%rsp),%r13
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3731
	inode = NULL;
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry_deleg;
	}
    58c2:	mov    %edi,0x8(%rsp)
    58c6:	mov    %rsi,(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3737
	mnt_drop_write(nd.path.mnt);
exit1:
	path_put(&nd.path);
	putname(name);
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
    58ca:	movq   $0x0,0x10(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3738
		inode = NULL;
    58d3:	movl   $0x0,0xc(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3740
		goto retry;
	}
    58db:	mov    0xc(%rsp),%ecx
    58df:	mov    (%rsp),%rsi
    58e3:	lea    0x18(%rsp),%rdx
    58e8:	mov    0x8(%rsp),%edi
    58ec:	callq  46b0 <user_path_parent>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3741
	return error;
    58f1:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3740
	putname(name);
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
		inode = NULL;
		goto retry;
	}
    58f7:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3741
	return error;
    58fa:	ja     5927 <do_unlinkat+0x87>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3745

slashes:
	if (d_is_negative(dentry))
		error = -ENOENT;
    58fc:	mov    0x5c(%rsp),%edx
    5900:	test   %edx,%edx
    5902:	je     5940 <do_unlinkat+0xa0>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    5904:	mov    0x20(%rsp),%rdi
    5909:	callq  590e <do_unlinkat+0x6e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    590e:	mov    0x18(%rsp),%rdi
    5913:	callq  5918 <do_unlinkat+0x78>
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3783

	error = security_inode_symlink(dir, dentry, oldname);
	if (error)
		return error;

	error = dir->i_op->symlink(dir, dentry, oldname);
    5918:	mov    %r12,%rdi
    591b:	callq  5920 <do_unlinkat+0x80>
    5920:	mov    $0xffffffffffffffeb,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3799
	struct dentry *dentry;
	struct path path;
	unsigned int lookup_flags = 0;

	from = getname(oldname);
	if (IS_ERR(from))
    5927:	lea    -0x28(%rbp),%rsp
    592b:	pop    %rbx
    592c:	pop    %r12
    592e:	pop    %r13
    5930:	pop    %r14
    5932:	pop    %r15
    5934:	pop    %rbp
    5935:	retq   
    5936:	nopw   %cs:0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3749
	if (d_is_negative(dentry))
		error = -ENOENT;
	else if (d_is_directory(dentry) || d_is_autodir(dentry))
		error = -EISDIR;
	else
		error = -ENOTDIR;
    5940:	mov    0x18(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3748
slashes:
	if (d_is_negative(dentry))
		error = -ENOENT;
	else if (d_is_directory(dentry) || d_is_autodir(dentry))
		error = -EISDIR;
	else
    5945:	andl   $0xffffffef,0x50(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3749
		error = -ENOTDIR;
    594a:	callq  594f <do_unlinkat+0xaf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3750
	goto exit2;
    594f:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3749
	if (d_is_negative(dentry))
		error = -ENOENT;
	else if (d_is_directory(dentry) || d_is_autodir(dentry))
		error = -EISDIR;
	else
		error = -ENOTDIR;
    5951:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3750
	goto exit2;
    5953:	je     59a6 <do_unlinkat+0x106>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    5955:	mov    0x20(%rsp),%rdi
    595a:	callq  595f <do_unlinkat+0xbf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    595f:	mov    0x18(%rsp),%rdi
    5964:	callq  5969 <do_unlinkat+0xc9>
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3783

	error = security_inode_symlink(dir, dentry, oldname);
	if (error)
		return error;

	error = dir->i_op->symlink(dir, dentry, oldname);
    5969:	mov    %r12,%rdi
    596c:	callq  5971 <do_unlinkat+0xd1>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    5971:	cmp    $0xffffff8c,%ebx
    5974:	jne    5b26 <do_unlinkat+0x286>
    597a:	mov    0xc(%rsp),%eax
    597e:	test   %eax,%eax
    5980:	jne    5b10 <do_unlinkat+0x270>
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3785
	if (!error)
		fsnotify_create(dir, dentry);
    5986:	movl   $0x20,0xc(%rsp)
    598e:	jmpq   58db <do_unlinkat+0x3b>
    5993:	nopl   0x0(%rax,%rax,1)
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    5998:	callq  599d <do_unlinkat+0xfd>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    599d:	movq   $0x0,0x10(%rsp)
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3753
	else
		error = -ENOTDIR;
	goto exit2;
}

SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
    59a6:	mov    0x20(%rsp),%rax
    59ab:	mov    0x30(%rax),%rdi
    59af:	add    $0xa8,%rdi
    59b6:	callq  59bb <do_unlinkat+0x11b>
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    59bb:	mov    0x50(%rsp),%edx
    59bf:	mov    0x20(%rsp),%rsi
    59c4:	mov    %r13,%rdi
    59c7:	callq  9a0 <__lookup_hash>
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3756
}

SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
{
	if ((flag & ~AT_REMOVEDIR) != 0)
		return -EINVAL;
    59cc:	cmp    $0xfffffffffffff000,%rax
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    59d2:	mov    %rax,%r15
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3756
}

SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
{
	if ((flag & ~AT_REMOVEDIR) != 0)
		return -EINVAL;
    59d5:	ja     5b2e <do_unlinkat+0x28e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3758

	if (flag & AT_REMOVEDIR)
    59db:	mov    0x2c(%rsp),%eax
    59df:	mov    0x30(%rsp),%rdx
    59e4:	cmpb   $0x0,(%rdx,%rax,1)
    59e8:	jne    5a88 <do_unlinkat+0x1e8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3761
		return do_rmdir(dfd, pathname);

	return do_unlinkat(dfd, pathname);
    59ee:	testl  $0x700000,(%r15)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3760
	if ((flag & ~AT_REMOVEDIR) != 0)
		return -EINVAL;

	if (flag & AT_REMOVEDIR)
		return do_rmdir(dfd, pathname);

    59f5:	mov    0x30(%r15),%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3793

SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
		int, newdfd, const char __user *, newname)
{
	int error;
	struct filename *from;
    59f9:	mov    $0xfffffffe,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3761
		return -EINVAL;

	if (flag & AT_REMOVEDIR)
		return do_rmdir(dfd, pathname);

	return do_unlinkat(dfd, pathname);
    59fe:	jne    5ad0 <do_unlinkat+0x230>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3769
SYSCALL_DEFINE1(unlink, const char __user *, pathname)
{
	return do_unlinkat(AT_FDCWD, pathname);
}

int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)
    5a04:	mov    %r15,%rdi
    5a07:	callq  5a0c <do_unlinkat+0x16c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3771
{
	int error = may_create(dir, dentry);
    5a0c:	mov    0x20(%rsp),%rax
    5a11:	mov    0x30(%rax),%rdi
    5a15:	add    $0xa8,%rdi
    5a1c:	callq  5a21 <do_unlinkat+0x181>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3772

    5a21:	test   %r14,%r14
    5a24:	je     5a2e <do_unlinkat+0x18e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3773
	if (error)
    5a26:	mov    %r14,%rdi
    5a29:	callq  5a2e <do_unlinkat+0x18e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3775
		return error;

    5a2e:	mov    0x10(%rsp),%rdi
    5a33:	test   %rdi,%rdi
    5a36:	je     5a72 <do_unlinkat+0x1d2>
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    5a38:	cmpq   $0x0,0x148(%rdi)
    5a40:	je     5998 <do_unlinkat+0xf8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    5a46:	mov    $0x4,%edx
    5a4b:	mov    $0x1,%esi
    5a50:	callq  5a55 <do_unlinkat+0x1b5>
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    5a55:	mov    0x10(%rsp),%rdi
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
		return __break_lease(inode, mode, FL_DELEG);
    5a5a:	mov    %eax,%ebx
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    5a5c:	callq  5a61 <do_unlinkat+0x1c1>
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3777
	if (!dir->i_op->symlink)
		return -EPERM;
    5a61:	test   %ebx,%ebx
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    5a63:	movq   $0x0,0x10(%rsp)
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3777
    5a6c:	je     59a6 <do_unlinkat+0x106>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3780

	error = security_inode_symlink(dir, dentry, oldname);
	if (error)
    5a72:	mov    0x18(%rsp),%rdi
    5a77:	callq  5a7c <do_unlinkat+0x1dc>
    5a7c:	jmpq   5955 <do_unlinkat+0xb5>
    5a81:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3792
}

SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
		int, newdfd, const char __user *, newname)
{
	int error;
    5a88:	mov    (%r15),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3793
	struct filename *from;
    5a8b:	mov    $0xfffffffe,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3792
}

SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
		int, newdfd, const char __user *, newname)
{
	int error;
    5a90:	and    $0x700000,%eax
    5a95:	je     5aad <do_unlinkat+0x20d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3794
	struct filename *from;
	struct dentry *dentry;
    5a97:	cmp    $0x100000,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3795
	struct path path;
    5a9c:	mov    $0xeb,%bl
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3794
SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
		int, newdfd, const char __user *, newname)
{
	int error;
	struct filename *from;
	struct dentry *dentry;
    5a9e:	je     5aad <do_unlinkat+0x20d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3795
	struct path path;
    5aa0:	xor    %ebx,%ebx
    5aa2:	cmp    $0x200000,%eax
    5aa7:	setne  %bl
    5aaa:	sub    $0x15,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3769
SYSCALL_DEFINE1(unlink, const char __user *, pathname)
{
	return do_unlinkat(AT_FDCWD, pathname);
}

int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)
    5aad:	mov    %r15,%rdi
    5ab0:	callq  5ab5 <do_unlinkat+0x215>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3771
{
	int error = may_create(dir, dentry);
    5ab5:	mov    0x20(%rsp),%rax
    5aba:	mov    0x30(%rax),%rdi
    5abe:	add    $0xa8,%rdi
    5ac5:	callq  5aca <do_unlinkat+0x22a>
    5aca:	jmpq   5a2e <do_unlinkat+0x18e>
    5acf:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3763
	if (flag & AT_REMOVEDIR)
		return do_rmdir(dfd, pathname);

	return do_unlinkat(dfd, pathname);
}

    5ad0:	mov    %r14,%rdi
    5ad3:	callq  5ad8 <do_unlinkat+0x238>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3764
SYSCALL_DEFINE1(unlink, const char __user *, pathname)
    5ad8:	lea    0x18(%rsp),%rdi
    5add:	mov    %r15,%rsi
    5ae0:	callq  5ae5 <do_unlinkat+0x245>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3765
{
    5ae5:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3764
		return do_rmdir(dfd, pathname);

	return do_unlinkat(dfd, pathname);
}

SYSCALL_DEFINE1(unlink, const char __user *, pathname)
    5ae7:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3765
{
    5ae9:	jne    5a04 <do_unlinkat+0x164>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3767
	return do_unlinkat(AT_FDCWD, pathname);
}
    5aef:	mov    0x20(%rsp),%rax
    5af4:	lea    0x10(%rsp),%rdx
    5af9:	mov    %r15,%rsi
    5afc:	mov    0x30(%rax),%rdi
    5b00:	callq  5b05 <do_unlinkat+0x265>
    5b05:	mov    %eax,%ebx
    5b07:	jmpq   5a04 <do_unlinkat+0x164>
    5b0c:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3799
	struct dentry *dentry;
	struct path path;
	unsigned int lookup_flags = 0;

	from = getname(oldname);
	if (IS_ERR(from))
    5b10:	lea    -0x28(%rbp),%rsp
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    5b14:	mov    $0xffffffffffffff8c,%rax
do_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3799
    5b1b:	pop    %rbx
    5b1c:	pop    %r12
    5b1e:	pop    %r13
    5b20:	pop    %r14
    5b22:	pop    %r15
    5b24:	pop    %rbp
    5b25:	retq   
    5b26:	movslq %ebx,%rax
    5b29:	jmpq   5927 <do_unlinkat+0x87>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3755
	goto exit2;
}

SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
{
	if ((flag & ~AT_REMOVEDIR) != 0)
    5b2e:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3771
	return do_unlinkat(AT_FDCWD, pathname);
}

int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)
{
	int error = may_create(dir, dentry);
    5b30:	mov    0x20(%rsp),%rax
    5b35:	mov    0x30(%rax),%rdi
    5b39:	add    $0xa8,%rdi
    5b40:	callq  5b45 <do_unlinkat+0x2a5>
    5b45:	jmpq   5a2e <do_unlinkat+0x18e>
    5b4a:	nopw   0x0(%rax,%rax,1)

0000000000005b50 <vfs_rename>:
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4168
	int error;
retry:
	from = user_path_parent(olddfd, oldname, &oldnd, lookup_flags);
	if (IS_ERR(from)) {
		error = PTR_ERR(from);
		goto exit;
    5b50:	callq  5b55 <vfs_rename+0x5>
    5b55:	push   %rbp
    5b56:	mov    %rsp,%rbp
    5b59:	push   %r15
    5b5b:	mov    %rsi,%r15
    5b5e:	push   %r14
    5b60:	mov    %rdx,%r14
    5b63:	push   %r13
    5b65:	mov    %rdi,%r13
    5b68:	push   %r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4170
	}

    5b6a:	mov    $0x1,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4168
	int error;
retry:
	from = user_path_parent(olddfd, oldname, &oldnd, lookup_flags);
	if (IS_ERR(from)) {
		error = PTR_ERR(from);
		goto exit;
    5b70:	push   %rbx
    5b71:	mov    %rcx,%rbx
    5b74:	sub    $0x28,%rsp
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    5b78:	mov    (%rsi),%eax
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4168
    5b7a:	mov    %r8,-0x30(%rbp)
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    5b7e:	and    $0x700000,%eax
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4170
	}

    5b83:	cmp    $0x100000,%eax
    5b88:	je     5b96 <vfs_rename+0x46>
    5b8a:	xor    %r12d,%r12d
    5b8d:	cmp    $0x200000,%eax
    5b92:	sete   %r12b
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4174 (discriminator 4)
	to = user_path_parent(newdfd, newname, &newnd, lookup_flags);
	if (IS_ERR(to)) {
		error = PTR_ERR(to);
		goto exit1;
    5b96:	xor    %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4173 (discriminator 4)
		goto exit;
	}

	to = user_path_parent(newdfd, newname, &newnd, lookup_flags);
	if (IS_ERR(to)) {
		error = PTR_ERR(to);
    5b98:	mov    0x30(%rbx),%rsi
    5b9c:	cmp    %rsi,0x30(%r15)
    5ba0:	je     5d80 <vfs_rename+0x230>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4176
		goto exit1;
	}

    5ba6:	mov    %r12d,%edx
    5ba9:	mov    %r15,%rsi
    5bac:	mov    %r13,%rdi
    5baf:	callq  5110 <may_delete>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4177
	error = -EXDEV;
    5bb4:	test   %eax,%eax
    5bb6:	jne    5d80 <vfs_rename+0x230>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4180
	if (oldnd.path.mnt != newnd.path.mnt)
		goto exit2;

    5bbc:	cmpq   $0x0,0x30(%rbx)
    5bc1:	je     5d90 <vfs_rename+0x240>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4183
	old_dir = oldnd.path.dentry;
	error = -EBUSY;
	if (oldnd.last_type != LAST_NORM)
    5bc7:	mov    %r12d,%edx
    5bca:	mov    %rbx,%rsi
    5bcd:	mov    %r14,%rdi
    5bd0:	callq  5110 <may_delete>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4184
		goto exit2;
    5bd5:	test   %eax,%eax
    5bd7:	jne    5d80 <vfs_rename+0x230>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4187

	new_dir = newnd.path.dentry;
	if (newnd.last_type != LAST_NORM)
    5bdd:	mov    0x20(%r13),%rax
    5be1:	cmpq   $0x0,0x68(%rax)
    5be6:	je     611b <vfs_rename+0x5cb>
fsnotify_oldname_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:333
/*
 * fsnotify_oldname_init - save off the old filename before we change it
 */
static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)
{
	return kstrdup(name, GFP_KERNEL);
    5bec:	mov    0x28(%r15),%rdi
    5bf0:	mov    $0xd0,%esi
    5bf5:	callq  5bfa <vfs_rename+0xaa>
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4192
		goto exit2;

	error = mnt_want_write(oldnd.path.mnt);
	if (error)
		goto exit2;
    5bfa:	test   %r12d,%r12d
fsnotify_oldname_init():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:333
    5bfd:	mov    %rax,-0x40(%rbp)
vfs_rename_dir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4053
	if (!error)
		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
			d_move(old_dentry,new_dentry);
	return error;
}

    5c01:	mov    0x30(%rbx),%rax
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4192
	if (newnd.last_type != LAST_NORM)
		goto exit2;

	error = mnt_want_write(oldnd.path.mnt);
	if (error)
		goto exit2;
    5c05:	je     5d50 <vfs_rename+0x200>
vfs_rename_dir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4053
	if (!error)
		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
			d_move(old_dentry,new_dentry);
	return error;
}

    5c0b:	mov    %rax,-0x30(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4054
static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, struct inode **delegated_inode)
    5c0f:	mov    0x28(%r14),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4060
{
	struct inode *target = new_dentry->d_inode;
	struct inode *source = old_dentry->d_inode;
	int error;

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
    5c13:	cmp    %r14,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4054
		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
			d_move(old_dentry,new_dentry);
	return error;
}

static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, struct inode **delegated_inode)
    5c16:	mov    0x300(%rax),%eax
    5c1c:	mov    %eax,-0x48(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4060
{
	struct inode *target = new_dentry->d_inode;
	struct inode *source = old_dentry->d_inode;
	int error;

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
    5c1f:	je     5c3a <vfs_rename+0xea>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4061
	if (error)
    5c21:	mov    0x30(%r15),%rdi
    5c25:	mov    $0x2,%esi
    5c2a:	callq  5c2f <vfs_rename+0xdf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4062
		return error;
    5c2f:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4061
	struct inode *target = new_dentry->d_inode;
	struct inode *source = old_dentry->d_inode;
	int error;

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
	if (error)
    5c31:	mov    %eax,-0x34(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4062
		return error;
    5c34:	jne    5d74 <vfs_rename+0x224>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4066

	dget(new_dentry);
	lock_two_nondirectories(source, target);

    5c3a:	mov    %rbx,%rcx
    5c3d:	mov    %r14,%rdx
    5c40:	mov    %r15,%rsi
    5c43:	mov    %r13,%rdi
    5c46:	callq  5c4b <vfs_rename+0xfb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4067
	error = -EBUSY;
    5c4b:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4066
	if (error)
		return error;

	dget(new_dentry);
	lock_two_nondirectories(source, target);

    5c4d:	mov    %eax,-0x34(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4067
	error = -EBUSY;
    5c50:	jne    5d74 <vfs_rename+0x224>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5c56:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    5c5f:	mov    $0x0,%rax
    5c66:	add    $0x4a8,%rdx
    5c6d:	jmp    5c78 <vfs_rename+0x128>
    5c6f:	nop
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5c70:	test   %cl,%cl
    5c72:	je     62c4 <vfs_rename+0x774>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5c78:	add    $0x1,%rdx
    5c7c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5c80:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5c84:	cmp    -0x1(%rax),%cl
    5c87:	je     5c70 <vfs_rename+0x120>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5c89:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    5c92:	mov    $0x0,%rax
    5c99:	add    $0x4a8,%rdx
    5ca0:	jmp    5cb0 <vfs_rename+0x160>
    5ca2:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5ca8:	test   %cl,%cl
    5caa:	je     62c4 <vfs_rename+0x774>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5cb0:	add    $0x1,%rdx
    5cb4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5cb8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5cbc:	cmp    -0x1(%rax),%cl
    5cbf:	je     5ca8 <vfs_rename+0x158>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    5cc1:	test   %rbx,%rbx
    5cc4:	je     5ccf <vfs_rename+0x17f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    5cc6:	lea    0x58(%rbx),%rdi
    5cca:	callq  5ccf <vfs_rename+0x17f>
vfs_rename_dir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4071
	if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))
		goto out;

	error = try_break_deleg(source, delegated_inode);
    5ccf:	mov    -0x30(%rbp),%rax
    5cd3:	test   %rax,%rax
    5cd6:	je     5ce4 <vfs_rename+0x194>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4072
	if (error)
    5cd8:	lea    0xa8(%rax),%rdi
    5cdf:	callq  5ce4 <vfs_rename+0x194>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4075
		goto out;
	if (target) {
		error = try_break_deleg(target, delegated_inode);
    5ce4:	testl  $0x10000,(%r15)
    5ceb:	jne    6068 <vfs_rename+0x518>
    5cf1:	testl  $0x10000,(%rbx)
    5cf7:	jne    6068 <vfs_rename+0x518>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4079
		if (error)
			goto out;
	}
	error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
    5cfd:	cmpq   $0x0,-0x30(%rbp)
    5d02:	jne    6125 <vfs_rename+0x5d5>
    5d08:	mov    -0x48(%rbp),%esi
    5d0b:	test   %esi,%esi
    5d0d:	je     6125 <vfs_rename+0x5d5>
    5d13:	cmp    %r14,%r13
    5d16:	je     5d25 <vfs_rename+0x1d5>
    5d18:	mov    -0x48(%rbp),%eax
    5d1b:	cmp    0x48(%r14),%eax
    5d1f:	jbe    6205 <vfs_rename+0x6b5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4085
	if (error)
		goto out;

	if (target)
		dont_mount(new_dentry);
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
    5d25:	mov    0x20(%r13),%rax
    5d29:	mov    %rbx,%rcx
    5d2c:	mov    %r14,%rdx
    5d2f:	mov    %r15,%rsi
    5d32:	mov    %r13,%rdi
    5d35:	callq  *0x68(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4086
		d_move(old_dentry, new_dentry);
    5d38:	test   %eax,%eax
    5d3a:	je     608a <vfs_rename+0x53a>
    5d40:	mov    %eax,-0x34(%rbp)
    5d43:	jmpq   5e95 <vfs_rename+0x345>
    5d48:	nopl   0x0(%rax,%rax,1)
vfs_rename_other():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4107
 *
 * If vfs_rename discovers a delegation in need of breaking at either
 * the source or destination, it will return -EWOULDBLOCK and return a
 * reference to the inode in delegated_inode.  The caller should then
 * break the delegation and retry.  Because breaking a delegation may
 * take a long time, the caller should drop all locks before doing
    5d50:	mov    %rax,-0x50(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4108
 * so.
    5d54:	mov    0x30(%r15),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4111
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
    5d58:	mov    %rbx,%rcx
    5d5b:	mov    %r14,%rdx
    5d5e:	mov    %r15,%rsi
    5d61:	mov    %r13,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4108
 * If vfs_rename discovers a delegation in need of breaking at either
 * the source or destination, it will return -EWOULDBLOCK and return a
 * reference to the inode in delegated_inode.  The caller should then
 * break the delegation and retry.  Because breaking a delegation may
 * take a long time, the caller should drop all locks before doing
 * so.
    5d64:	mov    %rax,-0x48(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4111
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
    5d68:	callq  5d6d <vfs_rename+0x21d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4112
 * to be NFS exported.
    5d6d:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4111
 * break the delegation and retry.  Because breaking a delegation may
 * take a long time, the caller should drop all locks before doing
 * so.
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
    5d6f:	mov    %eax,-0x34(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4112
 * to be NFS exported.
    5d72:	je     5de0 <vfs_rename+0x290>
fsnotify_oldname_free():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:341
/*
 * fsnotify_oldname_free - free the name we got from fsnotify_oldname_init
 */
static inline void fsnotify_oldname_free(const unsigned char *old_name)
{
	kfree(old_name);
    5d74:	mov    -0x40(%rbp),%rdi
    5d78:	callq  5d7d <vfs_rename+0x22d>
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4201
	newnd.flags |= LOOKUP_RENAME_TARGET;

retry_deleg:
	trap = lock_rename(new_dir, old_dir);

	old_dentry = lookup_hash(&oldnd);
    5d7d:	mov    -0x34(%rbp),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4202
	error = PTR_ERR(old_dentry);
    5d80:	add    $0x28,%rsp
    5d84:	pop    %rbx
    5d85:	pop    %r12
    5d87:	pop    %r13
    5d89:	pop    %r14
    5d8b:	pop    %r15
    5d8d:	pop    %rbp
    5d8e:	retq   
    5d8f:	nop
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    5d90:	mov    0x0(%rip),%r8d        # 5d97 <vfs_rename+0x247>
    5d97:	mov    0x0(%rip),%ecx        # 5d9d <vfs_rename+0x24d>
    5d9d:	mov    $0x4,%edx
    5da2:	mov    %rbx,%rsi
    5da5:	mov    %r14,%rdi
    5da8:	callq  5dad <vfs_rename+0x25d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
	if (p) {
    5dad:	cmpq   $0x0,0x30(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2461
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
    5db2:	mov    $0xffffffef,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
	if (p) {
    5db7:	jne    5d80 <vfs_rename+0x230>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    5db9:	testb  $0x10,0xc(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2463
		return p;
    5dbe:	mov    $0xfffffffe,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    5dc3:	jne    5d80 <vfs_rename+0x230>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
		return p;
	}
    5dc5:	mov    $0x3,%esi
    5dca:	mov    %r14,%rdi
    5dcd:	callq  5dd2 <vfs_rename+0x282>
    5dd2:	jmpq   5bd5 <vfs_rename+0x85>
    5dd7:	nopw   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5de0:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    5de9:	mov    $0x0,%rax
    5df0:	add    $0x4a8,%rdx
    5df7:	jmp    5e08 <vfs_rename+0x2b8>
    5df9:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5e00:	test   %cl,%cl
    5e02:	je     629a <vfs_rename+0x74a>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5e08:	add    $0x1,%rdx
    5e0c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5e10:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5e14:	cmp    -0x1(%rax),%cl
    5e17:	je     5e00 <vfs_rename+0x2b0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5e19:	mov    %gs:0x0,%rdx
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    5e22:	mov    $0x0,%rax
    5e29:	add    $0x4a8,%rdx
    5e30:	jmp    5e40 <vfs_rename+0x2f0>
    5e32:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5e38:	test   %cl,%cl
    5e3a:	je     629a <vfs_rename+0x74a>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5e40:	add    $0x1,%rdx
    5e44:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5e48:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5e4c:	cmp    -0x1(%rax),%cl
    5e4f:	je     5e38 <vfs_rename+0x2e8>
dget():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:361
	if (dentry)
    5e51:	test   %rbx,%rbx
    5e54:	je     5e5f <vfs_rename+0x30f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:362
		lockref_get(&dentry->d_lockref);
    5e56:	lea    0x58(%rbx),%rdi
    5e5a:	callq  5e5f <vfs_rename+0x30f>
vfs_rename_other():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4116
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 */
int vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, struct inode **delegated_inode)
{
	int error;
    5e5f:	mov    -0x50(%rbp),%rsi
    5e63:	mov    -0x48(%rbp),%rdi
    5e67:	callq  5e6c <vfs_rename+0x31c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4119
	int is_dir = d_is_directory(old_dentry) || d_is_autodir(old_dentry);
	const unsigned char *old_name;

    5e6c:	testl  $0x10000,(%r15)
    5e73:	jne    5e81 <vfs_rename+0x331>
    5e75:	testl  $0x10000,(%rbx)
    5e7b:	je     60bf <vfs_rename+0x56f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4118
 */
int vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, struct inode **delegated_inode)
{
	int error;
	int is_dir = d_is_directory(old_dentry) || d_is_autodir(old_dentry);
	const unsigned char *old_name;
    5e81:	movl   $0xfffffff0,-0x34(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4139
	if (!old_dir->i_op->rename)
		return -EPERM;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);

	if (is_dir)
    5e88:	mov    -0x50(%rbp),%rsi
    5e8c:	mov    -0x48(%rbp),%rdi
    5e90:	callq  5e95 <vfs_rename+0x345>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4140
		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
    5e95:	mov    %rbx,%rdi
    5e98:	callq  5e9d <vfs_rename+0x34d>
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4196
	if (error)
		goto exit2;

	oldnd.flags &= ~LOOKUP_PARENT;
	newnd.flags &= ~LOOKUP_PARENT;
	newnd.flags |= LOOKUP_RENAME_TARGET;
    5e9d:	mov    -0x34(%rbp),%edx
    5ea0:	test   %edx,%edx
    5ea2:	jne    5d74 <vfs_rename+0x224>
fsnotify_move():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:92
 */
static inline void fsnotify_move(struct inode *old_dir, struct inode *new_dir,
				 const unsigned char *old_name,
				 int isdir, struct inode *target, struct dentry *moved)
{
	struct inode *source = moved->d_inode;
    5ea8:	mov    0x30(%r15),%rax
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4197

    5eac:	mov    0x30(%rbx),%rbx
fsnotify_move():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:92
    5eb0:	mov    %rax,-0x30(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:93
	u32 fs_cookie = fsnotify_get_cookie();
    5eb4:	callq  5eb9 <vfs_rename+0x369>
    5eb9:	mov    %eax,%r11d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:96
	__u32 old_dir_mask = (FS_EVENT_ON_CHILD | FS_MOVED_FROM);
	__u32 new_dir_mask = (FS_EVENT_ON_CHILD | FS_MOVED_TO);
	const unsigned char *new_name = moved->d_name.name;
    5ebc:	mov    0x28(%r15),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:94
				 const unsigned char *old_name,
				 int isdir, struct inode *target, struct dentry *moved)
{
	struct inode *source = moved->d_inode;
	u32 fs_cookie = fsnotify_get_cookie();
	__u32 old_dir_mask = (FS_EVENT_ON_CHILD | FS_MOVED_FROM);
    5ec0:	cmp    %r14,%r13
    5ec3:	mov    $0x8000040,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:95
	__u32 new_dir_mask = (FS_EVENT_ON_CHILD | FS_MOVED_TO);
    5ec8:	mov    $0x8000080,%r10d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:96
	const unsigned char *new_name = moved->d_name.name;
    5ece:	mov    %rax,-0x48(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:94
				 const unsigned char *old_name,
				 int isdir, struct inode *target, struct dentry *moved)
{
	struct inode *source = moved->d_inode;
	u32 fs_cookie = fsnotify_get_cookie();
	__u32 old_dir_mask = (FS_EVENT_ON_CHILD | FS_MOVED_FROM);
    5ed2:	mov    $0x18000040,%eax
    5ed7:	cmove  %eax,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:101
	const unsigned char *new_name = moved->d_name.name;

	if (old_dir == new_dir)
		old_dir_mask |= FS_DN_RENAME;

	if (isdir) {
    5eda:	test   %r12d,%r12d
    5edd:	je     5eeb <vfs_rename+0x39b>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:102
		old_dir_mask |= FS_ISDIR;
    5edf:	or     $0x40000000,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:103
		new_dir_mask |= FS_ISDIR;
    5ee5:	mov    $0x48000080,%r10d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:106
	}

	fsnotify(old_dir, old_dir_mask, old_dir, FSNOTIFY_EVENT_INODE, old_name, fs_cookie);
    5eeb:	mov    -0x40(%rbp),%r8
    5eef:	mov    %r11d,%r9d
    5ef2:	mov    $0x2,%ecx
    5ef7:	mov    %r13,%rdx
    5efa:	mov    %r13,%rdi
    5efd:	mov    %r10d,-0x38(%rbp)
    5f01:	mov    %r11d,-0x50(%rbp)
    5f05:	callq  5f0a <vfs_rename+0x3ba>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:107
	fsnotify(new_dir, new_dir_mask, new_dir, FSNOTIFY_EVENT_INODE, new_name, fs_cookie);
    5f0a:	mov    -0x50(%rbp),%r11d
    5f0e:	mov    -0x38(%rbp),%r10d
    5f12:	mov    $0x2,%ecx
    5f17:	mov    -0x48(%rbp),%r8
    5f1b:	mov    %r14,%rdx
    5f1e:	mov    %r14,%rdi
    5f21:	mov    %r11d,%r9d
    5f24:	mov    %r10d,%esi
    5f27:	callq  5f2c <vfs_rename+0x3dc>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:109

	if (target)
    5f2c:	test   %rbx,%rbx
    5f2f:	je     5f4c <vfs_rename+0x3fc>
fsnotify_link_count():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:82
/*
 * fsnotify_link_count - inode's link count changed
 */
static inline void fsnotify_link_count(struct inode *inode)
{
	fsnotify(inode, FS_ATTRIB, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
    5f31:	xor    %r9d,%r9d
    5f34:	xor    %r8d,%r8d
    5f37:	mov    $0x2,%ecx
    5f3c:	mov    %rbx,%rdx
    5f3f:	mov    $0x4,%esi
    5f44:	mov    %rbx,%rdi
    5f47:	callq  5f4c <vfs_rename+0x3fc>
fsnotify_move():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:112
	fsnotify(new_dir, new_dir_mask, new_dir, FSNOTIFY_EVENT_INODE, new_name, fs_cookie);

	if (target)
		fsnotify_link_count(target);

	if (source)
    5f4c:	mov    -0x30(%rbp),%rdi
    5f50:	test   %rdi,%rdi
    5f53:	je     5f6e <vfs_rename+0x41e>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:113
		fsnotify(source, FS_MOVE_SELF, moved->d_inode, FSNOTIFY_EVENT_INODE, NULL, 0);
    5f55:	mov    0x30(%r15),%rdx
    5f59:	xor    %r9d,%r9d
    5f5c:	xor    %r8d,%r8d
    5f5f:	mov    $0x2,%ecx
    5f64:	mov    $0x800,%esi
    5f69:	callq  5f6e <vfs_rename+0x41e>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5f6e:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    5f77:	mov    $0x0,%rax
    5f7e:	add    $0x4a8,%rdx
    5f85:	jmp    5f98 <vfs_rename+0x448>
    5f87:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5f90:	test   %cl,%cl
    5f92:	je     6270 <vfs_rename+0x720>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5f98:	add    $0x1,%rdx
    5f9c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5fa0:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5fa4:	cmp    -0x1(%rax),%cl
    5fa7:	je     5f90 <vfs_rename+0x440>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5fa9:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    5fb2:	mov    $0x0,%rax
    5fb9:	add    $0x4a8,%rdx
    5fc0:	jmp    5fd0 <vfs_rename+0x480>
    5fc2:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    5fc8:	test   %cl,%cl
    5fca:	je     6270 <vfs_rename+0x720>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    5fd0:	add    $0x1,%rdx
    5fd4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    5fd8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    5fdc:	cmp    -0x1(%rax),%cl
    5fdf:	je     5fc8 <vfs_rename+0x478>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    5fe1:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    5fea:	mov    $0x0,%rax
    5ff1:	add    $0x4a8,%rdx
    5ff8:	jmp    6004 <vfs_rename+0x4b4>
    5ffa:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6000:	test   %cl,%cl
    6002:	je     6050 <vfs_rename+0x500>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6004:	add    $0x1,%rdx
    6008:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    600c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    6010:	cmp    -0x1(%rax),%cl
    6013:	je     6000 <vfs_rename+0x4b0>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    6015:	mov    %gs:0x0,%rax
    601e:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    6025:	test   %rax,%rax
    6028:	je     5d74 <vfs_rename+0x224>
    602e:	mov    (%rax),%eax
    6030:	test   %eax,%eax
    6032:	jne    5d74 <vfs_rename+0x224>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    6038:	mov    $0x4,%edx
    603d:	mov    %r15,%rsi
    6040:	mov    %r14,%rdi
    6043:	callq  6048 <vfs_rename+0x4f8>
    6048:	jmpq   5d74 <vfs_rename+0x224>
    604d:	nopl   (%rax)
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    6050:	cmpb   $0x0,0x0(%rip)        # 6057 <vfs_rename+0x507>
    6057:	mov    0x0(%rip),%rax        # 605e <vfs_rename+0x50e>
    605e:	jne    601e <vfs_rename+0x4ce>
    6060:	jmp    6015 <vfs_rename+0x4c5>
    6062:	nopw   0x0(%rax,%rax,1)
vfs_rename_dir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4094
	dput(new_dentry);
	return error;
}

/**
 * vfs_rename - rename a filesystem object
    6068:	cmpq   $0x0,-0x30(%rbp)
    606d:	movl   $0xfffffff0,-0x34(%rbp)
    6074:	je     5e95 <vfs_rename+0x345>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4095
 * @old_dir:	parent of source
    607a:	mov    -0x30(%rbp),%rdi
    607e:	add    $0xa8,%rdi
    6085:	callq  608a <vfs_rename+0x53a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4096
 * @old_dentry:	source
    608a:	mov    %rbx,%rdi
    608d:	callq  6092 <vfs_rename+0x542>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4097
 * @new_dir:	parent of destination
    6092:	mov    -0x34(%rbp),%ecx
    6095:	test   %ecx,%ecx
    6097:	jne    5d74 <vfs_rename+0x224>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4098
 * @new_dentry:	destination
    609d:	mov    0x28(%r13),%rax
    60a1:	mov    0x28(%rax),%rax
    60a5:	testb  $0x80,0x9(%rax)
    60a9:	jne    5ea8 <vfs_rename+0x358>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4099
 * @delegated_inode: returns an inode needing a delegation break
    60af:	mov    %rbx,%rsi
    60b2:	mov    %r15,%rdi
    60b5:	callq  60ba <vfs_rename+0x56a>
    60ba:	jmpq   5ea8 <vfs_rename+0x358>
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    60bf:	mov    -0x48(%rbp),%rax
    60c3:	cmpq   $0x0,0x148(%rax)
    60cb:	je     61dc <vfs_rename+0x68c>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    60d1:	mov    $0x4,%edx
    60d6:	mov    %rax,%rdi
    60d9:	mov    $0x801,%esi
    60de:	callq  60e3 <vfs_rename+0x593>
try_break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1983
static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(inode, O_WRONLY|O_NONBLOCK);
	if (ret == -EWOULDBLOCK && delegated_inode) {
    60e3:	mov    -0x30(%rbp),%rdi
    60e7:	test   %rdi,%rdi
    60ea:	setne  %dl
    60ed:	cmp    $0xfffffff5,%eax
    60f0:	mov    %edx,%ecx
    60f2:	jne    6185 <vfs_rename+0x635>
    60f8:	test   %dl,%dl
    60fa:	je     6185 <vfs_rename+0x635>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1984
		*delegated_inode = inode;
    6100:	mov    -0x48(%rbp),%rax
    6104:	mov    %rax,(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1985
		ihold(inode);
    6107:	mov    %rax,%rdi
    610a:	callq  610f <vfs_rename+0x5bf>
    610f:	movl   $0xfffffff5,-0x34(%rbp)
    6116:	jmpq   5e88 <vfs_rename+0x338>
vfs_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4188
	if (oldnd.last_type != LAST_NORM)
		goto exit2;

	new_dir = newnd.path.dentry;
	if (newnd.last_type != LAST_NORM)
		goto exit2;
    611b:	mov    $0xffffffff,%eax
    6120:	jmpq   5d80 <vfs_rename+0x230>
vfs_rename_dir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4083
	}
	error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
	if (error)
		goto out;

	if (target)
    6125:	cmpq   $0x0,-0x30(%rbp)
    612a:	je     5d25 <vfs_rename+0x1d5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4084
		dont_mount(new_dentry);
    6130:	mov    %rbx,%rdi
    6133:	callq  6138 <vfs_rename+0x5e8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4085
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
    6138:	mov    0x20(%r13),%rax
    613c:	mov    %rbx,%rcx
    613f:	mov    %r14,%rdx
    6142:	mov    %r15,%rsi
    6145:	mov    %r13,%rdi
    6148:	callq  *0x68(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4086
		d_move(old_dentry, new_dentry);
    614b:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4085
	if (error)
		goto out;

	if (target)
		dont_mount(new_dentry);
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
    614d:	mov    %eax,-0x34(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4086
		d_move(old_dentry, new_dentry);
    6150:	jne    607a <vfs_rename+0x52a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4090
out:
	unlock_two_nondirectories(source, target);
	dput(new_dentry);
	return error;
    6156:	mov    -0x30(%rbp),%rax
    615a:	orl    $0x10,0xc(%rax)
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    615e:	lea    0x58(%rbx),%rax
    6162:	mov    %rax,%rdi
    6165:	mov    %rax,-0x48(%rbp)
    6169:	callq  616e <vfs_rename+0x61e>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    616e:	mov    -0x48(%rbp),%rax
dont_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:393
}

static inline void dont_mount(struct dentry *dentry)
{
	spin_lock(&dentry->d_lock);
	dentry->d_flags |= DCACHE_CANT_MOUNT;
    6172:	orl    $0x100,(%rbx)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
    6178:	mov    %rax,%rdi
    617b:	callq  6180 <vfs_rename+0x630>
    6180:	jmpq   607a <vfs_rename+0x52a>
vfs_rename_other():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4123
	const unsigned char *old_name;

	if (old_dentry->d_inode == new_dentry->d_inode)
 		return 0;
 
	error = may_delete(old_dir, old_dentry, is_dir);
    6185:	test   %eax,%eax
    6187:	jne    61fd <vfs_rename+0x6ad>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4125
	if (error)
		return error;
    6189:	mov    -0x50(%rbp),%rax
    618d:	mov    %ecx,-0x38(%rbp)
    6190:	test   %rax,%rax
    6193:	je     61e6 <vfs_rename+0x696>
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    6195:	cmpq   $0x0,0x148(%rax)
    619d:	je     6215 <vfs_rename+0x6c5>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    619f:	mov    $0x4,%edx
    61a4:	mov    $0x801,%esi
    61a9:	mov    %rax,%rdi
    61ac:	callq  61b1 <vfs_rename+0x661>
try_break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1983
static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(inode, O_WRONLY|O_NONBLOCK);
	if (ret == -EWOULDBLOCK && delegated_inode) {
    61b1:	cmp    $0xfffffff5,%eax
    61b4:	jne    6211 <vfs_rename+0x6c1>
    61b6:	mov    -0x38(%rbp),%ecx
    61b9:	test   %cl,%cl
    61bb:	je     6211 <vfs_rename+0x6c1>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1984
		*delegated_inode = inode;
    61bd:	mov    -0x30(%rbp),%rdi
    61c1:	mov    -0x50(%rbp),%rax
    61c5:	mov    %rax,(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1985
		ihold(inode);
    61c8:	mov    %rax,%rdi
    61cb:	callq  61d0 <vfs_rename+0x680>
    61d0:	movl   $0xfffffff5,-0x34(%rbp)
    61d7:	jmpq   5e88 <vfs_rename+0x338>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1983
static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(inode, O_WRONLY|O_NONBLOCK);
	if (ret == -EWOULDBLOCK && delegated_inode) {
    61dc:	cmpq   $0x0,-0x30(%rbp)
    61e1:	setne  %cl
    61e4:	jmp    6189 <vfs_rename+0x639>
vfs_rename_other():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4130

	if (!new_dentry->d_inode)
		error = may_create(new_dir, new_dentry);
	else
		error = may_delete(new_dir, new_dentry, is_dir);
    61e6:	mov    0x20(%r13),%rax
    61ea:	mov    %rbx,%rcx
    61ed:	mov    %r14,%rdx
    61f0:	mov    %r15,%rsi
    61f3:	mov    %r13,%rdi
    61f6:	callq  *0x68(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4131
	if (error)
    61f9:	test   %eax,%eax
    61fb:	je     624e <vfs_rename+0x6fe>
    61fd:	mov    %eax,-0x34(%rbp)
    6200:	jmpq   5e88 <vfs_rename+0x338>
vfs_rename_dir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4078
		goto out;
	if (target) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
    6205:	movl   $0xffffffe1,-0x34(%rbp)
    620c:	jmpq   608a <vfs_rename+0x53a>
vfs_rename_other():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4127
 
	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!new_dentry->d_inode)
    6211:	test   %eax,%eax
    6213:	jne    61fd <vfs_rename+0x6ad>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4130
		error = may_create(new_dir, new_dentry);
	else
		error = may_delete(new_dir, new_dentry, is_dir);
    6215:	mov    0x20(%r13),%rax
    6219:	mov    %rbx,%rcx
    621c:	mov    %r14,%rdx
    621f:	mov    %r15,%rsi
    6222:	mov    %r13,%rdi
    6225:	callq  *0x68(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4131
	if (error)
    6228:	test   %eax,%eax
    622a:	jne    61fd <vfs_rename+0x6ad>
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    622c:	lea    0x58(%rbx),%rax
    6230:	mov    %rax,%rdi
    6233:	mov    %rax,-0x30(%rbp)
    6237:	callq  623c <vfs_rename+0x6ec>
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    623c:	mov    -0x30(%rbp),%rax
dont_mount():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:393
    6240:	orl    $0x100,(%rbx)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
    6246:	mov    %rax,%rdi
    6249:	callq  624e <vfs_rename+0x6fe>
vfs_rename_other():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4136
		return error;

	if (!old_dir->i_op->rename)
		return -EPERM;

    624e:	mov    0x28(%r13),%rax
    6252:	mov    0x28(%rax),%rax
    6256:	testb  $0x80,0x9(%rax)
    625a:	jne    5e88 <vfs_rename+0x338>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4137
	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
    6260:	mov    %rbx,%rsi
    6263:	mov    %r15,%rdi
    6266:	callq  626b <vfs_rename+0x71b>
    626b:	jmpq   5e88 <vfs_rename+0x338>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    6270:	mov    %gs:0x0,%rdx
fsnotify_move():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    6279:	mov    $0x0,%rsi
    6280:	add    $0x4a8,%rdx
    6287:	mov    $0x0,%rdi
    628e:	xor    %eax,%eax
    6290:	callq  6295 <vfs_rename+0x745>
    6295:	jmpq   5fe1 <vfs_rename+0x491>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    629a:	mov    %gs:0x0,%rdx
vfs_rename_other():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
	return dentry;
}

static inline struct dentry *dget(struct dentry *dentry)
{
  MY_PRINTK(get_current()->comm);
    62a3:	mov    $0x0,%rsi
    62aa:	add    $0x4a8,%rdx
    62b1:	mov    $0x0,%rdi
    62b8:	xor    %eax,%eax
    62ba:	callq  62bf <vfs_rename+0x76f>
    62bf:	jmpq   5e51 <vfs_rename+0x301>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    62c4:	mov    %gs:0x0,%rdx
vfs_rename_dir():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:360
    62cd:	mov    $0x0,%rsi
    62d4:	add    $0x4a8,%rdx
    62db:	mov    $0x0,%rdi
    62e2:	xor    %eax,%eax
    62e4:	callq  62e9 <vfs_rename+0x799>
    62e9:	jmpq   5cc1 <vfs_rename+0x171>
vfs_rename():
    62ee:	xchg   %ax,%ax

00000000000062f0 <SYSC_renameat>:
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4206
	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
	/* source must exist */
	error = -ENOENT;
    62f0:	push   %rbp
    62f1:	mov    %rsp,%rbp
    62f4:	push   %r15
    62f6:	push   %r14
    62f8:	mov    %rsi,%r14
    62fb:	push   %r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4214
	/* unless the source is a directory trailing slashes give -ENOTDIR */
	if (!d_is_directory(old_dentry) && !d_is_autodir(old_dentry)) {
		error = -ENOTDIR;
		if (oldnd.last.name[oldnd.last.len])
			goto exit4;
		if (newnd.last.name[newnd.last.len])
    62fd:	xor    %r13d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4206
	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
	/* source must exist */
	error = -ENOENT;
    6300:	push   %r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4287
	if (copy_to_user(buffer, link, len))
		len = -EFAULT;
out:
	return len;
}

    6302:	mov    %edi,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4206
	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
	/* source must exist */
	error = -ENOENT;
    6305:	push   %rbx
    6306:	and    $0xfffffffffffffff0,%rsp
    630a:	sub    $0x190,%rsp
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    6311:	lea    0x60(%rsp),%rax
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4206
	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
	/* source must exist */
	error = -ENOENT;
    6316:	mov    %edx,0x44(%rsp)
    631a:	mov    %rcx,0x38(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4211
	if (d_is_negative(old_dentry))
		goto exit4;
	/* unless the source is a directory trailing slashes give -ENOTDIR */
	if (!d_is_directory(old_dentry) && !d_is_autodir(old_dentry)) {
		error = -ENOTDIR;
    631f:	movq   $0x0,0x48(%rsp)
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    6328:	mov    %rax,0x20(%rsp)
    632d:	lea    0x100(%rsp),%rax
    6335:	mov    %rax,0x18(%rsp)
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4218
			goto exit4;
		if (newnd.last.name[newnd.last.len])
			goto exit4;
	}
	/* source should not be ancestor of target */
	error = -EINVAL;
    633a:	lea    0x50(%rsp),%rdx
    633f:	mov    %r13d,%ecx
    6342:	mov    %r14,%rsi
    6345:	mov    %r12d,%edi
    6348:	callq  46b0 <user_path_parent>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4219
	if (old_dentry == trap)
    634d:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4218
			goto exit4;
		if (newnd.last.name[newnd.last.len])
			goto exit4;
	}
	/* source should not be ancestor of target */
	error = -EINVAL;
    6353:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4219
	if (old_dentry == trap)
    6356:	ja     66b1 <SYSC_renameat+0x3c1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4224
		goto exit4;
	new_dentry = lookup_hash(&newnd);
	error = PTR_ERR(new_dentry);
	if (IS_ERR(new_dentry))
		goto exit4;
    635c:	mov    0x38(%rsp),%rsi
    6361:	mov    0x44(%rsp),%edi
    6365:	lea    0xf0(%rsp),%rdx
    636d:	mov    %r13d,%ecx
    6370:	callq  46b0 <user_path_parent>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4225
	/* target should not be an ancestor of source */
    6375:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4224
	if (old_dentry == trap)
		goto exit4;
	new_dentry = lookup_hash(&newnd);
	error = PTR_ERR(new_dentry);
	if (IS_ERR(new_dentry))
		goto exit4;
    637b:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4225
	/* target should not be an ancestor of source */
    637e:	ja     66b9 <SYSC_renameat+0x3c9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4231
	error = -ENOTEMPTY;
	if (new_dentry == trap)
		goto exit5;

	error = security_path_rename(&oldnd.path, old_dentry,
				     &newnd.path, new_dentry);
    6384:	mov    0x50(%rsp),%rdi
    6389:	cmp    0xf0(%rsp),%rdi
    6391:	je     63f0 <SYSC_renameat+0x100>
    6393:	mov    0xf8(%rsp),%rdi
    639b:	mov    %rax,%r12
    639e:	mov    $0xffffffffffffffee,%r13
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    63a5:	callq  63aa <SYSC_renameat+0xba>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    63aa:	mov    0xf0(%rsp),%rdi
    63b2:	callq  63b7 <SYSC_renameat+0xc7>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4306
	if (IS_ERR(cookie))
		return PTR_ERR(cookie);

	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));
	if (dentry->d_inode->i_op->put_link)
		dentry->d_inode->i_op->put_link(dentry, &nd, cookie);
    63b7:	mov    %r12,%rdi
    63ba:	callq  63bf <SYSC_renameat+0xcf>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    63bf:	mov    0x58(%rsp),%rdi
    63c4:	callq  63c9 <SYSC_renameat+0xd9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    63c9:	mov    0x50(%rsp),%rdi
    63ce:	callq  63d3 <SYSC_renameat+0xe3>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4309
	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));
	if (dentry->d_inode->i_op->put_link)
		dentry->d_inode->i_op->put_link(dentry, &nd, cookie);
	return res;
}

    63d3:	mov    %rbx,%rdi
    63d6:	callq  63db <SYSC_renameat+0xeb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4317
{
	char *kaddr;
	struct page *page;
	struct address_space *mapping = dentry->d_inode->i_mapping;
	page = read_mapping_page(mapping, 0, NULL);
	if (IS_ERR(page))
    63db:	lea    -0x28(%rbp),%rsp
    63df:	mov    %r13,%rax
    63e2:	pop    %rbx
    63e3:	pop    %r12
    63e5:	pop    %r13
    63e7:	pop    %r14
    63e9:	pop    %r15
    63eb:	pop    %rbp
    63ec:	retq   
    63ed:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4236
				     &newnd.path, new_dentry);
	if (error)
		goto exit5;
	error = vfs_rename(old_dir->d_inode, old_dentry,
				   new_dir->d_inode, new_dentry,
				   &delegated_inode);
    63f0:	mov    0x94(%rsp),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4234

	error = security_path_rename(&oldnd.path, old_dentry,
				     &newnd.path, new_dentry);
	if (error)
		goto exit5;
	error = vfs_rename(old_dir->d_inode, old_dentry,
    63f7:	mov    0x58(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4236
				   new_dir->d_inode, new_dentry,
				   &delegated_inode);
    63fc:	test   %edx,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4234

	error = security_path_rename(&oldnd.path, old_dentry,
				     &newnd.path, new_dentry);
	if (error)
		goto exit5;
	error = vfs_rename(old_dir->d_inode, old_dentry,
    63fe:	mov    %rax,0x30(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4236
				   new_dir->d_inode, new_dentry,
				   &delegated_inode);
    6403:	je     6420 <SYSC_renameat+0x130>
    6405:	mov    %r15,%r12
    6408:	mov    0xf8(%rsp),%rdi
    6410:	mov    $0xfffffffffffffff0,%r13
    6417:	jmp    63a5 <SYSC_renameat+0xb5>
    6419:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4239
exit5:
	dput(new_dentry);
exit4:
    6420:	mov    0xf8(%rsp),%rax
    6428:	mov    %rax,0x28(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4240
	dput(old_dentry);
    642d:	mov    0x134(%rsp),%eax
    6434:	test   %eax,%eax
    6436:	je     6450 <SYSC_renameat+0x160>
    6438:	mov    %r15,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4239
	error = vfs_rename(old_dir->d_inode, old_dentry,
				   new_dir->d_inode, new_dentry,
				   &delegated_inode);
exit5:
	dput(new_dentry);
exit4:
    643b:	mov    0x28(%rsp),%rdi
    6440:	mov    $0xfffffffffffffff0,%r13
    6447:	jmpq   63a5 <SYSC_renameat+0xb5>
    644c:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4243
	dput(old_dentry);
exit3:
	unlock_rename(new_dir, old_dir);
	if (delegated_inode) {
    6450:	callq  6455 <SYSC_renameat+0x165>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4244
		error = break_deleg_wait(&delegated_inode);
    6455:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4243
	dput(new_dentry);
exit4:
	dput(old_dentry);
exit3:
	unlock_rename(new_dir, old_dir);
	if (delegated_inode) {
    6457:	mov    %eax,0x10(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4244
		error = break_deleg_wait(&delegated_inode);
    645b:	jne    65f9 <SYSC_renameat+0x309>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4248
		if (!error)
			goto retry_deleg;
	}
	mnt_drop_write(oldnd.path.mnt);
    6461:	mov    0x128(%rsp),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4247
	unlock_rename(new_dir, old_dir);
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry_deleg;
	}
    6468:	andl   $0xffffffef,0x88(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4249
	mnt_drop_write(oldnd.path.mnt);
exit2:
    6470:	mov    %r13d,0x40(%rsp)
    6475:	mov    %rbx,0x8(%rsp)
    647a:	mov    %r12d,0x4(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4248
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry_deleg;
	}
	mnt_drop_write(oldnd.path.mnt);
    647f:	and    $0xffffffef,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4249
exit2:
    6482:	or     $0x8,%ah
    6485:	mov    %eax,0x128(%rsp)
    648c:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4252
	if (retry_estale(error, lookup_flags))
		should_retry = true;
	path_put(&newnd.path);
    6490:	mov    0x30(%rsp),%rsi
    6495:	mov    0x28(%rsp),%rdi
    649a:	callq  649f <SYSC_renameat+0x1af>
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    649f:	mov    0x88(%rsp),%edx
    64a6:	mov    0x58(%rsp),%rsi
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4252
	}
	mnt_drop_write(oldnd.path.mnt);
exit2:
	if (retry_estale(error, lookup_flags))
		should_retry = true;
	path_put(&newnd.path);
    64ab:	mov    %rax,%r13
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    64ae:	mov    0x20(%rsp),%rdi
    64b3:	callq  9a0 <__lookup_hash>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4256
		should_retry = true;
	path_put(&newnd.path);
	putname(to);
exit1:
	path_put(&oldnd.path);
	putname(from);
    64b8:	cmp    $0xfffffffffffff000,%rax
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    64be:	mov    %rax,%r12
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4256
		should_retry = true;
	path_put(&newnd.path);
	putname(to);
exit1:
	path_put(&oldnd.path);
	putname(from);
    64c1:	ja     66f2 <SYSC_renameat+0x402>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4260
	if (should_retry) {
		should_retry = false;
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
    64c7:	mov    (%rax),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4259
exit1:
	path_put(&oldnd.path);
	putname(from);
	if (should_retry) {
		should_retry = false;
		lookup_flags |= LOOKUP_REVAL;
    64c9:	mov    $0xfffffffe,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4260
		goto retry;
    64ce:	and    $0x700000,%eax
    64d3:	je     6581 <SYSC_renameat+0x291>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4263
	}
exit:
	return error;
    64d9:	cmp    $0x100000,%eax
    64de:	je     6511 <SYSC_renameat+0x221>
    64e0:	cmp    $0x200000,%eax
    64e5:	je     6511 <SYSC_renameat+0x221>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4265
}

    64e7:	mov    0x64(%rsp),%eax
    64eb:	mov    0x68(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4264
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
exit:
	return error;
}
    64f0:	mov    $0xec,%bl
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4265

    64f2:	cmpb   $0x0,(%rdx,%rax,1)
    64f6:	jne    6581 <SYSC_renameat+0x291>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4267
SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
    64fc:	mov    0x104(%rsp),%eax
    6503:	mov    0x108(%rsp),%rdx
    650b:	cmpb   $0x0,(%rdx,%rax,1)
    650f:	jne    6581 <SYSC_renameat+0x291>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4272
	return sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);
}

int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
{
    6511:	cmp    %r12,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4271
SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);
}

int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
    6514:	mov    $0xffffffea,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4272
{
    6519:	je     6581 <SYSC_renameat+0x291>
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    651b:	mov    0x128(%rsp),%edx
    6522:	mov    0xf8(%rsp),%rsi
    652a:	mov    0x18(%rsp),%rdi
    652f:	callq  9a0 <__lookup_hash>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4276
int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
{
	int len;

	len = PTR_ERR(link);
	if (IS_ERR(link))
    6534:	cmp    $0xfffffffffffff000,%rax
lookup_hash():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2078
 * using this helper needs to be prepared for that.
 */
struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
{
	struct qstr this;
	unsigned int c;
    653a:	mov    %rax,%r10
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4276
int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
{
	int len;

	len = PTR_ERR(link);
	if (IS_ERR(link))
    653d:	ja     66f9 <SYSC_renameat+0x409>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4280
		goto out;

	len = strlen(link);
	if (len > (unsigned) buflen)
    6543:	cmp    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4279

	len = PTR_ERR(link);
	if (IS_ERR(link))
		goto out;

	len = strlen(link);
    6546:	mov    $0xffffffd9,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4280
	if (len > (unsigned) buflen)
    654b:	je     6579 <SYSC_renameat+0x289>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4283
		len = buflen;
	if (copy_to_user(buffer, link, len))
		len = -EFAULT;
    654d:	lea    0xf0(%rsp),%rdx
    6555:	lea    0x50(%rsp),%rdi
    655a:	mov    %rax,%rcx
    655d:	mov    %r12,%rsi
    6560:	mov    %rax,0x10(%rsp)
    6565:	callq  656a <SYSC_renameat+0x27a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4285
out:
	return len;
    656a:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4283

	len = strlen(link);
	if (len > (unsigned) buflen)
		len = buflen;
	if (copy_to_user(buffer, link, len))
		len = -EFAULT;
    656c:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4285
out:
	return len;
    656e:	mov    0x10(%rsp),%r10
    6573:	je     6683 <SYSC_renameat+0x393>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4291
}

/*
 * A helper for ->readlink().  This should be used *ONLY* for symlinks that
 * have ->follow_link() touching nd only in nd_set_link().  Using (or not
 * using) it for any given inode is up to filesystem.
    6579:	mov    %r10,%rdi
    657c:	callq  6581 <SYSC_renameat+0x291>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4293
 */
int generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)
    6581:	mov    %r12,%rdi
    6584:	callq  6589 <SYSC_renameat+0x299>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4295
{
	struct nameidata nd;
    6589:	mov    0x28(%rsp),%rdi
    658e:	mov    0x30(%rsp),%rsi
    6593:	callq  6598 <SYSC_renameat+0x2a8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4296
	void *cookie;
    6598:	mov    0x48(%rsp),%rdi
    659d:	test   %rdi,%rdi
    65a0:	je     65dc <SYSC_renameat+0x2ec>
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    65a2:	cmpq   $0x0,0x148(%rdi)
    65aa:	je     6670 <SYSC_renameat+0x380>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    65b0:	mov    $0x4,%edx
    65b5:	mov    $0x1,%esi
    65ba:	callq  65bf <SYSC_renameat+0x2cf>
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    65bf:	mov    0x48(%rsp),%rdi
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
		return __break_lease(inode, mode, FL_DELEG);
    65c4:	mov    %eax,%ebx
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    65c6:	callq  65cb <SYSC_renameat+0x2db>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4298
	int res;

    65cb:	test   %ebx,%ebx
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    65cd:	movq   $0x0,0x48(%rsp)
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4298
    65d6:	je     6490 <SYSC_renameat+0x1a0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4301
	nd.depth = 0;
	cookie = dentry->d_inode->i_op->follow_link(dentry, &nd);
	if (IS_ERR(cookie))
    65dc:	mov    0x50(%rsp),%rdi
    65e1:	mov    %ebx,0x10(%rsp)
    65e5:	mov    0x40(%rsp),%r13d
    65ea:	mov    0x8(%rsp),%rbx
    65ef:	mov    0x4(%rsp),%r12d
    65f4:	callq  65f9 <SYSC_renameat+0x309>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    65f9:	cmpl   $0xffffff8c,0x10(%rsp)
    65fe:	jne    66dd <SYSC_renameat+0x3ed>
    6604:	test   %r13d,%r13d
    6607:	je     6620 <SYSC_renameat+0x330>
    6609:	mov    %r15,%r12
    660c:	mov    0xf8(%rsp),%rdi
    6614:	mov    $0xffffffffffffff8c,%r13
    661b:	jmpq   63a5 <SYSC_renameat+0xb5>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    6620:	mov    0xf8(%rsp),%rdi
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4312
	return res;
}

/* get the link contents into pagecache */
static char *page_getlink(struct dentry * dentry, struct page **ppage)
{
    6628:	mov    $0x20,%r13d
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    662e:	callq  6633 <SYSC_renameat+0x343>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    6633:	mov    0xf0(%rsp),%rdi
    663b:	callq  6640 <SYSC_renameat+0x350>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4306
	if (IS_ERR(cookie))
		return PTR_ERR(cookie);

	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));
	if (dentry->d_inode->i_op->put_link)
		dentry->d_inode->i_op->put_link(dentry, &nd, cookie);
    6640:	mov    %r15,%rdi
    6643:	callq  6648 <SYSC_renameat+0x358>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    6648:	mov    0x58(%rsp),%rdi
    664d:	callq  6652 <SYSC_renameat+0x362>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    6652:	mov    0x50(%rsp),%rdi
    6657:	callq  665c <SYSC_renameat+0x36c>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4309
	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));
	if (dentry->d_inode->i_op->put_link)
		dentry->d_inode->i_op->put_link(dentry, &nd, cookie);
	return res;
}

    665c:	mov    %rbx,%rdi
    665f:	callq  6664 <SYSC_renameat+0x374>
    6664:	jmpq   633a <SYSC_renameat+0x4a>
    6669:	nopl   0x0(%rax)
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    6670:	callq  6675 <SYSC_renameat+0x385>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    6675:	movq   $0x0,0x48(%rsp)
    667e:	jmpq   6490 <SYSC_renameat+0x1a0>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4287
	if (copy_to_user(buffer, link, len))
		len = -EFAULT;
out:
	return len;
}

    6683:	mov    0x28(%rsp),%rax
    6688:	lea    0x48(%rsp),%r8
    668d:	mov    %r10,%rcx
    6690:	mov    %r12,%rsi
    6693:	mov    0x30(%rax),%rdx
    6697:	mov    0x30(%rsp),%rax
    669c:	mov    0x30(%rax),%rdi
    66a0:	callq  66a5 <SYSC_renameat+0x3b5>
    66a5:	mov    0x10(%rsp),%r10
    66aa:	mov    %eax,%ebx
    66ac:	jmpq   6579 <SYSC_renameat+0x289>
    66b1:	movslq %eax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4221
	}
	/* source should not be ancestor of target */
	error = -EINVAL;
	if (old_dentry == trap)
		goto exit4;
	new_dentry = lookup_hash(&newnd);
    66b4:	jmpq   63db <SYSC_renameat+0xeb>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    66b9:	mov    0x58(%rsp),%rdi
    66be:	movslq %r15d,%r13
    66c1:	callq  66c6 <SYSC_renameat+0x3d6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    66c6:	mov    0x50(%rsp),%rdi
    66cb:	callq  66d0 <SYSC_renameat+0x3e0>
SYSC_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4309
	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));
	if (dentry->d_inode->i_op->put_link)
		dentry->d_inode->i_op->put_link(dentry, &nd, cookie);
	return res;
}

    66d0:	mov    %rbx,%rdi
    66d3:	callq  66d8 <SYSC_renameat+0x3e8>
    66d8:	jmpq   63db <SYSC_renameat+0xeb>
    66dd:	mov    %r15,%r12
    66e0:	movslq 0x10(%rsp),%r13
    66e5:	mov    0xf8(%rsp),%rdi
    66ed:	jmpq   63a5 <SYSC_renameat+0xb5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4255
	if (retry_estale(error, lookup_flags))
		should_retry = true;
	path_put(&newnd.path);
	putname(to);
exit1:
	path_put(&oldnd.path);
    66f2:	mov    %eax,%ebx
    66f4:	jmpq   6589 <SYSC_renameat+0x299>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4275

int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
{
	int len;

	len = PTR_ERR(link);
    66f9:	mov    %eax,%ebx
    66fb:	jmpq   6581 <SYSC_renameat+0x291>

0000000000006700 <vfs_symlink>:
vfs_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3818
		goto retry;
	}
out_putname:
	putname(from);
	return error;
}
    6700:	callq  6705 <vfs_symlink+0x5>
    6705:	push   %rbp
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6706:	mov    0x0(%rip),%r8d        # 670d <vfs_symlink+0xd>
    670d:	mov    0x0(%rip),%ecx        # 6713 <vfs_symlink+0x13>
vfs_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3818
		goto retry;
	}
out_putname:
	putname(from);
	return error;
}
    6713:	mov    %rsp,%rbp
    6716:	push   %r13
    6718:	mov    %rdx,%r13
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    671b:	mov    $0x4,%edx
vfs_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3818
		goto retry;
	}
out_putname:
	putname(from);
	return error;
}
    6720:	push   %r12
    6722:	mov    %rsi,%r12
    6725:	push   %rbx
    6726:	mov    %rdi,%rbx
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6729:	callq  672e <vfs_symlink+0x2e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
	if (p) {
    672e:	cmpq   $0x0,0x30(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2461
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
    6734:	mov    $0xffffffef,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
	if (p) {
    6739:	jne    6775 <vfs_symlink+0x75>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    673b:	testb  $0x10,0xc(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2463
		return p;
    673f:	mov    $0xfe,%al
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    6741:	jne    6775 <vfs_symlink+0x75>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
		return p;
	}
    6743:	mov    $0x3,%esi
    6748:	mov    %rbx,%rdi
    674b:	callq  6750 <vfs_symlink+0x50>
vfs_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3821
	putname(from);
	return error;
}

SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)
{
    6750:	test   %eax,%eax
    6752:	jne    6775 <vfs_symlink+0x75>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3824
	return sys_symlinkat(oldname, AT_FDCWD, newname);
}

    6754:	mov    0x20(%rbx),%rax
    6758:	cmpq   $0x0,0x48(%rax)
    675d:	je     68b2 <vfs_symlink+0x1b2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3827
/**
 * vfs_link - create a new link
 * @old_dentry:	object to be linked
    6763:	mov    %r13,%rdx
    6766:	mov    %r12,%rsi
    6769:	mov    %rbx,%rdi
    676c:	callq  6771 <vfs_symlink+0x71>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3828
 * @dir:	new parent
    6771:	test   %eax,%eax
    6773:	je     6780 <vfs_symlink+0x80>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3835
 * @delegated_inode: returns inode needing a delegation break
 *
 * The caller must hold dir->i_mutex
 *
 * If vfs_link discovers a delegation on the to-be-linked file in need
 * of breaking, it will return -EWOULDBLOCK and return a reference to the
    6775:	pop    %rbx
    6776:	pop    %r12
    6778:	pop    %r13
    677a:	pop    %rbp
    677b:	retq   
    677c:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3831
 * vfs_link - create a new link
 * @old_dentry:	object to be linked
 * @dir:	new parent
 * @new_dentry:	where to create the new link
 * @delegated_inode: returns inode needing a delegation break
 *
    6780:	mov    0x20(%rbx),%rax
    6784:	mov    %r13,%rdx
    6787:	mov    %r12,%rsi
    678a:	mov    %rbx,%rdi
    678d:	callq  *0x48(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3832
 * The caller must hold dir->i_mutex
    6790:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3831
 * vfs_link - create a new link
 * @old_dentry:	object to be linked
 * @dir:	new parent
 * @new_dentry:	where to create the new link
 * @delegated_inode: returns inode needing a delegation break
 *
    6792:	mov    %eax,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3832
 * The caller must hold dir->i_mutex
    6795:	je     67a8 <vfs_symlink+0xa8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3835
 *
 * If vfs_link discovers a delegation on the to-be-linked file in need
 * of breaking, it will return -EWOULDBLOCK and return a reference to the
    6797:	pop    %rbx
    6798:	pop    %r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3831
 * vfs_link - create a new link
 * @old_dentry:	object to be linked
 * @dir:	new parent
 * @new_dentry:	where to create the new link
 * @delegated_inode: returns inode needing a delegation break
 *
    679a:	mov    %r13d,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3835
 * The caller must hold dir->i_mutex
 *
 * If vfs_link discovers a delegation on the to-be-linked file in need
 * of breaking, it will return -EWOULDBLOCK and return a reference to the
    679d:	pop    %r13
    679f:	pop    %rbp
    67a0:	retq   
    67a1:	nopl   0x0(%rax)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    67a8:	mov    %gs:0x0,%rcx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    67b1:	mov    $0x0,%rdx
    67b8:	add    $0x4a8,%rcx
    67bf:	jmp    67d0 <vfs_symlink+0xd0>
    67c1:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    67c8:	test   %al,%al
    67ca:	je     68bc <vfs_symlink+0x1bc>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    67d0:	add    $0x1,%rcx
    67d4:	movzbl -0x1(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    67d8:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    67dc:	cmp    -0x1(%rdx),%al
    67df:	je     67c8 <vfs_symlink+0xc8>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    67e1:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    67ea:	mov    $0x0,%rax
    67f1:	add    $0x4a8,%rdx
    67f8:	jmp    6808 <vfs_symlink+0x108>
    67fa:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6800:	test   %cl,%cl
    6802:	je     68bc <vfs_symlink+0x1bc>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6808:	add    $0x1,%rdx
    680c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    6810:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    6814:	cmp    -0x1(%rax),%cl
    6817:	je     6800 <vfs_symlink+0x100>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6819:	mov    %gs:0x0,%rcx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    6822:	mov    $0x0,%rdx
    6829:	add    $0x4a8,%rcx
    6830:	jmp    683c <vfs_symlink+0x13c>
    6832:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6838:	test   %al,%al
    683a:	je     68a0 <vfs_symlink+0x1a0>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    683c:	add    $0x1,%rcx
    6840:	movzbl -0x1(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    6844:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    6848:	cmp    -0x1(%rdx),%al
    684b:	je     6838 <vfs_symlink+0x138>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    684d:	mov    %gs:0x0,%rax
    6856:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    685d:	test   %rax,%rax
    6860:	je     6878 <vfs_symlink+0x178>
    6862:	mov    (%rax),%eax
    6864:	test   %eax,%eax
    6866:	jne    6878 <vfs_symlink+0x178>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    6868:	mov    $0x4,%edx
    686d:	mov    %r12,%rsi
    6870:	mov    %rbx,%rdi
    6873:	callq  6878 <vfs_symlink+0x178>
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:162
 */
static inline void fsnotify_create(struct inode *inode, struct dentry *dentry)
{
	audit_inode_child(inode, dentry, AUDIT_TYPE_CHILD_CREATE);

	fsnotify(inode, FS_CREATE, dentry->d_inode, FSNOTIFY_EVENT_INODE, dentry->d_name.name, 0);
    6878:	mov    0x30(%r12),%rdx
    687d:	mov    0x28(%r12),%r8
    6882:	xor    %r9d,%r9d
    6885:	mov    $0x2,%ecx
    688a:	mov    $0x100,%esi
    688f:	mov    %rbx,%rdi
    6892:	callq  6897 <vfs_symlink+0x197>
    6897:	jmpq   6797 <vfs_symlink+0x97>
    689c:	nopl   0x0(%rax)
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    68a0:	cmpb   $0x0,0x0(%rip)        # 68a7 <vfs_symlink+0x1a7>
    68a7:	mov    0x0(%rip),%rax        # 68ae <vfs_symlink+0x1ae>
    68ae:	jne    6856 <vfs_symlink+0x156>
    68b0:	jmp    684d <vfs_symlink+0x14d>
vfs_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3825
SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)
{
	return sys_symlinkat(oldname, AT_FDCWD, newname);
}

/**
    68b2:	mov    $0xffffffff,%eax
    68b7:	jmpq   6775 <vfs_symlink+0x75>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    68bc:	mov    %gs:0x0,%rdx
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    68c5:	mov    $0x0,%rsi
    68cc:	add    $0x4a8,%rdx
    68d3:	mov    $0x0,%rdi
    68da:	xor    %eax,%eax
    68dc:	callq  68e1 <vfs_symlink+0x1e1>
    68e1:	jmpq   6819 <vfs_symlink+0x119>
vfs_symlink():
    68e6:	nopw   %cs:0x0(%rax,%rax,1)

00000000000068f0 <vfs_mknod>:
vfs_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3401

SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev)
{
	struct dentry *dentry;
	struct path path;
	int error;
    68f0:	callq  68f5 <vfs_mknod+0x5>
    68f5:	push   %rbp
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    68f6:	mov    0x0(%rip),%r8d        # 68fd <vfs_mknod+0xd>
vfs_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3401

SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev)
{
	struct dentry *dentry;
	struct path path;
	int error;
    68fd:	mov    %rsp,%rbp
    6900:	push   %r15
    6902:	mov    %ecx,%r15d
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6905:	mov    0x0(%rip),%ecx        # 690b <vfs_mknod+0x1b>
vfs_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3401

SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev)
{
	struct dentry *dentry;
	struct path path;
	int error;
    690b:	push   %r14
    690d:	mov    %edx,%r14d
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6910:	mov    $0x4,%edx
vfs_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3401

SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev)
{
	struct dentry *dentry;
	struct path path;
	int error;
    6915:	push   %r13
    6917:	mov    %rsi,%r13
    691a:	push   %r12
    691c:	mov    %rdi,%r12
    691f:	push   %rbx
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2461
		return p;
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
    6920:	mov    $0xffffffef,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6925:	callq  692a <vfs_mknod+0x3a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
	if (p) {
    692a:	cmpq   $0x0,0x30(%r13)
    692f:	jne    6984 <vfs_mknod+0x94>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    6931:	testb  $0x10,0xc(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2463
		return p;
    6937:	mov    $0xfe,%bl
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    6939:	jne    6984 <vfs_mknod+0x94>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
		return p;
	}
    693b:	mov    $0x3,%esi
    6940:	mov    %r12,%rdi
    6943:	callq  6948 <vfs_mknod+0x58>
vfs_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3404
	struct dentry *dentry;
	struct path path;
	int error;
	unsigned int lookup_flags = 0;

	error = may_mknod(mode);
    6948:	test   %eax,%eax
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}
    694a:	mov    %eax,%ebx
vfs_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3404
	struct dentry *dentry;
	struct path path;
	int error;
	unsigned int lookup_flags = 0;

	error = may_mknod(mode);
    694c:	jne    6984 <vfs_mknod+0x94>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3407
	if (error)
		return error;
retry:
    694e:	mov    %r14d,%eax
    6951:	and    $0xb000,%ax
    6955:	cmp    $0x2000,%ax
    6959:	je     6ac0 <vfs_mknod+0x1d0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3410
	dentry = user_path_create(dfd, filename, &path, lookup_flags);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    695f:	mov    0x20(%r12),%rax
    6964:	cmpq   $0x0,0x60(%rax)
    6969:	je     6ad2 <vfs_mknod+0x1e2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3413

	if (!IS_POSIXACL(path.dentry->d_inode))
		mode &= ~current_umask();
    696f:	movzwl %r14w,%r14d
    6973:	mov    %r15d,%esi
    6976:	mov    %r14d,%edi
    6979:	callq  697e <vfs_mknod+0x8e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3414
	error = security_path_mknod(&path, dentry, mode, dev);
    697e:	test   %eax,%eax
    6980:	je     6998 <vfs_mknod+0xa8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3422
	switch (mode & S_IFMT) {
		case 0: case S_IFREG:
			error = vfs_create(path.dentry->d_inode,dentry,mode,true);
			break;
		case S_IFCHR: case S_IFBLK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,
    6982:	mov    %eax,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3425
					new_decode_dev(dev));
			break;
		case S_IFIFO: case S_IFSOCK:
    6984:	mov    %ebx,%eax
    6986:	pop    %rbx
    6987:	pop    %r12
    6989:	pop    %r13
    698b:	pop    %r14
    698d:	pop    %r15
    698f:	pop    %rbp
    6990:	retq   
    6991:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3417
	if (!IS_POSIXACL(path.dentry->d_inode))
		mode &= ~current_umask();
	error = security_path_mknod(&path, dentry, mode, dev);
	if (error)
		goto out;
	switch (mode & S_IFMT) {
    6998:	mov    %r15d,%ecx
    699b:	mov    %r14d,%edx
    699e:	mov    %r13,%rsi
    69a1:	mov    %r12,%rdi
    69a4:	callq  69a9 <vfs_mknod+0xb9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3418
		case 0: case S_IFREG:
    69a9:	test   %eax,%eax
    69ab:	jne    6982 <vfs_mknod+0x92>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3421
			error = vfs_create(path.dentry->d_inode,dentry,mode,true);
			break;
		case S_IFCHR: case S_IFBLK:
    69ad:	mov    0x20(%r12),%rax
    69b2:	mov    %r15d,%ecx
    69b5:	mov    %r14d,%edx
    69b8:	mov    %r13,%rsi
    69bb:	mov    %r12,%rdi
    69be:	callq  *0x60(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3422
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,
    69c1:	test   %eax,%eax
    69c3:	jne    6982 <vfs_mknod+0x92>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    69c5:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    69ce:	mov    $0x0,%rax
    69d5:	add    $0x4a8,%rdx
    69dc:	jmp    69e8 <vfs_mknod+0xf8>
    69de:	xchg   %ax,%ax
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    69e0:	test   %cl,%cl
    69e2:	je     6af1 <vfs_mknod+0x201>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    69e8:	add    $0x1,%rdx
    69ec:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    69f0:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    69f4:	cmp    -0x1(%rax),%cl
    69f7:	je     69e0 <vfs_mknod+0xf0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    69f9:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    6a02:	mov    $0x0,%rax
    6a09:	add    $0x4a8,%rdx
    6a10:	jmp    6a20 <vfs_mknod+0x130>
    6a12:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6a18:	test   %cl,%cl
    6a1a:	je     6af1 <vfs_mknod+0x201>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6a20:	add    $0x1,%rdx
    6a24:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    6a28:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    6a2c:	cmp    -0x1(%rax),%cl
    6a2f:	je     6a18 <vfs_mknod+0x128>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6a31:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    6a3a:	mov    $0x0,%rax
    6a41:	add    $0x4a8,%rdx
    6a48:	jmp    6a58 <vfs_mknod+0x168>
    6a4a:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6a50:	test   %cl,%cl
    6a52:	je     6adc <vfs_mknod+0x1ec>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6a58:	add    $0x1,%rdx
    6a5c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    6a60:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    6a64:	cmp    -0x1(%rax),%cl
    6a67:	je     6a50 <vfs_mknod+0x160>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    6a69:	mov    %gs:0x0,%rax
    6a72:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    6a79:	test   %rax,%rax
    6a7c:	je     6a94 <vfs_mknod+0x1a4>
    6a7e:	mov    (%rax),%eax
    6a80:	test   %eax,%eax
    6a82:	jne    6a94 <vfs_mknod+0x1a4>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    6a84:	mov    $0x4,%edx
    6a89:	mov    %r13,%rsi
    6a8c:	mov    %r12,%rdi
    6a8f:	callq  6a94 <vfs_mknod+0x1a4>
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:162
    6a94:	mov    0x30(%r13),%rdx
    6a98:	mov    0x28(%r13),%r8
    6a9c:	xor    %r9d,%r9d
    6a9f:	mov    $0x2,%ecx
    6aa4:	mov    $0x100,%esi
    6aa9:	mov    %r12,%rdi
    6aac:	callq  6ab1 <vfs_mknod+0x1c1>
    6ab1:	jmpq   6984 <vfs_mknod+0x94>
    6ab6:	nopw   %cs:0x0(%rax,%rax,1)
vfs_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3407 (discriminator 1)
	unsigned int lookup_flags = 0;

	error = may_mknod(mode);
	if (error)
		return error;
retry:
    6ac0:	mov    $0x1b,%edi
    6ac5:	callq  6aca <vfs_mknod+0x1da>
    6aca:	test   %al,%al
    6acc:	jne    695f <vfs_mknod+0x6f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3408
	dentry = user_path_create(dfd, filename, &path, lookup_flags);
    6ad2:	mov    $0xffffffff,%ebx
    6ad7:	jmpq   6984 <vfs_mknod+0x94>
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    6adc:	cmpb   $0x0,0x0(%rip)        # 6ae3 <vfs_mknod+0x1f3>
    6ae3:	mov    0x0(%rip),%rax        # 6aea <vfs_mknod+0x1fa>
    6aea:	jne    6a72 <vfs_mknod+0x182>
    6aec:	jmpq   6a69 <vfs_mknod+0x179>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    6af1:	mov    %gs:0x0,%rdx
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    6afa:	mov    $0x0,%rsi
    6b01:	add    $0x4a8,%rdx
    6b08:	mov    $0x0,%rdi
    6b0f:	xor    %eax,%eax
    6b11:	callq  6b16 <vfs_mknod+0x226>
    6b16:	jmpq   6a31 <vfs_mknod+0x141>
vfs_mknod():
    6b1b:	nopl   0x0(%rax,%rax,1)

0000000000006b20 <vfs_mkdir>:
vfs_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3492
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
	return error;
}

    6b20:	callq  6b25 <vfs_mkdir+0x5>
    6b25:	push   %rbp
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6b26:	mov    0x0(%rip),%r8d        # 6b2d <vfs_mkdir+0xd>
    6b2d:	mov    0x0(%rip),%ecx        # 6b33 <vfs_mkdir+0x13>
vfs_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3492
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
	return error;
}

    6b33:	mov    %rsp,%rbp
    6b36:	push   %r15
    6b38:	push   %r14
    6b3a:	mov    %edx,%r14d
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6b3d:	mov    $0x4,%edx
vfs_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3492
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
	return error;
}

    6b42:	push   %r13
    6b44:	mov    %rsi,%r13
    6b47:	push   %r12
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2461
		return p;
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
    6b49:	mov    $0xffffffef,%r12d
vfs_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3492
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
	return error;
}

    6b4f:	push   %rbx
    6b50:	mov    %rdi,%rbx
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6b53:	callq  6b58 <vfs_mkdir+0x38>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
	if (p) {
    6b58:	cmpq   $0x0,0x30(%r13)
    6b5d:	jne    6bd6 <vfs_mkdir+0xb6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    6b5f:	testb  $0x10,0xc(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2463
		return p;
    6b63:	mov    $0xfe,%r12b
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    6b66:	jne    6bd6 <vfs_mkdir+0xb6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
		return p;
	}
    6b68:	mov    $0x3,%esi
    6b6d:	mov    %rbx,%rdi
    6b70:	callq  6b75 <vfs_mkdir+0x55>
    6b75:	mov    %eax,%r12d
vfs_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3494
	}
	return error;
}

SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)
{
    6b78:	mov    0x28(%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3496
	return sys_mkdirat(AT_FDCWD, pathname, mode);
}
    6b7c:	test   %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3494
	}
	return error;
}

SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)
{
    6b7f:	mov    0x300(%rax),%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3496
	return sys_mkdirat(AT_FDCWD, pathname, mode);
}
    6b86:	jne    6bd6 <vfs_mkdir+0xb6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3499

/*
 * The dentry_unhash() helper will try to drop the dentry early: we
    6b88:	mov    0x20(%rbx),%rax
    6b8c:	cmpq   $0x0,0x50(%rax)
    6b91:	je     6cfa <vfs_mkdir+0x1da>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3503
 * should have a usage count of 1 if we're the only user of this
 * dentry, and if that is true (possibly after pruning the dcache),
 * then we drop the dentry now.
 *
    6b97:	and    $0x3ff,%r14d
    6b9e:	mov    %r13,%rsi
    6ba1:	mov    %rbx,%rdi
    6ba4:	mov    %r14d,%edx
    6ba7:	callq  6bac <vfs_mkdir+0x8c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3504
 * A low-level filesystem can, if it choses, legally
    6bac:	test   %eax,%eax
    6bae:	jne    6bd3 <vfs_mkdir+0xb3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3507
 * do a
 *
 *	if (!d_unhashed(dentry))
    6bb0:	test   %r15d,%r15d
    6bb3:	je     6bbf <vfs_mkdir+0x9f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3507 (discriminator 1)
    6bb5:	cmp    0x48(%rbx),%r15d
    6bb9:	jbe    6d05 <vfs_mkdir+0x1e5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3510
 *		return -EBUSY;
 *
 * if it cannot handle the case of removing a directory
    6bbf:	mov    0x20(%rbx),%rax
    6bc3:	mov    %r14d,%edx
    6bc6:	mov    %r13,%rsi
    6bc9:	mov    %rbx,%rdi
    6bcc:	callq  *0x50(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3511
 * that is still in use by something else..
    6bcf:	test   %eax,%eax
    6bd1:	je     6be8 <vfs_mkdir+0xc8>
    6bd3:	mov    %eax,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3514
 */
void dentry_unhash(struct dentry *dentry)
{
    6bd6:	pop    %rbx
    6bd7:	mov    %r12d,%eax
    6bda:	pop    %r12
    6bdc:	pop    %r13
    6bde:	pop    %r14
    6be0:	pop    %r15
    6be2:	pop    %rbp
    6be3:	retq   
    6be4:	nopl   0x0(%rax)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6be8:	mov    %gs:0x0,%rdx
fsnotify_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:184
 * fsnotify_mkdir - directory 'name' was created
 */
static inline void fsnotify_mkdir(struct inode *inode, struct dentry *dentry)
{
	__u32 mask = (FS_CREATE | FS_ISDIR);
	struct inode *d_inode = dentry->d_inode;
    6bf1:	mov    0x30(%r13),%r14
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    6bf5:	add    $0x4a8,%rdx
    6bfc:	mov    $0x0,%rax
    6c03:	jmp    6c10 <vfs_mkdir+0xf0>
    6c05:	nopl   (%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6c08:	test   %cl,%cl
    6c0a:	je     6d10 <vfs_mkdir+0x1f0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6c10:	add    $0x1,%rdx
    6c14:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    6c18:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    6c1c:	cmp    -0x1(%rax),%cl
    6c1f:	je     6c08 <vfs_mkdir+0xe8>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6c21:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    6c2a:	mov    $0x0,%rax
    6c31:	add    $0x4a8,%rdx
    6c38:	jmp    6c48 <vfs_mkdir+0x128>
    6c3a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6c40:	test   %cl,%cl
    6c42:	je     6d10 <vfs_mkdir+0x1f0>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6c48:	add    $0x1,%rdx
    6c4c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    6c50:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    6c54:	cmp    -0x1(%rax),%cl
    6c57:	je     6c40 <vfs_mkdir+0x120>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6c59:	mov    %gs:0x0,%rcx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    6c62:	mov    $0x0,%rax
    6c69:	add    $0x4a8,%rcx
    6c70:	jmp    6c7c <vfs_mkdir+0x15c>
    6c72:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6c78:	test   %dl,%dl
    6c7a:	je     6ce8 <vfs_mkdir+0x1c8>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6c7c:	add    $0x1,%rcx
    6c80:	movzbl -0x1(%rcx),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    6c84:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    6c88:	cmp    -0x1(%rax),%dl
    6c8b:	je     6c78 <vfs_mkdir+0x158>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    6c8d:	mov    %gs:0x0,%rax
    6c96:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    6c9d:	test   %rax,%rax
    6ca0:	je     6cb8 <vfs_mkdir+0x198>
    6ca2:	mov    (%rax),%eax
    6ca4:	test   %eax,%eax
    6ca6:	jne    6cb8 <vfs_mkdir+0x198>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    6ca8:	mov    $0x4,%edx
    6cad:	mov    %r13,%rsi
    6cb0:	mov    %rbx,%rdi
    6cb3:	callq  6cb8 <vfs_mkdir+0x198>
fsnotify_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:188

	audit_inode_child(inode, dentry, AUDIT_TYPE_CHILD_CREATE);

	fsnotify(inode, mask, d_inode, FSNOTIFY_EVENT_INODE, dentry->d_name.name, 0);
    6cb8:	mov    0x28(%r13),%r8
    6cbc:	mov    %r14,%rdx
    6cbf:	mov    %rbx,%rdi
    6cc2:	xor    %r9d,%r9d
    6cc5:	mov    $0x2,%ecx
    6cca:	mov    $0x40000100,%esi
    6ccf:	callq  6cd4 <vfs_mkdir+0x1b4>
vfs_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3514
    6cd4:	pop    %rbx
    6cd5:	mov    %r12d,%eax
    6cd8:	pop    %r12
    6cda:	pop    %r13
    6cdc:	pop    %r14
    6cde:	pop    %r15
    6ce0:	pop    %rbp
    6ce1:	retq   
    6ce2:	nopw   0x0(%rax,%rax,1)
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    6ce8:	cmpb   $0x0,0x0(%rip)        # 6cef <vfs_mkdir+0x1cf>
    6cef:	mov    0x0(%rip),%rax        # 6cf6 <vfs_mkdir+0x1d6>
    6cf6:	jne    6c96 <vfs_mkdir+0x176>
    6cf8:	jmp    6c8d <vfs_mkdir+0x16d>
vfs_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3500
	return sys_mkdirat(AT_FDCWD, pathname, mode);
}

/*
 * The dentry_unhash() helper will try to drop the dentry early: we
 * should have a usage count of 1 if we're the only user of this
    6cfa:	mov    $0xffffffff,%r12d
    6d00:	jmpq   6bd6 <vfs_mkdir+0xb6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3508
 *
 * A low-level filesystem can, if it choses, legally
 * do a
 *
 *	if (!d_unhashed(dentry))
 *		return -EBUSY;
    6d05:	mov    $0xffffffe1,%r12d
    6d0b:	jmpq   6bd6 <vfs_mkdir+0xb6>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    6d10:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    6d19:	mov    $0x0,%rsi
    6d20:	add    $0x4a8,%rdx
    6d27:	mov    $0x0,%rdi
    6d2e:	xor    %eax,%eax
    6d30:	callq  6d35 <vfs_mkdir+0x215>
    6d35:	jmpq   6c59 <vfs_mkdir+0x139>
vfs_mkdir():
    6d3a:	nopw   0x0(%rax,%rax,1)

0000000000006d40 <vfs_link>:
vfs_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3893
		inode->i_state &= ~I_LINKABLE;
		spin_unlock(&inode->i_lock);
	}
	mutex_unlock(&inode->i_mutex);
	if (!error)
		fsnotify_link(dir, inode, new_dentry);
    6d40:	callq  6d45 <vfs_link+0x5>
    6d45:	push   %rbp
    6d46:	mov    %rsp,%rbp
    6d49:	push   %r15
    6d4b:	push   %r14
    6d4d:	mov    %rsi,%r14
    6d50:	push   %r13
    6d52:	mov    %rdi,%r13
    6d55:	push   %r12
    6d57:	push   %rbx
    6d58:	sub    $0x18,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3895
	return error;
}
    6d5c:	mov    0x28(%rsi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3894
		spin_unlock(&inode->i_lock);
	}
	mutex_unlock(&inode->i_mutex);
	if (!error)
		fsnotify_link(dir, inode, new_dentry);
	return error;
    6d60:	mov    0x30(%rdi),%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3893
		inode->i_state &= ~I_LINKABLE;
		spin_unlock(&inode->i_lock);
	}
	mutex_unlock(&inode->i_mutex);
	if (!error)
		fsnotify_link(dir, inode, new_dentry);
    6d64:	mov    %rcx,-0x38(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3895
	return error;
}
    6d68:	mov    0x300(%rax),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3898

/*
 * Hardlinks are often used in delicate situations.  We avoid
    6d6e:	test   %rbx,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3895
	}
	mutex_unlock(&inode->i_mutex);
	if (!error)
		fsnotify_link(dir, inode, new_dentry);
	return error;
}
    6d71:	mov    %eax,-0x2c(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3898

/*
 * Hardlinks are often used in delicate situations.  We avoid
    6d74:	je     7069 <vfs_link+0x329>
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6d7a:	mov    0x0(%rip),%r8d        # 6d81 <vfs_link+0x41>
    6d81:	mov    0x0(%rip),%ecx        # 6d87 <vfs_link+0x47>
    6d87:	mov    %rdx,%r12
    6d8a:	mov    %r12,%rsi
    6d8d:	mov    $0x4,%edx
    6d92:	mov    %r14,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2461
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
    6d95:	mov    $0xffffffef,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    6d9b:	callq  6da0 <vfs_link+0x60>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
	if (p) {
    6da0:	cmpq   $0x0,0x30(%r12)
    6da6:	jne    6e0f <vfs_link+0xcf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    6da8:	testb  $0x10,0xc(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2463
		return p;
    6dad:	mov    $0xfe,%r15b
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    6db0:	jne    6e0f <vfs_link+0xcf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
		return p;
	}
    6db2:	mov    $0x3,%esi
    6db7:	mov    %r14,%rdi
    6dba:	callq  6dbf <vfs_link+0x7f>
vfs_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3902
/*
 * Hardlinks are often used in delicate situations.  We avoid
 * security-related surprises by not following symlinks on the
 * newname.  --KAB
 *
 * We don't follow them on the oldname either to be compatible
    6dbf:	test   %eax,%eax
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}
    6dc1:	mov    %eax,%r15d
vfs_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3902
/*
 * Hardlinks are often used in delicate situations.  We avoid
 * security-related surprises by not following symlinks on the
 * newname.  --KAB
 *
 * We don't follow them on the oldname either to be compatible
    6dc4:	jne    6e0f <vfs_link+0xcf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3905
 * with linux 2.0, and to avoid hard-linking to directories
 * and other special files.  --ADM
 */
    6dc6:	mov    0x28(%rbx),%rax
    6dca:	cmp    %rax,0x28(%r14)
    6dce:	jne    6e28 <vfs_link+0xe8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3911
SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
		int, newdfd, const char __user *, newname, int, flags)
{
	struct dentry *new_dentry;
	struct path old_path, new_path;
	struct inode *delegated_inode = NULL;
    6dd0:	testb  $0xc,0xc(%rbx)
    6dd4:	jne    7010 <vfs_link+0x2d0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3913
	int how = 0;
	int error;
    6dda:	mov    0x20(%r14),%rax
    6dde:	cmpq   $0x0,0x38(%rax)
    6de3:	je     7010 <vfs_link+0x2d0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3915

	if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)
    6de9:	movzwl (%rbx),%eax
    6dec:	and    $0xf000,%ax
    6df0:	cmp    $0x4000,%ax
    6df4:	je     7010 <vfs_link+0x2d0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3918
		return -EINVAL;
	/*
	 * To use null names we require CAP_DAC_READ_SEARCH
    6dfa:	mov    %r12,%rdx
    6dfd:	mov    %r14,%rsi
    6e00:	mov    %r13,%rdi
    6e03:	callq  6e08 <vfs_link+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3919
	 * This ensures that not everyone will be able to create
    6e08:	test   %eax,%eax
    6e0a:	je     6e30 <vfs_link+0xf0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3939

	new_dentry = user_path_create(newdfd, newname, &new_path,
					(how & LOOKUP_REVAL));
	error = PTR_ERR(new_dentry);
	if (IS_ERR(new_dentry))
		goto out;
    6e0c:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3943

	error = -EXDEV;
	if (old_path.mnt != new_path.mnt)
		goto out_dput;
    6e0f:	add    $0x18,%rsp
    6e13:	mov    %r15d,%eax
    6e16:	pop    %rbx
    6e17:	pop    %r12
    6e19:	pop    %r13
    6e1b:	pop    %r14
    6e1d:	pop    %r15
    6e1f:	pop    %rbp
    6e20:	retq   
    6e21:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3906
 *
 * We don't follow them on the oldname either to be compatible
 * with linux 2.0, and to avoid hard-linking to directories
 * and other special files.  --ADM
 */
SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
    6e28:	mov    $0xffffffee,%r15d
    6e2e:	jmp    6e0f <vfs_link+0xcf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3922
	/*
	 * To use null names we require CAP_DAC_READ_SEARCH
	 * This ensures that not everyone will be able to create
	 * handlink using the passed filedescriptor.
	 */
	if (flags & AT_EMPTY_PATH) {
    6e30:	lea    0xa8(%rbx),%rax
    6e37:	mov    %rax,%rdi
    6e3a:	mov    %rax,-0x40(%rbp)
    6e3e:	callq  6e43 <vfs_link+0x103>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3924
		if (!capable(CAP_DAC_READ_SEARCH))
			return -ENOENT;
    6e43:	mov    0x48(%rbx),%eax
    6e46:	test   %eax,%eax
    6e48:	jne    6e53 <vfs_link+0x113>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3924 (discriminator 1)
    6e4a:	testb  $0x4,0xa1(%rbx)
    6e51:	je     6eb8 <vfs_link+0x178>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3926
		how = LOOKUP_EMPTY;
	}
    6e53:	mov    -0x2c(%rbp),%esi
    6e56:	test   %esi,%esi
    6e58:	je     6e78 <vfs_link+0x138>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3926 (discriminator 1)
    6e5a:	cmp    %eax,%esi
    6e5c:	ja     6e78 <vfs_link+0x138>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3927

    6e5e:	mov    $0xffffffe1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3939

	new_dentry = user_path_create(newdfd, newname, &new_path,
					(how & LOOKUP_REVAL));
	error = PTR_ERR(new_dentry);
	if (IS_ERR(new_dentry))
		goto out;
    6e63:	mov    -0x40(%rbp),%rdi
    6e67:	mov    %eax,-0x2c(%rbp)
    6e6a:	callq  6e6f <vfs_link+0x12f>
    6e6f:	mov    -0x2c(%rbp),%eax
    6e72:	jmp    6e0c <vfs_link+0xcc>
    6e74:	nopl   0x0(%rax)
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    6e78:	cmpq   $0x0,0x148(%rbx)
    6e80:	je     6ec8 <vfs_link+0x188>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    6e82:	mov    $0x4,%edx
    6e87:	mov    $0x801,%esi
    6e8c:	mov    %rbx,%rdi
    6e8f:	callq  6e94 <vfs_link+0x154>
try_break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1983
static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(inode, O_WRONLY|O_NONBLOCK);
	if (ret == -EWOULDBLOCK && delegated_inode) {
    6e94:	cmp    $0xfffffff5,%eax
    6e97:	jne    6ec0 <vfs_link+0x180>
    6e99:	mov    -0x38(%rbp),%rsi
    6e9d:	test   %rsi,%rsi
    6ea0:	je     6ec0 <vfs_link+0x180>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1984
		*delegated_inode = inode;
    6ea2:	mov    %rbx,(%rsi)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1985
		ihold(inode);
    6ea5:	mov    %rbx,%rdi
    6ea8:	callq  6ead <vfs_link+0x16d>
    6ead:	mov    $0xfffffff5,%eax
    6eb2:	jmp    6e63 <vfs_link+0x123>
    6eb4:	nopl   0x0(%rax)
vfs_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3925
	 * handlink using the passed filedescriptor.
	 */
	if (flags & AT_EMPTY_PATH) {
		if (!capable(CAP_DAC_READ_SEARCH))
			return -ENOENT;
		how = LOOKUP_EMPTY;
    6eb8:	mov    $0xfffffffe,%eax
    6ebd:	jmp    6e63 <vfs_link+0x123>
    6ebf:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3930
	}

	if (flags & AT_SYMLINK_FOLLOW)
		how |= LOOKUP_FOLLOW;
retry:
    6ec0:	test   %eax,%eax
    6ec2:	jne    6e63 <vfs_link+0x123>
    6ec4:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3931
	error = user_path_at(olddfd, oldname, how, &old_path);
    6ec8:	mov    0x20(%r14),%rax
    6ecc:	mov    %r12,%rdx
    6ecf:	mov    %r14,%rsi
    6ed2:	mov    %r13,%rdi
    6ed5:	callq  *0x38(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3934
	if (error)
		return error;

    6ed8:	test   %eax,%eax
    6eda:	jne    6e63 <vfs_link+0x123>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3934 (discriminator 1)
    6edc:	testb  $0x4,0xa1(%rbx)
    6ee3:	jne    7020 <vfs_link+0x2e0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3939
	new_dentry = user_path_create(newdfd, newname, &new_path,
					(how & LOOKUP_REVAL));
	error = PTR_ERR(new_dentry);
	if (IS_ERR(new_dentry))
		goto out;
    6ee9:	mov    -0x40(%rbp),%rdi
    6eed:	callq  6ef2 <vfs_link+0x1b2>
fsnotify_link_count():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:82
/*
 * fsnotify_link_count - inode's link count changed
 */
static inline void fsnotify_link_count(struct inode *inode)
{
	fsnotify(inode, FS_ATTRIB, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
    6ef2:	mov    %rbx,%rdx
    6ef5:	xor    %r9d,%r9d
    6ef8:	xor    %r8d,%r8d
    6efb:	mov    $0x2,%ecx
    6f00:	mov    $0x4,%esi
    6f05:	mov    %rbx,%rdi
    6f08:	callq  6f0d <vfs_link+0x1cd>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6f0d:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    6f16:	mov    $0x0,%rax
    6f1d:	add    $0x4a8,%rdx
    6f24:	jmp    6f38 <vfs_link+0x1f8>
    6f26:	nopw   %cs:0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6f30:	test   %cl,%cl
    6f32:	je     7074 <vfs_link+0x334>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6f38:	add    $0x1,%rdx
    6f3c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    6f40:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    6f44:	cmp    -0x1(%rax),%cl
    6f47:	je     6f30 <vfs_link+0x1f0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6f49:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    6f52:	mov    $0x0,%rax
    6f59:	add    $0x4a8,%rdx
    6f60:	jmp    6f70 <vfs_link+0x230>
    6f62:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6f68:	test   %cl,%cl
    6f6a:	je     7074 <vfs_link+0x334>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6f70:	add    $0x1,%rdx
    6f74:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    6f78:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    6f7c:	cmp    -0x1(%rax),%cl
    6f7f:	je     6f68 <vfs_link+0x228>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    6f81:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    6f8a:	mov    $0x0,%rax
    6f91:	add    $0x4a8,%rdx
    6f98:	jmp    6fa8 <vfs_link+0x268>
    6f9a:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    6fa0:	test   %cl,%cl
    6fa2:	je     7050 <vfs_link+0x310>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    6fa8:	add    $0x1,%rdx
    6fac:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    6fb0:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    6fb4:	cmp    -0x1(%rax),%cl
    6fb7:	je     6fa0 <vfs_link+0x260>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    6fb9:	mov    %gs:0x0,%rax
    6fc2:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    6fc9:	test   %rax,%rax
    6fcc:	je     6fe4 <vfs_link+0x2a4>
    6fce:	mov    (%rax),%eax
    6fd0:	test   %eax,%eax
    6fd2:	jne    6fe4 <vfs_link+0x2a4>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    6fd4:	mov    $0x4,%edx
    6fd9:	mov    %r12,%rsi
    6fdc:	mov    %r14,%rdi
    6fdf:	callq  6fe4 <vfs_link+0x2a4>
fsnotify_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:175
static inline void fsnotify_link(struct inode *dir, struct inode *inode, struct dentry *new_dentry)
{
	fsnotify_link_count(inode);
	audit_inode_child(dir, new_dentry, AUDIT_TYPE_CHILD_CREATE);

	fsnotify(dir, FS_CREATE, inode, FSNOTIFY_EVENT_INODE, new_dentry->d_name.name, 0);
    6fe4:	mov    0x28(%r12),%r8
    6fe9:	xor    %r9d,%r9d
    6fec:	mov    $0x2,%ecx
    6ff1:	mov    %rbx,%rdx
    6ff4:	mov    $0x100,%esi
    6ff9:	mov    %r14,%rdi
    6ffc:	callq  7001 <vfs_link+0x2c1>
    7001:	jmpq   6e0f <vfs_link+0xcf>
    7006:	nopw   %cs:0x0(%rax,%rax,1)
vfs_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3912
		int, newdfd, const char __user *, newname, int, flags)
{
	struct dentry *new_dentry;
	struct path old_path, new_path;
	struct inode *delegated_inode = NULL;
	int how = 0;
    7010:	mov    $0xffffffff,%r15d
    7016:	jmpq   6e0f <vfs_link+0xcf>
    701b:	nopl   0x0(%rax,%rax,1)
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    7020:	lea    0x88(%rbx),%r13
    7027:	mov    %r13,%rdi
    702a:	callq  702f <vfs_link+0x2ef>
vfs_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3936
	error = user_path_at(olddfd, oldname, how, &old_path);
	if (error)
		return error;

	new_dentry = user_path_create(newdfd, newname, &new_path,
					(how & LOOKUP_REVAL));
    702f:	andq   $0xfffffffffffffbff,0xa0(%rbx)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    703a:	mov    %r13,%rdi
    703d:	callq  7042 <vfs_link+0x302>
    7042:	jmpq   6ee9 <vfs_link+0x1a9>
    7047:	nopw   0x0(%rax,%rax,1)
fsnotify_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    7050:	cmpb   $0x0,0x0(%rip)        # 7057 <vfs_link+0x317>
    7057:	mov    0x0(%rip),%rax        # 705e <vfs_link+0x31e>
    705e:	jne    6fc2 <vfs_link+0x282>
    7064:	jmpq   6fb9 <vfs_link+0x279>
vfs_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3899
	return error;
}

/*
 * Hardlinks are often used in delicate situations.  We avoid
 * security-related surprises by not following symlinks on the
    7069:	mov    $0xfffffffe,%r15d
    706f:	jmpq   6e0f <vfs_link+0xcf>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    7074:	mov    %gs:0x0,%rdx
fsnotify_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    707d:	mov    $0x0,%rsi
    7084:	add    $0x4a8,%rdx
    708b:	mov    $0x0,%rdi
    7092:	xor    %eax,%eax
    7094:	callq  7099 <vfs_link+0x359>
    7099:	jmpq   6f81 <vfs_link+0x241>
vfs_link():
    709e:	xchg   %ax,%ax

00000000000070a0 <vfs_create>:
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2511
	struct dentry *dentry = path->dentry;
	struct inode *inode = dentry->d_inode;
	int error;

	/* O_PATH? */
	if (!acc_mode)
    70a0:	callq  70a5 <vfs_create+0x5>
    70a5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2512
		return 0;
    70a6:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    70ad:	mov    %gs:0x0,%r8
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2511
	struct dentry *dentry = path->dentry;
	struct inode *inode = dentry->d_inode;
	int error;

	/* O_PATH? */
	if (!acc_mode)
    70b6:	mov    %rsp,%rbp
    70b9:	push   %r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2512
		return 0;
    70bb:	add    $0x4a8,%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2511
	struct dentry *dentry = path->dentry;
	struct inode *inode = dentry->d_inode;
	int error;

	/* O_PATH? */
	if (!acc_mode)
    70c2:	push   %r14
    70c4:	mov    %rdi,%r14
    70c7:	push   %r13
    70c9:	mov    %ecx,%r13d
    70cc:	push   %r12
    70ce:	mov    %edx,%r12d
    70d1:	push   %rbx
    70d2:	mov    %rsi,%rbx
    70d5:	jmp    70e8 <vfs_create+0x48>
    70d7:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    70e0:	test   %dl,%dl
    70e2:	je     7330 <vfs_create+0x290>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    70e8:	add    $0x1,%r8
    70ec:	movzbl -0x1(%r8),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    70f1:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    70f5:	cmp    -0x1(%rax),%dl
    70f8:	je     70e0 <vfs_create+0x40>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    70fa:	mov    %gs:0x0,%rdx
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2512
		return 0;
    7103:	mov    $0x0,%rax
    710a:	add    $0x4a8,%rdx
    7111:	jmp    7120 <vfs_create+0x80>
    7113:	nopl   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7118:	test   %cl,%cl
    711a:	je     7330 <vfs_create+0x290>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7120:	add    $0x1,%rdx
    7124:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7128:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    712c:	cmp    -0x1(%rax),%cl
    712f:	je     7118 <vfs_create+0x78>
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    7131:	mov    0x0(%rip),%r8d        # 7138 <vfs_create+0x98>
    7138:	mov    0x0(%rip),%ecx        # 713e <vfs_create+0x9e>
    713e:	mov    $0x4,%edx
    7143:	mov    %rbx,%rsi
    7146:	mov    %r14,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2461
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
    7149:	mov    $0xffffffef,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2459
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}

	p = d_ancestor(p1, p2);
    714f:	callq  7154 <vfs_create+0xb4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2460
	if (p) {
    7154:	cmpq   $0x0,0x30(%rbx)
    7159:	jne    71f2 <vfs_create+0x152>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    715f:	testb  $0x10,0xc(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2463
		return p;
    7164:	mov    $0xfe,%r15b
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2462
	}

	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
    7167:	jne    71f2 <vfs_create+0x152>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
		return p;
	}
    716d:	mov    $0x3,%esi
    7172:	mov    %r14,%rdi
    7175:	callq  717a <vfs_create+0xda>
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2514

	/* O_PATH? */
	if (!acc_mode)
		return 0;

	if (!inode)
    717a:	test   %eax,%eax
may_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2464
	p = d_ancestor(p1, p2);
	if (p) {
		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
		return p;
	}
    717c:	mov    %eax,%r15d
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2514

	/* O_PATH? */
	if (!acc_mode)
		return 0;

	if (!inode)
    717f:	jne    71f2 <vfs_create+0x152>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2517
		return -ENOENT;

	switch (inode->i_mode & S_IFMT) {
    7181:	mov    0x20(%r14),%rax
    7185:	mov    0x30(%rax),%rdi
    7189:	test   %rdi,%rdi
    718c:	je     731c <vfs_create+0x27c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2519
	case S_IFLNK:
		return -ELOOP;
    7192:	and    $0xfff,%r12w
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2522
	case S_IFDIR:
		if (acc_mode & MAY_WRITE)
			return -EISDIR;
    7198:	mov    $0x0,%rcx
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    719f:	mov    %gs:0x0,%rsi
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2520
		return -ENOENT;

	switch (inode->i_mode & S_IFMT) {
	case S_IFLNK:
		return -ELOOP;
	case S_IFDIR:
    71a8:	or     $0x8000,%r12w
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2522
		if (acc_mode & MAY_WRITE)
			return -EISDIR;
    71ae:	add    $0x4a8,%rsi
    71b5:	jmp    71c4 <vfs_create+0x124>
    71b7:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    71c0:	test   %al,%al
    71c2:	je     7200 <vfs_create+0x160>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    71c4:	add    $0x1,%rsi
    71c8:	movzbl -0x1(%rsi),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    71cc:	add    $0x1,%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    71d0:	cmp    -0x1(%rcx),%al
    71d3:	je     71c0 <vfs_create+0x120>
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2523
		break;
    71d5:	movzwl %r12w,%r12d
    71d9:	mov    %rbx,%rsi
    71dc:	mov    %r14,%rdi
    71df:	mov    %r12d,%edx
    71e2:	callq  71e7 <vfs_create+0x147>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2526
	case S_IFBLK:
	case S_IFCHR:
		if (path->mnt->mnt_flags & MNT_NODEV)
    71e7:	test   %eax,%eax
    71e9:	je     7384 <vfs_create+0x2e4>
    71ef:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2532
			return -EACCES;
		/*FALLTHRU*/
	case S_IFIFO:
	case S_IFSOCK:
		flag &= ~O_TRUNC;
		break;
    71f2:	pop    %rbx
    71f3:	pop    %r12
    71f5:	pop    %r13
    71f7:	pop    %r14
    71f9:	mov    %r15d,%eax
    71fc:	pop    %r15
    71fe:	pop    %rbp
    71ff:	retq   
    7200:	movzwl %r12w,%r12d
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7204:	mov    %rdi,%rax
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2528
		break;
	case S_IFBLK:
	case S_IFCHR:
		if (path->mnt->mnt_flags & MNT_NODEV)
			return -EACCES;
		/*FALLTHRU*/
    7207:	movzbl %r13b,%ecx
    720b:	mov    %r12d,%edx
    720e:	mov    %rbx,%rsi
    7211:	mov    %r14,%rdi
    7214:	callq  *%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2529
	case S_IFIFO:
    7216:	test   %eax,%eax
    7218:	jne    71ef <vfs_create+0x14f>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    721a:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    7223:	mov    $0x0,%rax
    722a:	add    $0x4a8,%rdx
    7231:	jmp    7240 <vfs_create+0x1a0>
    7233:	nopl   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
    7238:	test   %cl,%cl
    723a:	je     735a <vfs_create+0x2ba>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7240:	add    $0x1,%rdx
    7244:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7248:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    724c:	cmp    -0x1(%rax),%cl
    724f:	je     7238 <vfs_create+0x198>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    7251:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    725a:	mov    $0x0,%rax
    7261:	add    $0x4a8,%rdx
    7268:	jmp    7278 <vfs_create+0x1d8>
    726a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7270:	test   %cl,%cl
    7272:	je     735a <vfs_create+0x2ba>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7278:	add    $0x1,%rdx
    727c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7280:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    7284:	cmp    -0x1(%rax),%cl
    7287:	je     7270 <vfs_create+0x1d0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    7289:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    7292:	mov    $0x0,%rax
    7299:	add    $0x4a8,%rdx
    72a0:	jmp    72ac <vfs_create+0x20c>
    72a2:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    72a8:	test   %cl,%cl
    72aa:	je     730a <vfs_create+0x26a>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    72ac:	add    $0x1,%rdx
    72b0:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    72b4:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    72b8:	cmp    -0x1(%rax),%cl
    72bb:	je     72a8 <vfs_create+0x208>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    72bd:	mov    %gs:0x0,%rax
    72c6:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    72cd:	test   %rax,%rax
    72d0:	je     72e8 <vfs_create+0x248>
    72d2:	mov    (%rax),%eax
    72d4:	test   %eax,%eax
    72d6:	jne    72e8 <vfs_create+0x248>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    72d8:	mov    $0x4,%edx
    72dd:	mov    %rbx,%rsi
    72e0:	mov    %r14,%rdi
    72e3:	callq  72e8 <vfs_create+0x248>
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:162
 */
static inline void fsnotify_create(struct inode *inode, struct dentry *dentry)
{
	audit_inode_child(inode, dentry, AUDIT_TYPE_CHILD_CREATE);

	fsnotify(inode, FS_CREATE, dentry->d_inode, FSNOTIFY_EVENT_INODE, dentry->d_name.name, 0);
    72e8:	mov    0x30(%rbx),%rdx
    72ec:	mov    0x28(%rbx),%r8
    72f0:	xor    %r9d,%r9d
    72f3:	mov    $0x2,%ecx
    72f8:	mov    $0x100,%esi
    72fd:	mov    %r14,%rdi
    7300:	callq  7305 <vfs_create+0x265>
    7305:	jmpq   71f2 <vfs_create+0x152>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    730a:	cmpb   $0x0,0x0(%rip)        # 7311 <vfs_create+0x271>
    7311:	mov    0x0(%rip),%rax        # 7318 <vfs_create+0x278>
    7318:	jne    72c6 <vfs_create+0x226>
    731a:	jmp    72bd <vfs_create+0x21d>
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2518

	if (!inode)
		return -ENOENT;

	switch (inode->i_mode & S_IFMT) {
	case S_IFLNK:
    731c:	mov    $0xfffffff3,%r15d
    7322:	jmpq   71f2 <vfs_create+0x152>
    7327:	nopw   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    7330:	mov    %gs:0x0,%rdx
vfs_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2512
	struct inode *inode = dentry->d_inode;
	int error;

	/* O_PATH? */
	if (!acc_mode)
		return 0;
    7339:	mov    $0x0,%rsi
    7340:	add    $0x4a8,%rdx
    7347:	mov    $0x0,%rdi
    734e:	xor    %eax,%eax
    7350:	callq  7355 <vfs_create+0x2b5>
    7355:	jmpq   7131 <vfs_create+0x91>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    735a:	mov    %gs:0x0,%rdx
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    7363:	mov    $0x0,%rsi
    736a:	add    $0x4a8,%rdx
    7371:	mov    $0x0,%rdi
    7378:	xor    %eax,%eax
    737a:	callq  737f <vfs_create+0x2df>
    737f:	jmpq   7289 <vfs_create+0x1e9>
    7384:	mov    0x20(%r14),%rax
    7388:	mov    0x30(%rax),%rax
    738c:	jmpq   7207 <vfs_create+0x167>
vfs_create():
    7391:	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

00000000000073a0 <do_last>:
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2902
		if (error < 0)
			goto out;

		BUG_ON(nd->inode != dir->d_inode);
	} else {
		/* create side of things */
    73a0:	callq  73a5 <do_last+0x5>
    73a5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2903
		/*
    73a6:	mov    $0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2902
		if (error < 0)
			goto out;

		BUG_ON(nd->inode != dir->d_inode);
	} else {
		/* create side of things */
    73ad:	mov    %rsp,%rbp
    73b0:	push   %r15
    73b2:	push   %r14
    73b4:	mov    %rdi,%r14
    73b7:	push   %r13
    73b9:	mov    %rsi,%r13
    73bc:	push   %r12
    73be:	push   %rbx
    73bf:	mov    %rcx,%rbx
    73c2:	sub    $0x68,%rsp
    73c6:	mov    %rdx,0x40(%rsp)
    73cb:	mov    %r8,0x38(%rsp)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    73d0:	mov    %gs:0x0,%rdx
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2902
    73d9:	mov    %r9,0x48(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2903
		/*
    73de:	add    $0x4a8,%rdx
    73e5:	jmp    73f8 <do_last+0x58>
    73e7:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    73f0:	test   %cl,%cl
    73f2:	je     8598 <do_last+0x11f8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    73f8:	add    $0x1,%rdx
    73fc:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7400:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    7404:	cmp    -0x1(%rax),%cl
    7407:	je     73f0 <do_last+0x50>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    7409:	mov    %gs:0x0,%rdx
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2903
    7412:	mov    $0x0,%rax
    7419:	add    $0x4a8,%rdx
    7420:	jmp    7430 <do_last+0x90>
    7422:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7428:	test   %cl,%cl
    742a:	je     8598 <do_last+0x11f8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7430:	add    $0x1,%rdx
    7434:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7438:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    743c:	cmp    -0x1(%rax),%cl
    743f:	je     7428 <do_last+0x88>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2906
		 * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED
		 * has been cleared when we got to the last component we are
		 * about to look up
    7441:	mov    (%rbx),%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2905
		BUG_ON(nd->inode != dir->d_inode);
	} else {
		/* create side of things */
		/*
		 * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED
		 * has been cleared when we got to the last component we are
    7444:	mov    0x8(%r14),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2919
		error = -EISDIR;
		/* trailing slashes? */
		if (nd->last.name[nd->last.len])
			goto out;
	}

    7448:	mov    0x44(%r14),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2905
		BUG_ON(nd->inode != dir->d_inode);
	} else {
		/* create side of things */
		/*
		 * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED
		 * has been cleared when we got to the last component we are
    744c:	mov    %rax,0x50(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2907
		 * about to look up
		 */
    7451:	mov    %r12d,%eax
    7454:	shr    $0x9,%eax
    7457:	and    $0x1,%eax
    745a:	mov    %al,0x37(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2909
		error = complete_walk(nd);
		if (error)
    745e:	mov    0x8(%rbx),%eax
    7461:	mov    %eax,0x30(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2916

		// audit_inode(name, dir, LOOKUP_PARENT);
		msg_audit_inode(name, dir, LOOKUP_PARENT, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
		error = -EISDIR;
		/* trailing slashes? */
		if (nd->last.name[nd->last.len])
    7465:	mov    0x38(%r14),%eax
    7469:	and    $0xffffffef,%eax
    746c:	mov    %eax,0x38(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2917
			goto out;
    7470:	or     0xc(%rbx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2919
	}

    7473:	test   %edx,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2917
		// audit_inode(name, dir, LOOKUP_PARENT);
		msg_audit_inode(name, dir, LOOKUP_PARENT, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
		error = -EISDIR;
		/* trailing slashes? */
		if (nd->last.name[nd->last.len])
			goto out;
    7475:	mov    %eax,0x38(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2919
	}

    7479:	jne    7560 <do_last+0x1c0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2926
	if (op->open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {
		error = mnt_want_write(nd->path.mnt);
		if (!error)
			got_write = true;
		/*
		 * do _not_ fail yet - we might not need that or fail with
    747f:	test   $0x40,%r12b
    7483:	jne    76a0 <do_last+0x300>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2927
		 * a different error; let lookup_open() decide; we'll be
    7489:	mov    0x14(%r14),%edx
    748d:	mov    0x18(%r14),%rcx
    7491:	cmpb   $0x0,(%rcx,%rdx,1)
    7495:	je     749e <do_last+0xfe>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2928
		 * dropping this one anyway.
    7497:	or     $0x3,%eax
    749a:	mov    %eax,0x38(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2929
		 */
    749e:	test   $0x200000,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2911
		 * about to look up
		 */
		error = complete_walk(nd);
		if (error)
			return error;

    74a5:	movb   $0x0,0x36(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2929
			got_write = true;
		/*
		 * do _not_ fail yet - we might not need that or fail with
		 * a different error; let lookup_open() decide; we'll be
		 * dropping this one anyway.
		 */
    74aa:	jne    7540 <do_last+0x1a0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2932
	}
	mutex_lock(&dir->d_inode->i_mutex);
	error = lookup_open(nd, path, file, op, got_write, opened);
    74b0:	lea    0x60(%rsp),%rdx
    74b5:	mov    %r13,%rsi
    74b8:	mov    %r14,%rdi
    74bb:	callq  19e0 <lookup_fast>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2933
	mutex_unlock(&dir->d_inode->i_mutex);
    74c0:	test   %eax,%eax
    74c2:	jne    8952 <do_last+0x15b2>
    74c8:	mov    0x8(%r13),%rsi
    74cc:	mov    0x38(%r14),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3027
	if ((open_flag & O_CREAT) &&
	    (d_is_directory(nd->path.dentry) || d_is_autodir(nd->path.dentry)))
		goto out;
	error = -ENOTDIR;
	if ((nd->flags & LOOKUP_DIRECTORY) && !d_is_directory(nd->path.dentry))
		goto out;
    74d0:	mov    (%rsi),%edx
    74d2:	and    $0x40,%eax
    74d5:	and    $0x700000,%edx
    74db:	je     76c0 <do_last+0x320>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2913
		error = complete_walk(nd);
		if (error)
			return error;

		// audit_inode(name, dir, LOOKUP_PARENT);
		msg_audit_inode(name, dir, LOOKUP_PARENT, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    74e1:	movb   $0x0,0x35(%rsp)
should_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1531
	struct inode *inode;
	int err;
	/*
	 * "." and ".." are special - ".." especially so because it has
	 * to be able to know about the current root directory and
	 * parent relationships.
    74e6:	cmp    $0x300000,%edx
    74ec:	je     8971 <do_last+0x15d1>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3043
	error = may_open(&nd->path, acc_mode, open_flag);
	if (error)
		goto out;
	file->f_path.mnt = nd->path.mnt;
	error = finish_open(file, nd->path.dentry, NULL, opened);
	if (error) {
    74f2:	test   %eax,%eax
    74f4:	jne    751a <do_last+0x17a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3043 (discriminator 1)
    74f6:	mov    (%r14),%rdi
    74f9:	cmp    0x0(%r13),%rdi
    74fd:	je     8097 <do_last+0xcf7>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    7503:	mov    0x8(%r14),%rdi
    7507:	callq  750c <do_last+0x16c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    750c:	mov    (%r14),%rdi
    750f:	cmp    0x0(%r13),%rdi
    7513:	je     751e <do_last+0x17e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    7515:	callq  751a <do_last+0x17a>
    751a:	mov    0x0(%r13),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
}

    751e:	mov    %rdi,(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    7521:	mov    0x8(%r13),%rax
    7525:	xor    %r8d,%r8d
    7528:	xor    %r15d,%r15d
    752b:	mov    %rax,0x8(%r14)
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3051
		goto out;
	}
opened:
	error = open_check_o_direct(file);
	if (error)
		goto exit_fput;
    752f:	mov    0x60(%rsp),%rax
    7534:	mov    %rax,0x30(%r14)
    7538:	jmp    7579 <do_last+0x1d9>
    753a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2929 (discriminator 1)
			got_write = true;
		/*
		 * do _not_ fail yet - we might not need that or fail with
		 * a different error; let lookup_open() decide; we'll be
		 * dropping this one anyway.
		 */
    7540:	mov    0x38(%r14),%eax
    7544:	and    $0x1,%eax
    7547:	xor    $0x1,%eax
    754a:	and    $0x1,%eax
    754d:	mov    %al,0x36(%rsp)
    7551:	jmpq   74b0 <do_last+0x110>
    7556:	nopw   %cs:0x0(%rax,%rax,1)
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1501
			follow_dotdot(nd);
	}
	return 0;
}

static void terminate_walk(struct nameidata *nd)
    7560:	cmp    $0x3,%edx
    7563:	je     7711 <do_last+0x371>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2912
		 */
		error = complete_walk(nd);
		if (error)
			return error;

		// audit_inode(name, dir, LOOKUP_PARENT);
    7569:	xor    %r8d,%r8d
    756c:	xor    %r15d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2913
		msg_audit_inode(name, dir, LOOKUP_PARENT, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    756f:	movb   $0x0,0x35(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2911
		 * about to look up
		 */
		error = complete_walk(nd);
		if (error)
			return error;

    7574:	movb   $0x0,0x36(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3054
	error = open_check_o_direct(file);
	if (error)
		goto exit_fput;
	// error = ima_file_check(file, op->acc_mode);
  error = 0;
	if (error)
    7579:	mov    %r14,%rdi
    757c:	mov    %r8,0x28(%rsp)
    7581:	callq  410 <complete_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3055
		goto exit_fput;
    7586:	test   %eax,%eax
    7588:	mov    0x28(%rsp),%r8
    758d:	jne    7966 <do_last+0x5c6>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    7593:	mov    %gs:0x0,%rdx
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3059

	if (will_truncate) {
		error = handle_truncate(file);
		if (error)
    759c:	mov    0x8(%r14),%rcx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    75a0:	add    $0x4a8,%rdx
    75a7:	mov    $0x0,%rax
    75ae:	jmp    75b9 <do_last+0x219>
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    75b0:	test   %sil,%sil
    75b3:	je     86ef <do_last+0x134f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    75b9:	add    $0x1,%rdx
    75bd:	movzbl -0x1(%rdx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    75c1:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    75c5:	cmp    -0x1(%rax),%sil
    75c9:	je     75b0 <do_last+0x210>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    75cb:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    75d4:	mov    $0x0,%rax
    75db:	add    $0x4a8,%rdx
    75e2:	jmp    75f1 <do_last+0x251>
    75e4:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    75e8:	test   %sil,%sil
    75eb:	je     86ef <do_last+0x134f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    75f1:	add    $0x1,%rdx
    75f5:	movzbl -0x1(%rdx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    75f9:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    75fd:	cmp    -0x1(%rax),%sil
    7601:	je     75e8 <do_last+0x248>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    7603:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    760c:	mov    $0x0,%rax
    7613:	add    $0x4a8,%rdx
    761a:	jmp    7629 <do_last+0x289>
    761c:	nopl   0x0(%rax)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7620:	test   %sil,%sil
    7623:	je     7a0d <do_last+0x66d>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7629:	add    $0x1,%rdx
    762d:	movzbl -0x1(%rdx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    7631:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    7635:	cmp    -0x1(%rax),%sil
    7639:	je     7620 <do_last+0x280>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    763b:	mov    %gs:0x0,%rax
    7644:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    764b:	test   %rax,%rax
    764e:	je     766f <do_last+0x2cf>
    7650:	mov    (%rax),%eax
    7652:	test   %eax,%eax
    7654:	jne    766f <do_last+0x2cf>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:167
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context())) {
		unsigned int flags = 0;
		if (parent)
			flags |= AUDIT_INODE_PARENT;
		__audit_inode(name, dentry, flags);
    7656:	mov    0x48(%rsp),%rdi
    765b:	xor    %edx,%edx
    765d:	mov    %rcx,%rsi
    7660:	mov    %r8,0x28(%rsp)
    7665:	callq  766a <do_last+0x2ca>
    766a:	mov    0x28(%rsp),%r8
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3061
			goto exit_fput;
	}
    766f:	test   $0x40,%r12b
    7673:	je     7983 <do_last+0x5e3>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:434 (discriminator 1)
static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
}

static inline bool d_is_directory(const struct dentry *dentry)
    7679:	mov    0x8(%r14),%rax
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431 (discriminator 1)
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    767d:	mov    (%rax),%eax
    767f:	and    $0x700000,%eax
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3061 (discriminator 1)
    7684:	cmp    $0x100000,%eax
    7689:	je     7696 <do_last+0x2f6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3062
out:
    768b:	cmp    $0x200000,%eax
    7690:	jne    7983 <do_last+0x5e3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3060
		goto exit_fput;

	if (will_truncate) {
		error = handle_truncate(file);
		if (error)
			goto exit_fput;
    7696:	mov    $0xffffffeb,%eax
    769b:	jmp    76e2 <do_last+0x342>
    769d:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2947

		audit_inode(name, file->f_path.dentry, 0);
		goto opened;
	}

	if (*opened & FILE_CREATED) {
    76a0:	mov    %r14,%rdi
    76a3:	callq  410 <complete_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2948
		/* Don't check for write permission, don't truncate */
    76a8:	test   %eax,%eax
    76aa:	je     77d8 <do_last+0x438>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3132
	if (error)
		goto out2;
	audit_inode(pathname, nd->path.dentry, 0);
	error = may_open(&nd->path, op->acc_mode, op->open_flag);
	if (error)
		goto out2;
    76b0:	add    $0x68,%rsp
    76b4:	pop    %rbx
    76b5:	pop    %r12
    76b7:	pop    %r13
    76b9:	pop    %r14
    76bb:	pop    %r15
    76bd:	pop    %rbp
    76be:	retq   
    76bf:	nop
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    76c0:	test   %eax,%eax
    76c2:	je     7946 <do_last+0x5a6>
    76c8:	mov    0x0(%r13),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    76cc:	mov    %rdi,(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    76cf:	mov    0x8(%r13),%rax
    76d3:	xor    %r8d,%r8d
    76d6:	xor    %r15d,%r15d
    76d9:	mov    %rax,0x8(%r14)
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3026
	error = -EISDIR;
	if ((open_flag & O_CREAT) &&
	    (d_is_directory(nd->path.dentry) || d_is_autodir(nd->path.dentry)))
		goto out;
	error = -ENOTDIR;
	if ((nd->flags & LOOKUP_DIRECTORY) && !d_is_directory(nd->path.dentry))
    76dd:	mov    $0xfffffffe,%eax
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    76e2:	mov    %r8,%rdi
    76e5:	mov    %eax,0x50(%rsp)
    76e9:	callq  76ee <do_last+0x34e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    76ee:	mov    %r15,%rdi
    76f1:	callq  76f6 <do_last+0x356>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3105
	int error = path_lookupat(dfd, pathname->name,
				  flags | LOOKUP_DIRECTORY, nd);
	if (unlikely(error))
		return error;
	error = mnt_want_write(nd->path.mnt);
	if (unlikely(error))
    76f6:	mov    %r14,%rdi
    76f9:	callq  cc0 <terminate_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3106
		goto out;
    76fe:	mov    0x50(%rsp),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3132
	if (error)
		goto out2;
	audit_inode(pathname, nd->path.dentry, 0);
	error = may_open(&nd->path, op->acc_mode, op->open_flag);
	if (error)
		goto out2;
    7702:	add    $0x68,%rsp
    7706:	pop    %rbx
    7707:	pop    %r12
    7709:	pop    %r13
    770b:	pop    %r14
    770d:	pop    %r15
    770f:	pop    %rbp
    7710:	retq   
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1502
	}
	return 0;
}

static void terminate_walk(struct nameidata *nd)
{
    7711:	test   $0x40,%al
    7713:	je     7a65 <do_last+0x6c5>
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:659

static __always_inline void set_root_rcu(struct nameidata *nd)
{
	if (!nd->root.mnt) {
		struct fs_struct *fs = current->fs;
		unsigned seq;
    7719:	cmpq   $0x0,0x20(%r14)
    771e:	je     81e8 <do_last+0xe48>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2905
		BUG_ON(nd->inode != dir->d_inode);
	} else {
		/* create side of things */
		/*
		 * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED
		 * has been cleared when we got to the last component we are
    7724:	mov    0x50(%rsp),%rdx
    7729:	jmp    7767 <do_last+0x3c7>
    772b:	nopl   0x0(%rax,%rax,1)
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1166
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
			unsigned seq;

			seq = read_seqcount_begin(&parent->d_seq);
			if (read_seqcount_retry(&old->d_seq, nd->seq))
    7730:	mov    (%rax),%rsi
    7733:	cmp    %rdx,%rsi
    7736:	jne    7ace <do_last+0x72e>
follow_up_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:900
	parent = mnt->mnt_parent;
	if (&parent->mnt == path->mnt)
		return 0;
	mountpoint = mnt->mnt_mountpoint;
	path->dentry = mountpoint;
	path->mnt = &parent->mnt;
    773c:	mov    -0x10(%rax),%rdi
    7740:	lea    0x20(%rdi),%rdx
    7744:	cmp    %rax,%rdx
    7747:	je     77b3 <do_last+0x413>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:902
	return 1;
}
    7749:	mov    -0x8(%rax),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:904

/*
    774d:	mov    %rdx,(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:903
	mountpoint = mnt->mnt_mountpoint;
	path->dentry = mountpoint;
	path->mnt = &parent->mnt;
	return 1;
}

    7750:	mov    %rcx,0x8(%r14)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    7754:	mov    0x4(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    7757:	test   $0x1,%al
    7759:	jne    8942 <do_last+0x15a2>
raw_read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:132
 * section is tested by checking read_seqcount_retry function.
 */
static inline unsigned raw_read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret = __read_seqcount_begin(s);
	smp_rmb();
    775f:	mov    0x8(%r14),%rdx
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1180
	}
	follow_mount_rcu(nd);
	nd->inode = nd->path.dentry->d_inode;
	return 0;

failed:
    7763:	mov    %eax,0x3c(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1162
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
    7767:	mov    0x28(%r14),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1163
			unsigned seq;
    776b:	mov    (%r14),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1162
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			struct dentry *old = nd->path.dentry;
			struct dentry *parent = old->d_parent;
    776e:	cmp    %rdx,%rsi
    7771:	jne    7730 <do_last+0x390>
    7773:	cmp    0x20(%r14),%rax
    7777:	jne    7730 <do_last+0x390>
    7779:	jmp    77b3 <do_last+0x413>
    777b:	nopl   0x0(%rax,%rax,1)
follow_mount_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1148
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
	}
    7780:	mov    (%r14),%rdi
    7783:	callq  7788 <do_last+0x3e8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1149
}
    7788:	test   %rax,%rax
    778b:	je     7ac5 <do_last+0x725>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1151

static int follow_dotdot_rcu(struct nameidata *nd)
    7791:	lea    0x20(%rax),%rdx
    7795:	mov    %rdx,(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1152
{
    7798:	mov    0x20(%rax),%rdx
    779c:	mov    %rdx,0x8(%r14)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    77a0:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    77a3:	test   $0x1,%al
    77a5:	jne    885a <do_last+0x14ba>
follow_mount_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1146
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
    77ab:	mov    0x8(%r14),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1153
	}
}

static int follow_dotdot_rcu(struct nameidata *nd)
{
	set_root_rcu(nd);
    77af:	mov    %eax,0x3c(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1146
		struct mount *mounted;
		mounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);
		if (!mounted)
			break;
		nd->path.mnt = &mounted->mnt;
		nd->path.dentry = mounted->mnt.mnt_root;
    77b3:	testl  $0x10000,(%rsi)
    77b9:	jne    7780 <do_last+0x3e0>
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1183
	return 0;

failed:
	nd->flags &= ~LOOKUP_RCU;
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
    77bb:	mov    0x30(%rsi),%rax
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2912
		 */
		error = complete_walk(nd);
		if (error)
			return error;

		// audit_inode(name, dir, LOOKUP_PARENT);
    77bf:	xor    %r8d,%r8d
    77c2:	xor    %r15d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2913
		msg_audit_inode(name, dir, LOOKUP_PARENT, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    77c5:	movb   $0x0,0x35(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2911
		 * about to look up
		 */
		error = complete_walk(nd);
		if (error)
			return error;

    77ca:	movb   $0x0,0x36(%rsp)
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1183
	return 0;

failed:
	nd->flags &= ~LOOKUP_RCU;
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
    77cf:	mov    %rax,0x30(%r14)
    77d3:	jmpq   7579 <do_last+0x1d9>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2952
	if (*opened & FILE_CREATED) {
		/* Don't check for write permission, don't truncate */
		open_flag &= ~O_TRUNC;
		will_truncate = false;
		acc_mode = MAY_OPEN;
		path_to_nameidata(path, nd);
    77d8:	mov    0x0(%rip),%r8d        # 77df <do_last+0x43f>
    77df:	mov    0x0(%rip),%ecx        # 77e5 <do_last+0x445>
    77e5:	mov    $0x10,%edx
    77ea:	mov    0x50(%rsp),%rsi
    77ef:	mov    0x48(%rsp),%rdi
    77f4:	callq  77f9 <do_last+0x459>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2955
		goto finish_open_created;
	}

    77f9:	mov    0x14(%r14),%eax
    77fd:	mov    0x18(%r14),%rdx
    7801:	cmpb   $0x0,(%rdx,%rax,1)
    7805:	jne    7a26 <do_last+0x686>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2913
		error = complete_walk(nd);
		if (error)
			return error;

		// audit_inode(name, dir, LOOKUP_PARENT);
		msg_audit_inode(name, dir, LOOKUP_PARENT, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    780b:	movb   $0x0,0x35(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2911
		 * about to look up
		 */
		error = complete_walk(nd);
		if (error)
			return error;

    7810:	movb   $0x0,0x36(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2960

	/*
	 * create/update audit record if it already exists.
	 */
	if (d_is_positive(path->dentry))
		audit_inode(name, path->dentry, 0);
    7815:	testl  $0x243,(%rbx)
    781b:	movb   $0x0,0x28(%rsp)
    7820:	jne    8060 <do_last+0xcc0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2970
	 * necessary...)
	 */
	if (got_write) {
		mnt_drop_write(nd->path.mnt);
		got_write = false;
	}
    7826:	mov    0x50(%rsp),%rax
    782b:	mov    0x30(%rax),%rax
    782f:	lea    0xa8(%rax),%rdi
    7836:	mov    %rax,0x20(%rsp)
    783b:	callq  7840 <do_last+0x4a0>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2832
			mode &= ~current_umask();
		/*
		 * This write is needed to ensure that a
		 * rw->ro transition does not occur between
		 * the time when the file is created and when
		 * a permanent write count is taken through
    7840:	mov    0x8(%r14),%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2839
		 */
		if (!got_write) {
			error = -EROFS;
			goto out_dput;
		}
		*opened |= FILE_CREATED;
    7844:	lea    0x10(%r14),%rdi
    7848:	lea    0x5f(%rsp),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2833
		/*
		 * This write is needed to ensure that a
		 * rw->ro transition does not occur between
		 * the time when the file is created and when
		 * a permanent write count is taken through
		 * the 'struct file' in finish_open().
    784d:	mov    0x30(%r8),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2839
		 */
		if (!got_write) {
			error = -EROFS;
			goto out_dput;
		}
		*opened |= FILE_CREATED;
    7851:	mov    %r8,%rsi
    7854:	mov    %r8,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2833
		/*
		 * This write is needed to ensure that a
		 * rw->ro transition does not occur between
		 * the time when the file is created and when
		 * a permanent write count is taken through
		 * the 'struct file' in finish_open().
    7859:	mov    %rax,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2838
		 */
		if (!got_write) {
			error = -EROFS;
			goto out_dput;
		}
    785e:	mov    0x38(%rsp),%rax
    7863:	andl   $0xfffffffe,(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2839
		*opened |= FILE_CREATED;
    7866:	mov    0x38(%r14),%edx
    786a:	callq  8f0 <lookup_dcache>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2840
		// error = security_path_mknod(&nd->path, dentry, mode, 0);
    786f:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2839
		 */
		if (!got_write) {
			error = -EROFS;
			goto out_dput;
		}
		*opened |= FILE_CREATED;
    7875:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2840
		// error = security_path_mknod(&nd->path, dentry, mode, 0);
    7878:	mov    0x20(%rsp),%r8
    787d:	ja     88a7 <do_last+0x1507>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2844
    error = 0;
		if (error)
			goto out_dput;
		error = vfs_create(dir->d_inode, dentry, mode,
    7883:	movzbl 0x5f(%rsp),%r9d
    7889:	mov    0x30(%rax),%rax
    788d:	test   %r9b,%r9b
    7890:	jne    7af7 <do_last+0x757>
    7896:	test   %rax,%rax
    7899:	je     7af7 <do_last+0x757>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2887
		if (error)
			return error;
		goto finish_open;
	}

	if (!(open_flag & O_CREAT)) {
    789f:	mov    %r15,0x8(%r13)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2888
		if (nd->last.name[nd->last.len])
    78a3:	mov    (%r14),%rax
    78a6:	mov    %rax,0x0(%r13)
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2972
	if (got_write) {
		mnt_drop_write(nd->path.mnt);
		got_write = false;
	}

	error = -EEXIST;
    78aa:	mov    0x50(%rsp),%rax
    78af:	mov    0x30(%rax),%rax
    78b3:	lea    0xa8(%rax),%rdi
    78ba:	mov    %rax,0x20(%rsp)
    78bf:	callq  78c4 <do_last+0x524>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2986
		nd->flags |= LOOKUP_JUMPED;

	BUG_ON(nd->flags & LOOKUP_RCU);
	inode = path->dentry->d_inode;
finish_lookup:
	/* we _can_ be in RCU mode here */
    78c4:	mov    0x38(%rsp),%rax
    78c9:	testb  $0x1,(%rax)
    78cc:	jne    80ba <do_last+0xd1a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2998
	if (should_follow_link(path->dentry, !symlink_ok)) {
		if (nd->flags & LOOKUP_RCU) {
			if (unlikely(unlazy_walk(nd, path->dentry))) {
				error = -ECHILD;
				goto out;
			}
    78d2:	mov    0x8(%r13),%r15
    78d6:	testl  $0x700000,(%r15)
    78dd:	jne    810b <do_last+0xd6b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3006
		return 1;
	}

	if ((nd->flags & LOOKUP_RCU) || nd->path.mnt != path->mnt) {
		path_to_nameidata(path, nd);
	} else {
    78e3:	cmpb   $0x0,0x28(%rsp)
    78e8:	jne    80fe <do_last+0xd5e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3012
		save_parent.dentry = nd->path.dentry;
		save_parent.mnt = mntget(path->mnt);
		nd->path.dentry = path->dentry;

	}
	nd->inode = inode;
    78ee:	mov    %r12d,%eax
    78f1:	and    $0xc0,%eax
    78f6:	cmp    $0xc0,%eax
    78fb:	je     8074 <do_last+0xcd4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3015
	/* Why this, you ask?  _Now_ we might have grown LOOKUP_JUMPED... */
finish_open:
	error = complete_walk(nd);
    7901:	mov    0x38(%r14),%esi
    7905:	mov    %r13,%rdi
    7908:	callq  4f0 <follow_managed>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3016
	if (error) {
    790d:	test   %eax,%eax
    790f:	js     8079 <do_last+0xcd9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3020
		path_put(&save_parent);
		return error;
	}
	audit_inode(name, nd->path.dentry, 0);
    7915:	mov    0x38(%r14),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3019
finish_open:
	error = complete_walk(nd);
	if (error) {
		path_put(&save_parent);
		return error;
	}
    7919:	je     7922 <do_last+0x582>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3020
	audit_inode(name, nd->path.dentry, 0);
    791b:	or     $0x10,%ah
    791e:	mov    %eax,0x38(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3022
	error = -EISDIR;
	if ((open_flag & O_CREAT) &&
    7922:	and    $0x40,%eax
    7925:	jne    872d <do_last+0x138d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3023
	    (d_is_directory(nd->path.dentry) || d_is_autodir(nd->path.dentry)))
    792b:	mov    0x8(%r13),%rsi
    792f:	mov    0x30(%rsi),%rdx
    7933:	mov    %rdx,0x60(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3027
		goto out;
	error = -ENOTDIR;
	if ((nd->flags & LOOKUP_DIRECTORY) && !d_is_directory(nd->path.dentry))
		goto out;
    7938:	mov    (%rsi),%edx
    793a:	and    $0x700000,%edx
    7940:	jne    74e6 <do_last+0x146>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    7946:	mov    0x8(%r14),%rdi
    794a:	callq  794f <do_last+0x5af>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    794f:	mov    (%r14),%rdi
    7952:	cmp    0x0(%r13),%rdi
    7956:	je     76cc <do_last+0x32c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    795c:	callq  7961 <do_last+0x5c1>
    7961:	jmpq   76c8 <do_last+0x328>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    7966:	mov    %r8,%rdi
    7969:	mov    %eax,0x50(%rsp)
    796d:	callq  7972 <do_last+0x5d2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    7972:	mov    %r15,%rdi
    7975:	callq  797a <do_last+0x5da>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3057
	// error = ima_file_check(file, op->acc_mode);
  error = 0;
	if (error)
		goto exit_fput;

	if (will_truncate) {
    797a:	mov    0x50(%rsp),%eax
    797e:	jmpq   76b0 <do_last+0x310>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3065
			goto exit_fput;
	}
out:
	if (got_write)
		mnt_drop_write(nd->path.mnt);
	path_put(&save_parent);
    7983:	testb  $0x2,0x38(%r14)
    7988:	je     79a7 <do_last+0x607>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:434 (discriminator 1)
}

static inline bool d_is_directory(const struct dentry *dentry)
    798a:	mov    0x8(%r14),%rax
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431 (discriminator 1)
	spin_unlock(&dentry->d_lock);
}

static inline unsigned __d_entry_type(const struct dentry *dentry)
{
	return dentry->d_flags & DCACHE_ENTRY_TYPE;
    798e:	mov    (%rax),%edx
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3064 (discriminator 1)
		if (error)
			goto exit_fput;
	}
out:
	if (got_write)
		mnt_drop_write(nd->path.mnt);
    7990:	mov    $0xffffffec,%eax
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431 (discriminator 1)
    7995:	and    $0x700000,%edx
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3065 (discriminator 1)
	path_put(&save_parent);
    799b:	cmp    $0x100000,%edx
    79a1:	jne    76e2 <do_last+0x342>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3067
	terminate_walk(nd);
	return error;
    79a7:	mov    0x30(%r14),%rax
    79ab:	movzwl (%rax),%eax
    79ae:	and    $0xf000,%ax
    79b2:	cmp    $0x8000,%ax
    79b6:	je     7a36 <do_last+0x696>
    79b8:	movb   $0x0,0x28(%rsp)
    79bd:	movb   $0x0,0x37(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3077
exit_fput:
	fput(file);
	goto out;

stale_open:
	/* If no saved parent or already retried then can't retry */
    79c2:	mov    0x30(%rsp),%esi
    79c6:	mov    %r12d,%edx
    79c9:	mov    %r14,%rdi
    79cc:	mov    %r8,0x20(%rsp)
    79d1:	callq  5000 <may_open>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3078
	if (!save_parent.dentry || retried)
    79d6:	test   %eax,%eax
    79d8:	mov    0x20(%rsp),%r8
    79dd:	je     7fc8 <do_last+0xc28>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3102
	static const struct qstr name = QSTR_INIT("/", 1);
	struct dentry *dentry, *child;
	struct inode *dir;
	int error = path_lookupat(dfd, pathname->name,
				  flags | LOOKUP_DIRECTORY, nd);
	if (unlikely(error))
    79e3:	cmpb   $0x0,0x28(%rsp)
    79e8:	je     76e2 <do_last+0x342>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3103
		return error;
    79ee:	mov    (%r14),%rdi
    79f1:	mov    %eax,0x48(%rsp)
    79f5:	mov    %r8,0x50(%rsp)
    79fa:	callq  79ff <do_last+0x65f>
    79ff:	mov    0x48(%rsp),%eax
    7a03:	mov    0x50(%rsp),%r8
    7a08:	jmpq   76e2 <do_last+0x342>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    7a0d:	cmpb   $0x0,0x0(%rip)        # 7a14 <do_last+0x674>
    7a14:	mov    0x0(%rip),%rax        # 7a1b <do_last+0x67b>
    7a1b:	jne    7644 <do_last+0x2a4>
    7a21:	jmpq   763b <do_last+0x29b>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2912
		 */
		error = complete_walk(nd);
		if (error)
			return error;

		// audit_inode(name, dir, LOOKUP_PARENT);
    7a26:	xor    %r8d,%r8d
    7a29:	xor    %r15d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2953
		/* Don't check for write permission, don't truncate */
		open_flag &= ~O_TRUNC;
		will_truncate = false;
		acc_mode = MAY_OPEN;
		path_to_nameidata(path, nd);
		goto finish_open_created;
    7a2c:	mov    $0xffffffeb,%eax
    7a31:	jmpq   76e2 <do_last+0x342>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3070
	path_put(&save_parent);
	terminate_walk(nd);
	return error;

exit_dput:
	path_put_conditional(path, nd);
    7a36:	cmpb   $0x0,0x37(%rsp)
    7a3b:	je     8682 <do_last+0x12e2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3071
	goto out;
    7a41:	mov    (%r14),%rdi
    7a44:	mov    %r8,0x28(%rsp)
    7a49:	callq  7a4e <do_last+0x6ae>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3072
exit_fput:
    7a4e:	test   %eax,%eax
    7a50:	mov    0x28(%rsp),%r8
    7a55:	jne    76e2 <do_last+0x342>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3074
	fput(file);
	goto out;
    7a5b:	movb   $0x1,0x28(%rsp)
    7a60:	jmpq   79c2 <do_last+0x622>
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    7a65:	cmpq   $0x0,0x20(%r14)
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2905
		BUG_ON(nd->inode != dir->d_inode);
	} else {
		/* create side of things */
		/*
		 * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED
		 * has been cleared when we got to the last component we are
    7a6a:	mov    0x50(%rsp),%r15
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    7a6f:	jne    7a9d <do_last+0x6fd>
    7a71:	jmpq   82ad <do_last+0xf0d>
    7a76:	nopw   %cs:0x0(%rax,%rax,1)
follow_dotdot():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1270
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
    7a80:	cmp    %r15,(%rax)
    7a83:	jne    7eee <do_last+0xb4e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1276
			break;
	}
	follow_mount(&nd->path);
	nd->inode = nd->path.dentry->d_inode;
}

    7a89:	mov    %r14,%rdi
    7a8c:	nopl   0x0(%rax)
    7a90:	callq  7a95 <do_last+0x6f5>
    7a95:	test   %eax,%eax
    7a97:	je     7aac <do_last+0x70c>
    7a99:	mov    0x8(%r14),%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1266
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
    7a9d:	cmp    %r15,0x28(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1267
			dput(old);
    7aa1:	mov    (%r14),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1266
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
    7aa4:	jne    7a80 <do_last+0x6e0>
    7aa6:	cmp    0x20(%r14),%rax
    7aaa:	jne    7a80 <do_last+0x6e0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1279
	nd->inode = nd->path.dentry->d_inode;
}

/*
 * This looks up the name in dcache, possibly revalidates the old dentry and
 * allocates a new one if not found or not valid.  In the need_lookup argument
    7aac:	mov    %r14,%rdi
    7aaf:	callq  15c0 <follow_mount>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1280
 * returns whether i_op->lookup is necessary.
    7ab4:	mov    0x8(%r14),%rax
    7ab8:	mov    0x30(%rax),%rax
    7abc:	mov    %rax,0x30(%r14)
    7ac0:	jmpq   7569 <do_last+0x1c9>
    7ac5:	mov    0x8(%r14),%rsi
    7ac9:	jmpq   77bb <do_last+0x41b>
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1168
			unsigned seq;

			seq = read_seqcount_begin(&parent->d_seq);
			if (read_seqcount_retry(&old->d_seq, nd->seq))
				goto failed;
			nd->path.dentry = parent;
    7ace:	mov    0x18(%rdx),%rsi
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    7ad2:	mov    0x4(%rsi),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    7ad5:	test   $0x1,%al
    7ad7:	jne    8898 <do_last+0x14f8>
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1172
			nd->seq = seq;
			break;
		}
		if (!follow_up_rcu(&nd->path))
    7add:	mov    0x3c(%r14),%ecx
    7ae1:	cmp    0x4(%rdx),%ecx
    7ae4:	jne    8874 <do_last+0x14d4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1174
			break;
		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
    7aea:	mov    %rsi,0x8(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1175
	}
    7aee:	mov    %eax,0x3c(%r14)
    7af2:	jmpq   77b3 <do_last+0x413>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2847
		if (error)
			goto out_dput;
		error = vfs_create(dir->d_inode, dentry, mode,
				   nd->flags & LOOKUP_EXCL);
		if (error)
			goto out_dput;
    7af7:	mov    0x38(%r14),%edx
    7afb:	test   $0x1,%dh
    7afe:	je     7f07 <do_last+0xb67>
    7b04:	mov    0x18(%rsp),%rdi
    7b09:	mov    0x20(%rdi),%rcx
    7b0d:	cmpq   $0x0,0xb0(%rcx)
    7b15:	je     7f07 <do_last+0xb67>
atomic_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2661
	 * to check access and if not granted clear O_CREAT from the flags.
	 *
	 * Another problem is returing the "right" error value (e.g. for an
	 * O_EXCL open we want to return EEXIST not EROFS).
	 */
	if (((open_flag & (O_CREAT | O_TRUNC)) ||
    7b1b:	mov    0x8(%r14),%rdx
    7b1f:	mov    0x30(%rdx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2662
	    (open_flag & O_ACCMODE) != O_RDONLY) && unlikely(!got_write)) {
    7b23:	mov    (%rbx),%edx
open_to_namei_flags():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2615
}

/*
 * Attempt to atomically look up, create and open a file from a negative
 * dentry.
 *
    7b25:	mov    %edx,%ecx
atomic_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2661
	 * to check access and if not granted clear O_CREAT from the flags.
	 *
	 * Another problem is returing the "right" error value (e.g. for an
	 * O_EXCL open we want to return EEXIST not EROFS).
	 */
	if (((open_flag & (O_CREAT | O_TRUNC)) ||
    7b27:	mov    %rdi,0x10(%rsp)
open_to_namei_flags():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2615
}

/*
 * Attempt to atomically look up, create and open a file from a negative
 * dentry.
 *
    7b2c:	and    $0x3,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2616
 * Returns 0 if successful.  The file will have been created and attached to
    7b2f:	cmp    $0x3,%ecx
    7b32:	sete   %cl
    7b35:	movzbl %cl,%ecx
    7b38:	sub    %ecx,%edx
atomic_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2670
			 * No O_CREATE -> atomicity not a requirement -> fall
			 * back to lookup + open
			 */
			goto no_open;
		} else if (open_flag & (O_EXCL | O_TRUNC)) {
			/* Fall back and fail with the right error */
    7b3a:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2662
	 *
	 * Another problem is returing the "right" error value (e.g. for an
	 * O_EXCL open we want to return EEXIST not EROFS).
	 */
	if (((open_flag & (O_CREAT | O_TRUNC)) ||
	    (open_flag & O_ACCMODE) != O_RDONLY) && unlikely(!got_write)) {
    7b3d:	mov    %edx,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2670
			 * No O_CREATE -> atomicity not a requirement -> fall
			 * back to lookup + open
			 */
			goto no_open;
		} else if (open_flag & (O_EXCL | O_TRUNC)) {
			/* Fall back and fail with the right error */
    7b41:	jne    8870 <do_last+0x14d0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2673
			create_error = -EROFS;
			goto no_open;
		} else {
    7b47:	mov    0x10(%rsp),%rax
    7b4c:	testb  $0x10,0xc(%rax)
    7b50:	jne    87a3 <do_last+0x1403>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2678
			/* No side effects, safe to clear O_CREAT */
			create_error = -EROFS;
			open_flag &= ~O_CREAT;
		}
	}
    7b56:	movzwl 0x4(%rbx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2679

    7b5a:	mov    %edx,%ecx
    7b5c:	and    $0x40,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2678
		} else {
			/* No side effects, safe to clear O_CREAT */
			create_error = -EROFS;
			open_flag &= ~O_CREAT;
		}
	}
    7b5f:	mov    %ax,0xe(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2679

    7b64:	je     7b9b <do_last+0x7fb>
    7b66:	mov    0x10(%rsp),%rax
    7b6b:	mov    0x28(%rax),%rax
    7b6f:	testb  $0x1,0x52(%rax)
    7b73:	jne    7b9b <do_last+0x7fb>
    7b75:	mov    %edx,0x4(%rsp)
    7b79:	mov    %ecx,0x8(%rsp)
    7b7d:	mov    %r9d,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2680
	if (open_flag & O_CREAT) {
    7b82:	callq  7b87 <do_last+0x7e7>
    7b87:	not    %eax
    7b89:	and    %ax,0xe(%rsp)
    7b8e:	mov    0x4(%rsp),%edx
    7b92:	mov    0x8(%rsp),%ecx
    7b96:	mov    0x20(%rsp),%r9d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2682
		error = may_o_create(&nd->path, dentry, mode);
		if (error) {
    7b9b:	mov    %edx,%eax
    7b9d:	and    $0xc0,%eax
    7ba2:	cmp    $0xc0,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2683
			create_error = error;
    7ba7:	sete   0x8(%rsp)
    7bac:	jne    7bba <do_last+0x81a>
    7bae:	mov    %edx,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2684
			if (open_flag & O_EXCL)
    7bb0:	and    $0xfd,%dh
    7bb3:	and    $0x40,%ecx
    7bb6:	mov    %edx,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2695
	if (nd->flags & LOOKUP_DIRECTORY)
		open_flag |= O_DIRECTORY;

	file->f_path.dentry = DENTRY_NOT_SET;
	file->f_path.mnt = nd->path.mnt;
	error = dir->i_op->atomic_open(dir, dentry, file, open_flag, mode,
    7bba:	testl  $0x243,0x18(%rsp)
    7bc2:	je     7bcf <do_last+0x82f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2696
				      opened);
    7bc4:	cmpb   $0x0,0x28(%rsp)
    7bc9:	je     87b0 <do_last+0x1410>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2714
			dput(dentry);
			dentry = file->f_path.dentry;
		}
		if (*opened & FILE_CREATED)
			fsnotify_create(dir, dentry);
		if (!dentry->d_inode) {
    7bcf:	test   %ecx,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2666
	if (((open_flag & (O_CREAT | O_TRUNC)) ||
	    (open_flag & O_ACCMODE) != O_RDONLY) && unlikely(!got_write)) {
		if (!(open_flag & O_CREAT)) {
			/*
			 * No O_CREATE -> atomicity not a requirement -> fall
			 * back to lookup + open
    7bd1:	movl   $0x0,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2714
			dput(dentry);
			dentry = file->f_path.dentry;
		}
		if (*opened & FILE_CREATED)
			fsnotify_create(dir, dentry);
		if (!dentry->d_inode) {
    7bd9:	jne    8470 <do_last+0x10d0>
    7bdf:	movzwl 0xe(%rsp),%r8d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2725
		} else {
			if (excl && !(*opened & FILE_CREATED)) {
				error = -EEXIST;
				goto out;
			}
		}
    7be5:	mov    0x18(%rsp),%edi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2727
		goto looked_up;
	}
    7be9:	mov    0x40(%rsp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2729

	/*
    7bee:	mov    %r15,%rsi
    7bf1:	mov    0x38(%rsp),%r9
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2725
		} else {
			if (excl && !(*opened & FILE_CREATED)) {
				error = -EEXIST;
				goto out;
			}
		}
    7bf6:	mov    %edi,%eax
    7bf8:	or     $0x10000,%eax
    7bfd:	testb  $0x2,0x38(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2727
		goto looked_up;
	}
    7c02:	movq   $0xffffffffffffffff,0x18(%rdx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2725
		} else {
			if (excl && !(*opened & FILE_CREATED)) {
				error = -EEXIST;
				goto out;
			}
		}
    7c0a:	cmove  %edi,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2729
		goto looked_up;
	}

	/*
    7c0d:	mov    0x10(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2725
		} else {
			if (excl && !(*opened & FILE_CREATED)) {
				error = -EEXIST;
				goto out;
			}
		}
    7c12:	mov    %eax,%ecx
    7c14:	mov    %eax,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2728
		goto looked_up;
	}

    7c18:	mov    (%r14),%rax
    7c1b:	mov    %rax,0x10(%rdx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2729
	/*
    7c1f:	mov    0x20(%rdi),%rax
    7c23:	callq  *0xb0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2731
	 * We didn't have the inode before the open, so check open permission
	 * here.
    7c29:	test   %eax,%eax
    7c2b:	js     844f <do_last+0x10af>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2737
	 */
	acc_mode = op->acc_mode;
	if (*opened & FILE_CREATED) {
		WARN_ON(!(open_flag & O_CREAT));
		fsnotify_create(dir, dentry);
		acc_mode = MAY_OPEN;
    7c31:	je     8310 <do_last+0xf70>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2738
	}
    7c37:	mov    0x40(%rsp),%rax
    7c3c:	mov    0x18(%rax),%rax
    7c40:	cmp    $0xffffffffffffffff,%rax
    7c44:	je     875b <do_last+0x13bb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2742
	error = may_open(&file->f_path, acc_mode, open_flag);
	if (error)
		fput(file);

    7c4a:	test   %rax,%rax
    7c4d:	je     7c60 <do_last+0x8c0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2743
out:
    7c4f:	mov    %r15,%rdi
    7c52:	callq  7c57 <do_last+0x8b7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2744
	dput(dentry);
    7c57:	mov    0x40(%rsp),%rax
    7c5c:	mov    0x18(%rax),%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2746
	return error;

    7c60:	mov    0x38(%rsp),%rax
    7c65:	testb  $0x1,(%rax)
    7c68:	jne    85cc <do_last+0x122c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2748
no_open:
	if (need_lookup) {
    7c6e:	cmpq   $0x0,0x30(%r15)
    7c73:	je     88b1 <do_last+0x1511>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2755
		if (IS_ERR(dentry))
			return PTR_ERR(dentry);

		if (create_error) {
			int open_flag = op->open_flag;

    7c79:	cmpb   $0x0,0x8(%rsp)
    7c7e:	je     7c8e <do_last+0x8ee>
    7c80:	mov    0x38(%rsp),%rax
    7c85:	testb  $0x1,(%rax)
    7c88:	je     874e <do_last+0x13ae>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2804
	bool need_lookup;

	*opened &= ~FILE_CREATED;
	dentry = lookup_dcache(&nd->last, dir, nd->flags, &need_lookup);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    7c8e:	mov    %r15,0x8(%r13)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2805

    7c92:	mov    (%r14),%rax
    7c95:	mov    %rax,0x0(%r13)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2806
	/* Cached positive dentry: will open in f_op->open */
    7c99:	mov    $0x1,%eax
    7c9e:	mov    %eax,0x18(%rsp)
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2972
	if (got_write) {
		mnt_drop_write(nd->path.mnt);
		got_write = false;
	}

	error = -EEXIST;
    7ca2:	mov    0x50(%rsp),%rax
    7ca7:	mov    0x30(%rax),%rax
    7cab:	lea    0xa8(%rax),%rdi
    7cb2:	mov    %rax,0x20(%rsp)
    7cb7:	callq  7cbc <do_last+0x91c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2974
	if ((open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT))
		goto exit_dput;
    7cbc:	mov    0x18(%rsp),%eax
    7cc0:	cmp    $0x0,%eax
    7cc3:	jg     78c4 <do_last+0x524>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2975

    7cc9:	jne    80f3 <do_last+0xd53>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2978
	error = follow_managed(path, nd->flags);
	if (error < 0)
		goto exit_dput;
    7ccf:	mov    0x38(%rsp),%rax
    7cd4:	testb  $0x1,(%rax)
    7cd7:	jne    826a <do_last+0xeca>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2979 (discriminator 1)

    7cdd:	mov    0x40(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2980 (discriminator 1)
	if (error)
    7ce2:	movzbl 0x37(%rsp),%edi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2979 (discriminator 1)
		goto exit_dput;

	error = follow_managed(path, nd->flags);
	if (error < 0)
		goto exit_dput;

    7ce7:	mov    0x20(%rax),%rax
    7ceb:	movzwl (%rax),%eax
    7cee:	and    $0xf000,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2980 (discriminator 1)
	if (error)
    7cf2:	cmp    $0x8000,%ax
    7cf6:	mov    $0x0,%eax
    7cfb:	cmovne %eax,%edi
    7cfe:	mov    %dil,0x37(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2982
		nd->flags |= LOOKUP_JUMPED;

    7d03:	mov    0x40(%rsp),%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    7d08:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    7d11:	add    $0x4a8,%rdx
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2982
    7d18:	mov    0x18(%rax),%rbx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    7d1c:	mov    $0x0,%rax
    7d23:	jmp    7d30 <do_last+0x990>
    7d25:	nopl   (%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7d28:	test   %cl,%cl
    7d2a:	je     88df <do_last+0x153f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7d30:	add    $0x1,%rdx
    7d34:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7d38:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    7d3c:	cmp    -0x1(%rax),%cl
    7d3f:	je     7d28 <do_last+0x988>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    7d41:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    7d4a:	mov    $0x0,%rax
    7d51:	add    $0x4a8,%rdx
    7d58:	jmp    7d68 <do_last+0x9c8>
    7d5a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7d60:	test   %cl,%cl
    7d62:	je     88df <do_last+0x153f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7d68:	add    $0x1,%rdx
    7d6c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7d70:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    7d74:	cmp    -0x1(%rax),%cl
    7d77:	je     7d60 <do_last+0x9c0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    7d79:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    7d82:	mov    $0x0,%rax
    7d89:	add    $0x4a8,%rdx
    7d90:	jmp    7da0 <do_last+0xa00>
    7d92:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7d98:	test   %cl,%cl
    7d9a:	je     82f7 <do_last+0xf57>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7da0:	add    $0x1,%rdx
    7da4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    7da8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    7dac:	cmp    -0x1(%rax),%cl
    7daf:	je     7d98 <do_last+0x9f8>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    7db1:	mov    %gs:0x0,%rax
    7dba:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    7dc1:	test   %rax,%rax
    7dc4:	je     825f <do_last+0xebf>
    7dca:	mov    (%rax),%ecx
    7dcc:	test   %ecx,%ecx
    7dce:	jne    825f <do_last+0xebf>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:167
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context())) {
		unsigned int flags = 0;
		if (parent)
			flags |= AUDIT_INODE_PARENT;
		__audit_inode(name, dentry, flags);
    7dd4:	mov    0x48(%rsp),%rdi
    7dd9:	xor    %edx,%edx
    7ddb:	mov    %rbx,%rsi
    7dde:	xor    %r15d,%r15d
    7de1:	callq  7de6 <do_last+0xa46>
    7de6:	xor    %r8d,%r8d
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3088
	nd->path = save_parent;
	nd->inode = dir->d_inode;
	save_parent.mnt = NULL;
	save_parent.dentry = NULL;
	if (got_write) {
		mnt_drop_write(nd->path.mnt);
    7de9:	mov    0x40(%rsp),%rdi
    7dee:	mov    %r8,0x50(%rsp)
    7df3:	callq  7df8 <do_last+0xa58>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3089
		got_write = false;
    7df8:	test   %eax,%eax
    7dfa:	mov    0x50(%rsp),%r8
    7dff:	jne    7ecd <do_last+0xb2d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3096
	retried = true;
	goto retry_lookup;
}

static int do_tmpfile(int dfd, struct filename *pathname, struct nameidata *nd, int flags, const struct open_flags *op, struct file *file, int *opened)
{
    7e05:	cmpb   $0x0,0x37(%rsp)
    7e0a:	je     79e3 <do_last+0x643>
handle_truncate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2589
{
	if ((flag & O_ACCMODE) == 3)
		flag--;
	return flag;
}

    7e10:	mov    0x40(%rsp),%rax
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:67
    7e15:	xor    %edx,%edx
handle_truncate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2589
    7e17:	mov    0x18(%rax),%rax
    7e1b:	mov    0x30(%rax),%rbx
    7e1f:	lea    0x138(%rbx),%rcx
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:68
		v1 = atomic_cmpxchg(p, v, v + 1);
    7e26:	lea    0x1(%rdx),%esi
atomic_cmpxchg():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/atomic.h:176
#define atomic_inc_return(v)  (atomic_add_return(1, v))
#define atomic_dec_return(v)  (atomic_sub_return(1, v))

static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
{
	return cmpxchg(&v->counter, old, new);
    7e29:	mov    %edx,%eax
    7e2b:	lock cmpxchg %esi,(%rcx)
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:69
		if (likely(v1 == v))
    7e2f:	cmp    %eax,%edx
    7e31:	jne    884c <do_last+0x14ac>
mandatory_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1940
 * otherwise these will be advisory locks
 */

static inline int mandatory_lock(struct inode *ino)
{
	return IS_MANDLOCK(ino) && __mandatory_lock(ino);
    7e37:	mov    0x28(%rbx),%rax
    7e3b:	testb  $0x40,0x50(%rax)
    7e3f:	je     7e52 <do_last+0xab2>
__mandatory_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1930
 * but no group execute bit -  an otherwise meaningless combination.
 */

static inline int __mandatory_lock(struct inode *ino)
{
	return (ino->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID;
    7e41:	movzwl (%rbx),%eax
    7e44:	and    $0x408,%ax
mandatory_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1940
 * otherwise these will be advisory locks
 */

static inline int mandatory_lock(struct inode *ino)
{
	return IS_MANDLOCK(ino) && __mandatory_lock(ino);
    7e48:	cmp    $0x400,%ax
    7e4c:	je     872f <do_last+0x138f>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    7e52:	mov    %gs:0x0,%rdx
handle_truncate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2599
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_path_mknod(dir, dentry, mode, 0);
  else
    error = 0;
	if (error)
		return error;
    7e5b:	mov    $0x0,%rax
    7e62:	add    $0x4a8,%rdx
    7e69:	jmp    7e6f <do_last+0xacf>
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    7e6b:	test   %cl,%cl
    7e6d:	je     7e9c <do_last+0xafc>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    7e6f:	add    $0x1,%rdx
    7e73:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    7e77:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    7e7b:	cmp    -0x1(%rax),%cl
    7e7e:	je     7e6b <do_last+0xacb>
handle_truncate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2588
static inline int open_to_namei_flags(int flag)
{
	if ((flag & O_ACCMODE) == 3)
		flag--;
	return flag;
}
    7e80:	mov    0x40(%rsp),%rax
    7e85:	mov    %r8,0x50(%rsp)
    7e8a:	lea    0x10(%rax),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2600
    error = security_path_mknod(dir, dentry, mode, 0);
  else
    error = 0;
	if (error)
		return error;

    7e8e:	callq  7e93 <do_last+0xaf3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2604
	error = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);
	if (error)
		return error;

    7e93:	test   %eax,%eax
    7e95:	mov    0x50(%rsp),%r8
    7e9a:	jne    7ebe <do_last+0xb1e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2605
	// return security_inode_create(dir->dentry->d_inode, dentry, mode);
    7e9c:	mov    0x40(%rsp),%rax
    7ea1:	mov    $0x8060,%edx
    7ea6:	xor    %esi,%esi
    7ea8:	mov    %r8,0x50(%rsp)
    7ead:	mov    0x18(%rax),%rdi
    7eb1:	mov    %rax,%rcx
    7eb4:	callq  7eb9 <do_last+0xb19>
    7eb9:	mov    0x50(%rsp),%r8
atomic_dec():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/atomic.h:103
 *
 * Atomically decrements @v by 1.
 */
static inline void atomic_dec(atomic_t *v)
{
	asm volatile(LOCK_PREFIX "decl %0"
    7ebe:	lock decl 0x138(%rbx)
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3098
}

static int do_tmpfile(int dfd, struct filename *pathname, struct nameidata *nd, int flags, const struct open_flags *op, struct file *file, int *opened)
{
	static const struct qstr name = QSTR_INIT("/", 1);
	struct dentry *dentry, *child;
    7ec5:	test   %eax,%eax
    7ec7:	je     79e3 <do_last+0x643>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3112
	/* we want directory to be writable */
	error = inode_permission(nd->inode, MAY_WRITE | MAY_EXEC);
	if (error)
		goto out2;
	dentry = nd->path.dentry;
	dir = dentry->d_inode;
    7ecd:	mov    0x40(%rsp),%rdi
    7ed2:	mov    %eax,0x48(%rsp)
    7ed6:	mov    %r8,0x50(%rsp)
    7edb:	callq  7ee0 <do_last+0xb40>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3113
	if (!dir->i_op->tmpfile) {
    7ee0:	mov    0x50(%rsp),%r8
    7ee5:	mov    0x48(%rsp),%eax
    7ee9:	jmpq   79e3 <do_last+0x643>
follow_dotdot():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1272
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
    7eee:	mov    %r15,%rdi
    7ef1:	callq  7ef6 <do_last+0xb56>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1273
	follow_mount(&nd->path);
    7ef6:	mov    %r15,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1272
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
    7ef9:	mov    %rax,0x8(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1273
	follow_mount(&nd->path);
    7efd:	callq  7f02 <do_last+0xb62>
    7f02:	jmpq   7aac <do_last+0x70c>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2852
			goto out_dput;
	}
out_no_open:
	path->dentry = dentry;
	path->mnt = nd->path.mnt;
	return 1;
    7f07:	test   %r9b,%r9b
    7f0a:	je     7f40 <do_last+0xba0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2853

    7f0c:	test   %rax,%rax
    7f0f:	nop
    7f10:	jne    8872 <do_last+0x14d2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2855
out_dput:
	dput(dentry);
    7f16:	mov    0x18(%rsp),%rdi
    7f1b:	mov    %r15,%rsi
    7f1e:	mov    %r8,0x20(%rsp)
    7f23:	callq  f0 <lookup_real>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2856
	return error;
    7f28:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2855
	path->dentry = dentry;
	path->mnt = nd->path.mnt;
	return 1;

out_dput:
	dput(dentry);
    7f2e:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2856
	return error;
    7f31:	ja     88a7 <do_last+0x1507>
    7f37:	mov    0x30(%rax),%rax
    7f3b:	mov    0x20(%rsp),%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2861
}

/*
 * Handle the last step of open()
 */
    7f40:	test   %rax,%rax
    7f43:	jne    789f <do_last+0x4ff>
    7f49:	testb  $0x40,(%rbx)
    7f4c:	je     789f <do_last+0x4ff>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2863
static int do_last(struct nameidata *nd, struct path *path, struct file *file, const struct open_flags *op, int *opened, struct filename *name)
{
    7f52:	mov    0x30(%r8),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2862
}

/*
 * Handle the last step of open()
 */
static int do_last(struct nameidata *nd, struct path *path, struct file *file, const struct open_flags *op, int *opened, struct filename *name)
    7f56:	movzwl 0x4(%rbx),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2863
{
    7f5a:	mov    0x28(%rax),%rax
    7f5e:	testb  $0x1,0x52(%rax)
    7f62:	jne    7f7f <do_last+0xbdf>
    7f64:	mov    %edx,0x18(%rsp)
    7f68:	mov    %r8,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2864
  MY_PRINTK(get_current()->comm);
    7f6d:	callq  7f72 <do_last+0xbd2>
    7f72:	mov    0x18(%rsp),%edx
    7f76:	mov    0x20(%rsp),%r8
    7f7b:	not    %eax
    7f7d:	and    %eax,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2872
	int open_flag = op->open_flag;
	bool will_truncate = (open_flag & O_TRUNC) != 0;
	bool got_write = false;
	int acc_mode = op->acc_mode;
	struct inode *inode;
	bool symlink_ok = false;
    7f7f:	cmpb   $0x0,0x28(%rsp)
    7f84:	je     85c2 <do_last+0x1222>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2876
	struct path save_parent = { .dentry = NULL, .mnt = NULL };
	bool retried = false;
	int error;

    7f8a:	mov    0x38(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2881
	nd->flags &= ~LOOKUP_PARENT;
	nd->flags |= op->intent;

	if (nd->last_type != LAST_NORM) {
		error = handle_dots(nd, nd->last_type);
    7f8f:	movzwl %dx,%edx
    7f92:	mov    %r15,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2876
	struct inode *inode;
	bool symlink_ok = false;
	struct path save_parent = { .dentry = NULL, .mnt = NULL };
	bool retried = false;
	int error;

    7f95:	orl    $0x1,(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2881
	nd->flags &= ~LOOKUP_PARENT;
	nd->flags |= op->intent;

	if (nd->last_type != LAST_NORM) {
		error = handle_dots(nd, nd->last_type);
    7f98:	mov    0x38(%r14),%ecx
    7f9c:	mov    0x30(%r8),%rdi
    7fa0:	shr    $0xa,%ecx
    7fa3:	and    $0x1,%ecx
    7fa6:	callq  7fab <do_last+0xc0b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2883
		if (error)
			return error;
    7fab:	test   %eax,%eax
    7fad:	je     789f <do_last+0x4ff>
    7fb3:	mov    %eax,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2892
	if (!(open_flag & O_CREAT)) {
		if (nd->last.name[nd->last.len])
			nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
		if (open_flag & O_PATH && !(nd->flags & LOOKUP_FOLLOW))
			symlink_ok = true;
		/* we _can_ be in RCU mode here */
    7fb7:	mov    %r15,%rdi
    7fba:	callq  7fbf <do_last+0xc1f>
    7fbf:	mov    0x20(%rsp),%eax
    7fc3:	jmpq   7c9e <do_last+0x8fe>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3080

stale_open:
	/* If no saved parent or already retried then can't retry */
	if (!save_parent.dentry || retried)
		goto out;

    7fc8:	mov    (%r14),%rax
    7fcb:	mov    0x40(%rsp),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3081
	BUG_ON(save_parent.dentry != dir);
    7fd0:	xor    %edx,%edx
    7fd2:	mov    0x38(%rsp),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3080

stale_open:
	/* If no saved parent or already retried then can't retry */
	if (!save_parent.dentry || retried)
		goto out;

    7fd7:	mov    %rax,0x10(%rdi)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3081
	BUG_ON(save_parent.dentry != dir);
    7fdb:	mov    0x8(%r14),%rsi
    7fdf:	callq  7fe4 <do_last+0xc44>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3082
	path_put(&nd->path);
    7fe4:	test   %eax,%eax
    7fe6:	mov    0x20(%rsp),%r8
    7feb:	je     7de9 <do_last+0xa49>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3083
	nd->path = save_parent;
    7ff1:	cmp    $0xfffffdfa,%eax
    7ff6:	jne    79e3 <do_last+0x643>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3117
	dir = dentry->d_inode;
	if (!dir->i_op->tmpfile) {
		error = -EOPNOTSUPP;
		goto out2;
	}
	child = d_alloc(dentry, &name);
    7ffc:	test   %r8,%r8
    7fff:	je     79e3 <do_last+0x643>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3117 (discriminator 1)
    8005:	cmpb   $0x0,0x35(%rsp)
    800a:	jne    79e3 <do_last+0x643>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3120
	if (unlikely(!child)) {
		error = -ENOMEM;
		goto out2;
    8010:	cmp    %r8,0x50(%rsp)
    8015:	jne    88af <do_last+0x150f>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    801b:	mov    0x8(%r14),%rdi
    801f:	callq  8024 <do_last+0xc84>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    8024:	mov    (%r14),%rdi
    8027:	callq  802c <do_last+0xc8c>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3122
	child = d_alloc(dentry, &name);
	if (unlikely(!child)) {
		error = -ENOMEM;
		goto out2;
	}
	nd->flags &= ~LOOKUP_DIRECTORY;
    802c:	mov    0x50(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3126
	nd->flags |= op->intent;
	dput(nd->path.dentry);
	nd->path.dentry = child;
	error = dir->i_op->tmpfile(dir, nd->path.dentry, op->mode);
    8031:	cmpb   $0x0,0x28(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3122
	child = d_alloc(dentry, &name);
	if (unlikely(!child)) {
		error = -ENOMEM;
		goto out2;
	}
	nd->flags &= ~LOOKUP_DIRECTORY;
    8036:	mov    %r15,(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3130
	nd->path.dentry = child;
	error = dir->i_op->tmpfile(dir, nd->path.dentry, op->mode);
	if (error)
		goto out2;
	audit_inode(pathname, nd->path.dentry, 0);
	error = may_open(&nd->path, op->acc_mode, op->open_flag);
    8039:	movb   $0x1,0x35(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3122
	child = d_alloc(dentry, &name);
	if (unlikely(!child)) {
		error = -ENOMEM;
		goto out2;
	}
	nd->flags &= ~LOOKUP_DIRECTORY;
    803e:	mov    %rax,0x8(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3123
	nd->flags |= op->intent;
    8042:	mov    0x30(%rax),%rax
    8046:	mov    %rax,0x30(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3126
	dput(nd->path.dentry);
	nd->path.dentry = child;
	error = dir->i_op->tmpfile(dir, nd->path.dentry, op->mode);
    804a:	je     7815 <do_last+0x475>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3127
	if (error)
    8050:	mov    %r15,%rdi
    8053:	callq  8058 <do_last+0xcb8>
    8058:	jmpq   7815 <do_last+0x475>
    805d:	nopl   (%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2961
	/*
	 * create/update audit record if it already exists.
	 */
	if (d_is_positive(path->dentry))
		audit_inode(name, path->dentry, 0);

    8060:	mov    (%r14),%rdi
    8063:	callq  8068 <do_last+0xcc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2962
	/*
    8068:	test   %eax,%eax
    806a:	sete   0x28(%rsp)
    806f:	jmpq   7826 <do_last+0x486>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3011
	} else {
		save_parent.dentry = nd->path.dentry;
		save_parent.mnt = mntget(path->mnt);
		nd->path.dentry = path->dentry;

	}
    8074:	mov    $0xffffffef,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3109
	error = mnt_want_write(nd->path.mnt);
	if (unlikely(error))
		goto out;
	/* we want directory to be writable */
	error = inode_permission(nd->inode, MAY_WRITE | MAY_EXEC);
	if (error)
    8079:	mov    %r14,%rsi
    807c:	mov    %r13,%rdi
    807f:	mov    %eax,0x50(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3110
		goto out2;
    8083:	xor    %r15d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3109
	error = mnt_want_write(nd->path.mnt);
	if (unlikely(error))
		goto out;
	/* we want directory to be writable */
	error = inode_permission(nd->inode, MAY_WRITE | MAY_EXEC);
	if (error)
    8086:	callq  d10 <path_put_conditional.isra.13>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3110
		goto out2;
    808b:	xor    %r8d,%r8d
    808e:	mov    0x50(%rsp),%eax
    8092:	jmpq   76e2 <do_last+0x342>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3046
	file->f_path.mnt = nd->path.mnt;
	error = finish_open(file, nd->path.dentry, NULL, opened);
	if (error) {
		if (error == -EOPENSTALE)
			goto stale_open;
		goto out;
    8097:	mov    0x8(%r14),%r8
    809b:	mov    %r8,0x28(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3047
	}
    80a0:	callq  80a5 <do_last+0xd05>
    80a5:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3048
opened:
    80a8:	mov    0x8(%r13),%rax
    80ac:	mov    0x28(%rsp),%r8
    80b1:	mov    %rax,0x8(%r14)
    80b5:	jmpq   752f <do_last+0x18f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2988
	BUG_ON(nd->flags & LOOKUP_RCU);
	inode = path->dentry->d_inode;
finish_lookup:
	/* we _can_ be in RCU mode here */
	error = -ENOENT;
	if (d_is_negative(path->dentry)) {
    80ba:	and    $0xfffffdff,%r12d
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:681
static inline void path_to_nameidata(const struct path *path, struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
    80c1:	testb  $0x40,0x38(%r14)
    80c6:	je     8274 <do_last+0xed4>
    80cc:	mov    0x0(%r13),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:686
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

    80d0:	mov    %rdi,(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
/*
    80d3:	mov    0x8(%r13),%rax
    80d7:	xor    %r15d,%r15d
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2989
	inode = path->dentry->d_inode;
finish_lookup:
	/* we _can_ be in RCU mode here */
	error = -ENOENT;
	if (d_is_negative(path->dentry)) {
		path_to_nameidata(path, nd);
    80da:	movb   $0x0,0x37(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2990
		goto out;
    80df:	movl   $0x20,0x30(%rsp)
    80e7:	xor    %r8d,%r8d
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:687
	}
	nd->path.mnt = path->mnt;
	nd->path.dentry = path->dentry;
}

/*
    80ea:	mov    %rax,0x8(%r14)
    80ee:	jmpq   79c2 <do_last+0x622>
do_last():
    80f3:	xor    %r8d,%r8d
    80f6:	xor    %r15d,%r15d
    80f9:	jmpq   79e3 <do_last+0x643>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3007
	}

	if ((nd->flags & LOOKUP_RCU) || nd->path.mnt != path->mnt) {
		path_to_nameidata(path, nd);
	} else {
		save_parent.dentry = nd->path.dentry;
    80fe:	mov    (%r14),%rdi
    8101:	callq  8106 <do_last+0xd66>
    8106:	jmpq   78ee <do_last+0x54e>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    810b:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    8114:	mov    $0x0,%rax
    811b:	add    $0x4a8,%rdx
    8122:	jmp    8130 <do_last+0xd90>
    8124:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8128:	test   %cl,%cl
    812a:	je     8918 <do_last+0x1578>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8130:	add    $0x1,%rdx
    8134:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8138:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    813c:	cmp    -0x1(%rax),%cl
    813f:	je     8128 <do_last+0xd88>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8141:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    814a:	mov    $0x0,%rax
    8151:	add    $0x4a8,%rdx
    8158:	jmp    8168 <do_last+0xdc8>
    815a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8160:	test   %cl,%cl
    8162:	je     8918 <do_last+0x1578>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8168:	add    $0x1,%rdx
    816c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8170:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    8174:	cmp    -0x1(%rax),%cl
    8177:	je     8160 <do_last+0xdc0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8179:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    8182:	mov    $0x0,%rax
    8189:	add    $0x4a8,%rdx
    8190:	jmp    81a0 <do_last+0xe00>
    8192:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8198:	test   %cl,%cl
    819a:	je     8294 <do_last+0xef4>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    81a0:	add    $0x1,%rdx
    81a4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    81a8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    81ac:	cmp    -0x1(%rax),%cl
    81af:	je     8198 <do_last+0xdf8>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    81b1:	mov    %gs:0x0,%rax
    81ba:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    81c1:	test   %rax,%rax
    81c4:	je     78e3 <do_last+0x543>
    81ca:	mov    (%rax),%edx
    81cc:	test   %edx,%edx
    81ce:	jne    78e3 <do_last+0x543>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:167
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context())) {
		unsigned int flags = 0;
		if (parent)
			flags |= AUDIT_INODE_PARENT;
		__audit_inode(name, dentry, flags);
    81d4:	mov    0x48(%rsp),%rdi
    81d9:	xor    %edx,%edx
    81db:	mov    %r15,%rsi
    81de:	callq  81e3 <do_last+0xe43>
    81e3:	jmpq   78e3 <do_last+0x543>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    81e8:	mov    %gs:0x0,%rdi
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:660
static __always_inline void set_root_rcu(struct nameidata *nd)
{
	if (!nd->root.mnt) {
		struct fs_struct *fs = current->fs;
		unsigned seq;

    81f1:	add    $0x4a8,%rdi
    81f8:	callq  1370 <my_strcmp_base.constprop.35>
    81fd:	test   %eax,%eax
    81ff:	jne    8211 <do_last+0xe71>
    8201:	cmpb   $0x0,0x0(%rip)        # 8208 <do_last+0xe68>
    8208:	mov    0x0(%rip),%rax        # 820f <do_last+0xe6f>
    820f:	jne    821a <do_last+0xe7a>
    8211:	mov    %gs:0x0,%rax
    821a:	mov    0x588(%rax),%rcx
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    8221:	mov    0x8(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    8224:	test   $0x1,%sil
    8228:	jne    867b <do_last+0x12db>
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:665
		do {
			seq = read_seqcount_begin(&fs->seq);
			nd->root = fs->root;
			nd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
		} while (read_seqcount_retry(&fs->seq, seq));
    822e:	mov    0x20(%rcx),%rdx
    8232:	mov    0x18(%rcx),%rax
    8236:	mov    %rdx,0x28(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:666
	}
    823a:	mov    0x28(%r14),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:665

		do {
			seq = read_seqcount_begin(&fs->seq);
			nd->root = fs->root;
			nd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
		} while (read_seqcount_retry(&fs->seq, seq));
    823e:	mov    %rax,0x20(%r14)
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    8242:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    8245:	test   $0x1,%al
    8247:	jne    8909 <do_last+0x1569>
set_root_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:666
	}
    824d:	mov    %eax,0x3c(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:667
}
    8251:	cmp    0x8(%rcx),%esi
    8254:	jne    8221 <do_last+0xe81>
    8256:	mov    0x8(%r14),%rdx
    825a:	jmpq   7767 <do_last+0x3c7>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
	return !p || *(int *)p;
    825f:	xor    %r8d,%r8d
    8262:	xor    %r15d,%r15d
    8265:	jmpq   7de9 <do_last+0xa49>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2980

	error = follow_managed(path, nd->flags);
	if (error < 0)
		goto exit_dput;

	if (error)
    826a:	movb   $0x0,0x37(%rsp)
    826f:	jmpq   7d03 <do_last+0x963>
path_to_nameidata():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:682
{
	if (!(nd->flags & LOOKUP_RCU)) {
		dput(nd->path.dentry);
		if (nd->path.mnt != path->mnt)
			mntput(nd->path.mnt);
	}
    8274:	mov    0x8(%r14),%rdi
    8278:	callq  827d <do_last+0xedd>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:683
	nd->path.mnt = path->mnt;
    827d:	mov    (%r14),%rdi
    8280:	cmp    0x0(%r13),%rdi
    8284:	je     80d0 <do_last+0xd30>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:684
	nd->path.dentry = path->dentry;
    828a:	callq  828f <do_last+0xeef>
    828f:	jmpq   80cc <do_last+0xd2c>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    8294:	cmpb   $0x0,0x0(%rip)        # 829b <do_last+0xefb>
    829b:	mov    0x0(%rip),%rax        # 82a2 <do_last+0xf02>
    82a2:	jne    81ba <do_last+0xe1a>
    82a8:	jmpq   81b1 <do_last+0xe11>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    82ad:	mov    %gs:0x0,%rdi
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652
static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}

    82b6:	add    $0x4a8,%rdi
    82bd:	lea    0x20(%r14),%r15
    82c1:	callq  1370 <my_strcmp_base.constprop.35>
    82c6:	test   %eax,%eax
    82c8:	jne    82da <do_last+0xf3a>
    82ca:	cmpb   $0x0,0x0(%rip)        # 82d1 <do_last+0xf31>
    82d1:	mov    0x0(%rip),%rax        # 82d8 <do_last+0xf38>
    82d8:	jne    82e3 <do_last+0xf43>
    82da:	mov    %gs:0x0,%rax
    82e3:	mov    0x588(%rax),%rdi
    82ea:	mov    %r15,%rsi
    82ed:	callq  16d0 <get_fs_root>
    82f2:	jmpq   7a99 <do_last+0x6f9>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    82f7:	cmpb   $0x0,0x0(%rip)        # 82fe <do_last+0xf5e>
    82fe:	mov    0x0(%rip),%rax        # 8305 <do_last+0xf65>
    8305:	jne    7dba <do_last+0xa1a>
    830b:	jmpq   7db1 <do_last+0xa11>
atomic_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2768
				   S_ISREG(dentry->d_inode->i_mode)) {
				goto out;
			}
			/* will fail later, go on to get the right error */
		}
	}
    8310:	mov    0x38(%rsp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2767
			} else if ((open_flag & O_TRUNC) &&
				   S_ISREG(dentry->d_inode->i_mode)) {
				goto out;
			}
			/* will fail later, go on to get the right error */
		}
    8315:	mov    0x8(%rbx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2768
	}
    8318:	testb  $0x1,(%rax)
    831b:	je     8422 <do_last+0x1082>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2769
looked_up:
    8321:	testb  $0x40,0x18(%rsp)
    8326:	je     87d4 <do_last+0x1434>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    832c:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    8335:	mov    $0x0,%rax
    833c:	add    $0x4a8,%rdx
    8343:	jmp    8350 <do_last+0xfb0>
    8345:	nopl   (%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8348:	test   %cl,%cl
    834a:	je     8779 <do_last+0x13d9>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8350:	add    $0x1,%rdx
    8354:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8358:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    835c:	cmp    -0x1(%rax),%cl
    835f:	je     8348 <do_last+0xfa8>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8361:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    836a:	mov    $0x0,%rax
    8371:	add    $0x4a8,%rdx
    8378:	jmp    8388 <do_last+0xfe8>
    837a:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8380:	test   %cl,%cl
    8382:	je     8779 <do_last+0x13d9>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8388:	add    $0x1,%rdx
    838c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8390:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    8394:	cmp    -0x1(%rax),%cl
    8397:	je     8380 <do_last+0xfe0>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8399:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    83a2:	mov    $0x0,%rax
    83a9:	add    $0x4a8,%rdx
    83b0:	jmp    83c0 <do_last+0x1020>
    83b2:	nopw   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    83b8:	test   %cl,%cl
    83ba:	je     8578 <do_last+0x11d8>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    83c0:	add    $0x1,%rdx
    83c4:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    83c8:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    83cc:	cmp    -0x1(%rax),%cl
    83cf:	je     83b8 <do_last+0x1018>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    83d1:	mov    %gs:0x0,%rax
    83da:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    83e1:	test   %rax,%rax
    83e4:	je     83fe <do_last+0x105e>
    83e6:	mov    (%rax),%edi
    83e8:	test   %edi,%edi
    83ea:	jne    83fe <do_last+0x105e>
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    83ec:	mov    0x10(%rsp),%rdi
    83f1:	mov    $0x4,%edx
    83f6:	mov    %r15,%rsi
    83f9:	callq  83fe <do_last+0x105e>
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:162
    83fe:	mov    0x30(%r15),%rdx
    8402:	mov    0x28(%r15),%r8
    8406:	mov    $0x100,%esi
    840b:	mov    0x10(%rsp),%rdi
    8410:	xor    %r9d,%r9d
    8413:	mov    $0x2,%ecx
    8418:	callq  841d <do_last+0x107d>
atomic_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2771
	path->dentry = dentry;
	path->mnt = nd->path.mnt;
    841d:	mov    $0x20,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2773
	return 1;
}
    8422:	mov    0x40(%rsp),%rax
    8427:	mov    0x18(%rsp),%edx
    842b:	lea    0x10(%rax),%rdi
    842f:	callq  5000 <may_open>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2774

    8434:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2773
	}
looked_up:
	path->dentry = dentry;
	path->mnt = nd->path.mnt;
	return 1;
}
    8436:	mov    %eax,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2774

    843a:	je     7fb7 <do_last+0xc17>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2775
/*
    8440:	mov    0x40(%rsp),%rdi
    8445:	callq  844a <do_last+0x10aa>
    844a:	jmpq   7fb7 <do_last+0xc17>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2732
	}

	/*
	 * We didn't have the inode before the open, so check open permission
	 * here.
	 */
    844f:	cmp    $0xfffffffe,%eax
    8452:	jne    7fb3 <do_last+0xc13>
    8458:	mov    0x20(%rsp),%r10d
    845d:	test   %r10d,%r10d
    8460:	jne    7fb7 <do_last+0xc17>
    8466:	jmpq   7fb3 <do_last+0xc13>
    846b:	nopl   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    8470:	mov    %gs:0x0,%rdx
may_o_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2624
 * Returns 1 if the file was looked up only or didn't need creating.  The
 * caller will need to perform the open themselves.  @path will have been
 * updated to point to the new dentry.  This may be negative.
 *
 * Returns an error code otherwise.
 */
    8479:	mov    $0x0,%rax
    8480:	add    $0x4a8,%rdx
    8487:	jmp    8494 <do_last+0x10f4>
    8489:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8490:	test   %cl,%cl
    8492:	je     84e0 <do_last+0x1140>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8494:	add    $0x1,%rdx
    8498:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    849c:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    84a0:	cmp    -0x1(%rax),%cl
    84a3:	je     8490 <do_last+0x10f0>
may_o_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2625
static int atomic_open(struct nameidata *nd, struct dentry *dentry, struct path *path, struct file *file, const struct open_flags *op, bool got_write, bool need_lookup, int *opened)
    84a5:	movzwl 0xe(%rsp),%edx
    84aa:	xor    %ecx,%ecx
    84ac:	mov    %r15,%rsi
    84af:	mov    %r14,%rdi
    84b2:	mov    %r9d,0x4(%rsp)
    84b7:	callq  84bc <do_last+0x111c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2628
{
	struct inode *dir =  nd->path.dentry->d_inode;
	unsigned open_flag = open_to_namei_flags(op->open_flag);
    84bc:	test   %eax,%eax
    84be:	mov    0x4(%rsp),%r9d
    84c3:	je     84e0 <do_last+0x1140>
atomic_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2718
			fsnotify_create(dir, dentry);
		if (!dentry->d_inode) {
			WARN_ON(*opened & FILE_CREATED);
			if (create_error) {
				error = create_error;
				goto out;
    84c5:	testb  $0x80,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2716
		}
		if (*opened & FILE_CREATED)
			fsnotify_create(dir, dentry);
		if (!dentry->d_inode) {
			WARN_ON(*opened & FILE_CREATED);
			if (create_error) {
    84ca:	mov    %eax,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2718
				error = create_error;
				goto out;
    84ce:	jne    87f2 <do_last+0x1452>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2720
			}
		} else {
    84d4:	andl   $0xffffffbf,0x18(%rsp)
    84d9:	jmpq   7bdf <do_last+0x83f>
    84de:	xchg   %ax,%ax
may_o_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2631
{
	struct inode *dir =  nd->path.dentry->d_inode;
	unsigned open_flag = open_to_namei_flags(op->open_flag);
	umode_t mode;
	int error;
	int acc_mode;
    84e0:	mov    0x8(%r14),%rax
    84e4:	mov    $0x3,%esi
    84e9:	mov    %r9d,0x4(%rsp)
    84ee:	mov    0x30(%rax),%rdi
    84f2:	callq  84f7 <do_last+0x1157>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2632
	int create_error = 0;
    84f7:	test   %eax,%eax
    84f9:	mov    0x4(%rsp),%r9d
    84fe:	jne    84c5 <do_last+0x1125>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8500:	mov    %gs:0x0,%rdx
may_o_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2636
	struct dentry *const DENTRY_NOT_SET = (void *) -1UL;
	bool excl;

	BUG_ON(dentry->d_inode);
    8509:	mov    $0x0,%rax
    8510:	add    $0x4a8,%rdx
    8517:	jmp    8528 <do_last+0x1188>
    8519:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8520:	test   %cl,%cl
    8522:	je     7bdf <do_last+0x83f>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8528:	add    $0x1,%rdx
    852c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8530:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    8534:	cmp    -0x1(%rax),%cl
    8537:	je     8520 <do_last+0x1180>
may_o_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2637

    8539:	mov    0x8(%r14),%rax
    853d:	movzwl 0xe(%rsp),%r8d
    8543:	mov    %r15,%rsi
    8546:	mov    %r9d,(%rsp)
    854a:	mov    0x30(%rax),%rdi
    854e:	mov    %r8d,%edx
    8551:	mov    %r8d,0x4(%rsp)
    8556:	callq  855b <do_last+0x11bb>
atomic_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2716
		}
		if (*opened & FILE_CREATED)
			fsnotify_create(dir, dentry);
		if (!dentry->d_inode) {
			WARN_ON(*opened & FILE_CREATED);
			if (create_error) {
    855b:	test   %eax,%eax
    855d:	mov    0x4(%rsp),%r8d
    8562:	mov    (%rsp),%r9d
    8566:	je     7be5 <do_last+0x845>
    856c:	jmpq   84c5 <do_last+0x1125>
    8571:	nopl   0x0(%rax)
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    8578:	cmpb   $0x0,0x0(%rip)        # 857f <do_last+0x11df>
    857f:	mov    0x0(%rip),%rax        # 8586 <do_last+0x11e6>
    8586:	jne    83da <do_last+0x103a>
    858c:	jmpq   83d1 <do_last+0x1031>
    8591:	nopl   0x0(%rax)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8598:	mov    %gs:0x0,%rdx
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2903
			goto out;

		BUG_ON(nd->inode != dir->d_inode);
	} else {
		/* create side of things */
		/*
    85a1:	mov    $0x0,%rsi
    85a8:	add    $0x4a8,%rdx
    85af:	mov    $0x0,%rdi
    85b6:	xor    %eax,%eax
    85b8:	callq  85bd <do_last+0x121d>
    85bd:	jmpq   7441 <do_last+0xa1>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2873
	bool will_truncate = (open_flag & O_TRUNC) != 0;
	bool got_write = false;
	int acc_mode = op->acc_mode;
	struct inode *inode;
	bool symlink_ok = false;
	struct path save_parent = { .dentry = NULL, .mnt = NULL };
    85c2:	mov    $0xffffffe2,%eax
    85c7:	jmpq   7fb3 <do_last+0xc13>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    85cc:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    85d5:	mov    $0x0,%rax
    85dc:	add    $0x4a8,%rdx
    85e3:	jmp    85e9 <do_last+0x1249>
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    85e5:	test   %cl,%cl
    85e7:	je     8626 <do_last+0x1286>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    85e9:	add    $0x1,%rdx
    85ed:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    85f1:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    85f5:	cmp    -0x1(%rax),%cl
    85f8:	je     85e5 <do_last+0x1245>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    85fa:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    8603:	mov    $0x0,%rax
    860a:	add    $0x4a8,%rdx
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8611:	add    $0x1,%rdx
    8615:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8619:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    861d:	cmp    -0x1(%rax),%cl
    8620:	jne    864b <do_last+0x12ab>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8622:	test   %cl,%cl
    8624:	jne    8611 <do_last+0x1271>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8626:	mov    %gs:0x0,%rdx
audit_inode_child():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
    862f:	mov    $0x0,%rsi
    8636:	add    $0x4a8,%rdx
    863d:	mov    $0x0,%rdi
    8644:	xor    %eax,%eax
    8646:	callq  864b <do_last+0x12ab>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    864b:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    8654:	mov    $0x0,%rax
    865b:	add    $0x4a8,%rdx
    8662:	jmp    8668 <do_last+0x12c8>
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8664:	test   %cl,%cl
    8666:	je     868c <do_last+0x12ec>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8668:	add    $0x1,%rdx
    866c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    8670:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    8674:	cmp    -0x1(%rax),%cl
    8677:	je     8664 <do_last+0x12c4>
    8679:	jmp    869c <do_last+0x12fc>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    867b:	pause  
    867d:	jmpq   8221 <do_last+0xe81>
do_last():
    8682:	movb   $0x0,0x28(%rsp)
    8687:	jmpq   79c2 <do_last+0x622>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    868c:	cmpb   $0x0,0x0(%rip)        # 8693 <do_last+0x12f3>
    8693:	mov    0x0(%rip),%rax        # 869a <do_last+0x12fa>
    869a:	jne    86a5 <do_last+0x1305>
    869c:	mov    %gs:0x0,%rax
    86a5:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    86ac:	test   %rax,%rax
    86af:	je     86cb <do_last+0x132b>
    86b1:	mov    (%rax),%r9d
    86b4:	test   %r9d,%r9d
    86b7:	jne    86cb <do_last+0x132b>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:182
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context()))
		__audit_inode_child(parent, dentry, type);
    86b9:	mov    0x10(%rsp),%rdi
    86be:	mov    $0x4,%edx
    86c3:	mov    %r15,%rsi
    86c6:	callq  86cb <do_last+0x132b>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fsnotify.h:162
    86cb:	mov    0x30(%r15),%rdx
    86cf:	mov    0x28(%r15),%r8
    86d3:	xor    %r9d,%r9d
    86d6:	mov    0x10(%rsp),%rdi
    86db:	mov    $0x2,%ecx
    86e0:	mov    $0x100,%esi
    86e5:	callq  86ea <do_last+0x134a>
    86ea:	jmpq   7c6e <do_last+0x8ce>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    86ef:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    86f8:	mov    $0x0,%rsi
    86ff:	add    $0x4a8,%rdx
    8706:	mov    $0x0,%rdi
    870d:	xor    %eax,%eax
    870f:	mov    %r8,0x20(%rsp)
    8714:	mov    %rcx,0x28(%rsp)
    8719:	callq  871e <do_last+0x137e>
    871e:	mov    0x28(%rsp),%rcx
    8723:	mov    0x20(%rsp),%r8
    8728:	jmpq   7603 <do_last+0x263>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3022 (discriminator 1)
		path_put(&save_parent);
		return error;
	}
	audit_inode(name, nd->path.dentry, 0);
	error = -EISDIR;
	if ((open_flag & O_CREAT) &&
    872d:	ud2    
locks_verify_locked():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1946
}

static inline int locks_verify_locked(struct inode *inode)
{
	if (mandatory_lock(inode))
		return locks_mandatory_locked(inode);
    872f:	mov    %rbx,%rdi
    8732:	mov    %r8,0x50(%rsp)
    8737:	callq  873c <do_last+0x139c>
handle_truncate():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2597
  int error;
	// int error = security_path_mknod(dir, dentry, mode, 0);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_path_mknod(dir, dentry, mode, 0);
  else
    error = 0;
    873c:	test   %eax,%eax
    873e:	mov    0x50(%rsp),%r8
    8743:	jne    7ebe <do_last+0xb1e>
    8749:	jmpq   7e52 <do_last+0xab2>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2756
			return PTR_ERR(dentry);

		if (create_error) {
			int open_flag = op->open_flag;

			error = create_error;
    874e:	movl   $0xffffffef,0x20(%rsp)
    8756:	jmpq   7fb7 <do_last+0xc17>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2738
	acc_mode = op->acc_mode;
	if (*opened & FILE_CREATED) {
		WARN_ON(!(open_flag & O_CREAT));
		fsnotify_create(dir, dentry);
		acc_mode = MAY_OPEN;
	}
    875b:	mov    $0xab2,%esi
    8760:	mov    $0x0,%rdi
    8767:	callq  876c <do_last+0x13cc>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2739
	error = may_open(&file->f_path, acc_mode, open_flag);
    876c:	movl   $0xfffffffb,0x20(%rsp)
    8774:	jmpq   7fb7 <do_last+0xc17>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8779:	mov    %gs:0x0,%rdx
fsnotify_create():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:180
				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
}
static inline void audit_inode_child(const struct inode *parent,
				     const struct dentry *dentry,
				     const unsigned char type) {
  MY_PRINTK(get_current()->comm);
    8782:	mov    $0x0,%rsi
    8789:	add    $0x4a8,%rdx
    8790:	mov    $0x0,%rdi
    8797:	xor    %eax,%eax
    8799:	callq  879e <do_last+0x13fe>
    879e:	jmpq   8399 <do_last+0xff9>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2674
		} else if (open_flag & (O_EXCL | O_TRUNC)) {
			/* Fall back and fail with the right error */
			create_error = -EROFS;
			goto no_open;
		} else {
			/* No side effects, safe to clear O_CREAT */
    87a3:	movl   $0xfffffffe,0x20(%rsp)
    87ab:	jmpq   7fb7 <do_last+0xc17>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2697

	file->f_path.dentry = DENTRY_NOT_SET;
	file->f_path.mnt = nd->path.mnt;
	error = dir->i_op->atomic_open(dir, dentry, file, open_flag, mode,
				      opened);
	if (error < 0) {
    87b0:	test   %ecx,%ecx
    87b2:	je     8842 <do_last+0x14a2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2703
		if (create_error && error == -ENOENT)
			error = create_error;
		goto out;
	}

	if (error) {	/* returned 1, that is */
    87b8:	testl  $0x280,0x18(%rsp)
    87c0:	jne    87ea <do_last+0x144a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2710
			error = -EIO;
			goto out;
		}
		if (file->f_path.dentry) {
			dput(dentry);
			dentry = file->f_path.dentry;
    87c2:	andl   $0xffffffbf,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2709
		if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {
			error = -EIO;
			goto out;
		}
		if (file->f_path.dentry) {
			dput(dentry);
    87c7:	movl   $0xffffffe2,0x20(%rsp)
    87cf:	jmpq   7bdf <do_last+0x83f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2769
				goto out;
			}
			/* will fail later, go on to get the right error */
		}
	}
looked_up:
    87d4:	mov    $0xad1,%esi
    87d9:	mov    $0x0,%rdi
    87e0:	callq  87e5 <do_last+0x1445>
    87e5:	jmpq   832c <do_last+0xf8c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2705
		goto out;
	}

	if (error) {	/* returned 1, that is */
		if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {
			error = -EIO;
    87ea:	movl   $0xffffffe2,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2782
 *
 * Must be called with i_mutex held on parent.
 *
 * Returns 0 if the file was successfully atomically created (if necessary) and
 * opened.  In this case the file will be returned attached to @file.
 *
    87f2:	test   %r9b,%r9b
    87f5:	je     7c8e <do_last+0x8ee>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2783
 * Returns 1 if the file was not completely opened at this time, though lookups
    87fb:	mov    0x38(%r14),%edx
    87ff:	mov    0x10(%rsp),%rdi
    8804:	mov    %r15,%rsi
    8807:	callq  f0 <lookup_real>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2784
 * and creations will have been performed and the dentry returned in @path will
    880c:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2783
 * Must be called with i_mutex held on parent.
 *
 * Returns 0 if the file was successfully atomically created (if necessary) and
 * opened.  In this case the file will be returned attached to @file.
 *
 * Returns 1 if the file was not completely opened at this time, though lookups
    8812:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2784
 * and creations will have been performed and the dentry returned in @path will
    8815:	ja     88a7 <do_last+0x1507>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2787
 * be positive upon return if O_CREAT was specified.  If O_CREAT wasn't
 * specified then a negative dentry may be returned.
 *
    881b:	mov    0x20(%rsp),%esi
    881f:	test   %esi,%esi
    8821:	je     7c8e <do_last+0x8ee>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2788
 * An error code is returned otherwise.
    8827:	mov    (%rbx),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2791
 *
 * FILE_CREATE will be set in @*opened if the dentry was created and will be
 * cleared otherwise prior to returning.
    8829:	test   $0x80,%dl
    882c:	je     89b3 <do_last+0x1613>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2792
 */
    8832:	cmpq   $0x0,0x30(%rax)
    8837:	jne    7c8e <do_last+0x8ee>
    883d:	jmpq   7fb7 <do_last+0xc17>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2666
	if (((open_flag & (O_CREAT | O_TRUNC)) ||
	    (open_flag & O_ACCMODE) != O_RDONLY) && unlikely(!got_write)) {
		if (!(open_flag & O_CREAT)) {
			/*
			 * No O_CREATE -> atomicity not a requirement -> fall
			 * back to lookup + open
    8842:	movl   $0x0,0x20(%rsp)
    884a:	jmp    87f2 <do_last+0x1452>
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:67

#ifndef atomic_inc_unless_negative
static inline int atomic_inc_unless_negative(atomic_t *p)
{
	int v, v1;
	for (v = 0; v >= 0; v = v1) {
    884c:	test   %eax,%eax
    884e:	jns    8869 <do_last+0x14c9>
get_write_access():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:2334
 * use {get,deny}_write_access() - these functions check the sign and refuse
 * to do the change if sign is wrong.
 */
static inline int get_write_access(struct inode *inode)
{
	return atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;
    8850:	mov    $0xffffffe6,%eax
    8855:	jmpq   7ecd <do_last+0xb2d>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    885a:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    885c:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    885f:	test   $0x1,%al
    8861:	je     77ab <do_last+0x40b>
    8867:	jmp    885a <do_last+0x14ba>
atomic_inc_unless_negative():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/atomic.h:67
    8869:	mov    %eax,%edx
    886b:	jmpq   7e26 <do_last+0xa86>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2670
			 */
			goto no_open;
		} else if (open_flag & (O_EXCL | O_TRUNC)) {
			/* Fall back and fail with the right error */
    8870:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2853
	}
out_no_open:
	path->dentry = dentry;
	path->mnt = nd->path.mnt;
	return 1;

    8872:	ud2    
follow_dotdot_rcu():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1187
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
	rcu_read_unlock();
	return -ECHILD;
}

    8874:	mov    0x38(%r14),%eax
    8878:	mov    %eax,%edx
    887a:	and    $0xffffffbf,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1188
/*
    887d:	test   $0x20,%ah
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1187
	if (!(nd->flags & LOOKUP_ROOT))
		nd->root.mnt = NULL;
	rcu_read_unlock();
	return -ECHILD;
}

    8880:	mov    %edx,0x38(%r14)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1188
/*
    8884:	jne    888e <do_last+0x14ee>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1189
 * Follow down to the covering mount currently visible to userspace.  At each
    8886:	movq   $0x0,0x20(%r14)
handle_dots():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1504
}

static void terminate_walk(struct nameidata *nd)
{
	if (!(nd->flags & LOOKUP_RCU)) {
		path_put(&nd->path);
    888e:	mov    $0xfffffff6,%eax
    8893:	jmpq   76b0 <do_last+0x310>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    8898:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    889a:	mov    0x4(%rsi),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    889d:	test   $0x1,%al
    889f:	je     7add <do_last+0x73d>
    88a5:	jmp    8898 <do_last+0x14f8>
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2857
	return 1;

out_dput:
	dput(dentry);
	return error;
}
    88a7:	mov    %r15d,%eax
    88aa:	jmpq   7c9e <do_last+0x8fe>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3120 (discriminator 1)
		goto out2;
	}
	child = d_alloc(dentry, &name);
	if (unlikely(!child)) {
		error = -ENOMEM;
		goto out2;
    88af:	ud2    
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2749
	dput(dentry);
	return error;

no_open:
	if (need_lookup) {
		dentry = lookup_real(dir, dentry, nd->flags);
    88b1:	mov    0x38(%rsp),%rax
    88b6:	testb  $0x1,(%rax)
    88b9:	je     88cc <do_last+0x152c>
    88bb:	mov    $0xabd,%esi
    88c0:	mov    $0x0,%rdi
    88c7:	callq  88cc <do_last+0x152c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2750
		if (IS_ERR(dentry))
    88cc:	mov    0x20(%rsp),%r8d
    88d1:	test   %r8d,%r8d
    88d4:	je     7c8e <do_last+0x8ee>
    88da:	jmpq   7fb7 <do_last+0xc17>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    88df:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    88e8:	mov    $0x0,%rsi
    88ef:	add    $0x4a8,%rdx
    88f6:	mov    $0x0,%rdi
    88fd:	xor    %eax,%eax
    88ff:	callq  8904 <do_last+0x1564>
    8904:	jmpq   7d79 <do_last+0x9d9>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    8909:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    890b:	mov    0x4(%rdx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    890e:	test   $0x1,%al
    8910:	je     824d <do_last+0xead>
    8916:	jmp    8909 <do_last+0x1569>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8918:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    8921:	mov    $0x0,%rsi
    8928:	add    $0x4a8,%rdx
    892f:	mov    $0x0,%rdi
    8936:	xor    %eax,%eax
    8938:	callq  893d <do_last+0x159d>
    893d:	jmpq   8179 <do_last+0xdd9>
rep_nop():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/processor.h:665
    8942:	pause  
__read_seqcount_begin():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:112
static inline unsigned __read_seqcount_begin(const seqcount_t *s)
{
	unsigned ret;

repeat:
	ret = ACCESS_ONCE(s->sequence);
    8944:	mov    0x4(%rcx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/seqlock.h:113
	if (unlikely(ret & 1)) {
    8947:	test   $0x1,%al
    8949:	je     775f <do_last+0x3bf>
    894f:	nop
    8950:	jmp    8942 <do_last+0x15a2>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2936
	mutex_lock(&dir->d_inode->i_mutex);
	error = lookup_open(nd, path, file, op, got_write, opened);
	mutex_unlock(&dir->d_inode->i_mutex);

	if (error <= 0) {
		if (error)
    8952:	js     89e1 <do_last+0x1641>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2939
			goto out;

		if ((*opened & FILE_CREATED) ||
    8958:	mov    0x50(%rsp),%rax
    895d:	mov    0x30(%rax),%rax
    8961:	cmp    %rax,0x30(%r14)
    8965:	jne    89b1 <do_last+0x1611>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2913
		error = complete_walk(nd);
		if (error)
			return error;

		// audit_inode(name, dir, LOOKUP_PARENT);
		msg_audit_inode(name, dir, LOOKUP_PARENT, msqid_from_fs_to_kernel, msqid_from_kernel_to_fs);
    8967:	movb   $0x0,0x35(%rsp)
    896c:	jmpq   7815 <do_last+0x475>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3032
		goto out;
	if (!S_ISREG(nd->inode->i_mode))
		will_truncate = false;

	if (will_truncate) {
		error = mnt_want_write(nd->path.mnt);
    8971:	cmpb   $0x0,0x36(%rsp)
    8976:	jne    74f2 <do_last+0x152>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3033
		if (error)
    897c:	test   %eax,%eax
    897e:	jne    899f <do_last+0x15ff>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3039
			goto out;
		got_write = true;
	}
finish_open_created:
	error = may_open(&nd->path, acc_mode, open_flag);
	if (error)
    8980:	mov    0x60(%rsp),%rax
    8985:	cmp    %rax,0x30(%rsi)
    8989:	jne    89df <do_last+0x163f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3132
	if (error)
		goto out2;
	audit_inode(pathname, nd->path.dentry, 0);
	error = may_open(&nd->path, op->acc_mode, op->open_flag);
	if (error)
		goto out2;
    898b:	add    $0x68,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3040
		got_write = true;
	}
finish_open_created:
	error = may_open(&nd->path, acc_mode, open_flag);
	if (error)
		goto out;
    898f:	mov    $0x1,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3132
	if (error)
		goto out2;
	audit_inode(pathname, nd->path.dentry, 0);
	error = may_open(&nd->path, op->acc_mode, op->open_flag);
	if (error)
		goto out2;
    8994:	pop    %rbx
    8995:	pop    %r12
    8997:	pop    %r13
    8999:	pop    %r14
    899b:	pop    %r15
    899d:	pop    %rbp
    899e:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3034
		will_truncate = false;

	if (will_truncate) {
		error = mnt_want_write(nd->path.mnt);
		if (error)
			goto out;
    899f:	mov    %r14,%rdi
    89a2:	callq  17c0 <unlazy_walk>
    89a7:	test   %eax,%eax
    89a9:	jne    89ec <do_last+0x164c>
    89ab:	mov    0x8(%r13),%rsi
    89af:	jmp    8980 <do_last+0x15e0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2939 (discriminator 1)

	if (error <= 0) {
		if (error)
			goto out;

		if ((*opened & FILE_CREATED) ||
    89b1:	ud2    
lookup_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2794
 *
 * FILE_CREATE will be set in @*opened if the dentry was created and will be
 * cleared otherwise prior to returning.
 */
static int lookup_open(struct nameidata *nd, struct path *path, struct file *file, const struct open_flags *op, bool got_write, int *opened)
{
    89b3:	mov    0x30(%rax),%rax
    89b7:	test   %rax,%rax
    89ba:	je     7fb7 <do_last+0xc17>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2796
	struct dentry *dir = nd->path.dentry;
	struct inode *dir_inode = dir->d_inode;
    89c0:	and    $0x2,%dh
    89c3:	je     7c8e <do_last+0x8ee>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2797
	struct dentry *dentry;
    89c9:	movzwl (%rax),%eax
    89cc:	and    $0xf000,%ax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2796
 * cleared otherwise prior to returning.
 */
static int lookup_open(struct nameidata *nd, struct path *path, struct file *file, const struct open_flags *op, bool got_write, int *opened)
{
	struct dentry *dir = nd->path.dentry;
	struct inode *dir_inode = dir->d_inode;
    89d0:	cmp    $0x8000,%ax
    89d4:	jne    7c8e <do_last+0x8ee>
    89da:	jmpq   7fb7 <do_last+0xc17>
do_last():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3039 (discriminator 1)
			goto out;
		got_write = true;
	}
finish_open_created:
	error = may_open(&nd->path, acc_mode, open_flag);
	if (error)
    89df:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2912
		 */
		error = complete_walk(nd);
		if (error)
			return error;

		// audit_inode(name, dir, LOOKUP_PARENT);
    89e1:	xor    %r8d,%r8d
    89e4:	xor    %r15d,%r15d
    89e7:	jmpq   76e2 <do_last+0x342>
    89ec:	xor    %r8d,%r8d
    89ef:	xor    %r15d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3035

	if (will_truncate) {
		error = mnt_want_write(nd->path.mnt);
		if (error)
			goto out;
		got_write = true;
    89f2:	mov    $0xfffffff6,%eax
    89f7:	jmpq   76e2 <do_last+0x342>
    89fc:	nopl   0x0(%rax)

0000000000008a00 <path_openat>:
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3197
		}
		error = may_follow_link(&link, nd);
		if (unlikely(error))
			break;
		nd->flags |= LOOKUP_PARENT;
		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
    8a00:	callq  8a05 <path_openat+0x5>
    8a05:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3198
		error = follow_link(&link, nd, &cookie);
    8a06:	mov    $0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3197
		}
		error = may_follow_link(&link, nd);
		if (unlikely(error))
			break;
		nd->flags |= LOOKUP_PARENT;
		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
    8a0d:	mov    %rsp,%rbp
    8a10:	push   %r15
    8a12:	mov    %edi,%r15d
    8a15:	push   %r14
    8a17:	mov    %rcx,%r14
    8a1a:	push   %r13
    8a1c:	mov    %rsi,%r13
    8a1f:	push   %r12
    8a21:	push   %rbx
    8a22:	mov    %rdx,%rbx
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8a25:	mov    %gs:0x0,%rdx
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3197
    8a2e:	sub    $0x60,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3198
		error = follow_link(&link, nd, &cookie);
    8a32:	add    $0x4a8,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3197
		}
		error = may_follow_link(&link, nd);
		if (unlikely(error))
			break;
		nd->flags |= LOOKUP_PARENT;
		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
    8a39:	mov    %r8d,0x2c(%rsp)
    8a3e:	jmp    8a48 <path_openat+0x48>
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
    8a40:	test   %cl,%cl
    8a42:	je     8c20 <path_openat+0x220>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8a48:	add    $0x1,%rdx
    8a4c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8a50:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    8a54:	cmp    -0x1(%rax),%cl
    8a57:	je     8a40 <path_openat+0x40>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8a59:	mov    %gs:0x0,%rdx
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3198
		error = follow_link(&link, nd, &cookie);
    8a62:	mov    $0x0,%rax
    8a69:	add    $0x4a8,%rdx
    8a70:	jmp    8a80 <path_openat+0x80>
    8a72:	nopw   0x0(%rax,%rax,1)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8a78:	test   %cl,%cl
    8a7a:	je     8c20 <path_openat+0x220>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8a80:	add    $0x1,%rdx
    8a84:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8a88:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    8a8c:	cmp    -0x1(%rax),%cl
    8a8f:	je     8a78 <path_openat+0x78>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3200
		if (unlikely(error))
			break;
    8a91:	movq   $0x0,0x38(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3203
		error = do_last(nd, &path, file, op, &opened, pathname);
		put_link(nd, &link, cookie);
	}
    8a9a:	movl   $0x0,0x34(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3206
out:
	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT))
		path_put(&nd->root);
    8aa2:	callq  8aa7 <path_openat+0xa7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3207
	if (base)
    8aa7:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3206
		error = do_last(nd, &path, file, op, &opened, pathname);
		put_link(nd, &link, cookie);
	}
out:
	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT))
		path_put(&nd->root);
    8aad:	mov    %rax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3207
	if (base)
    8ab0:	ja     8bc0 <path_openat+0x1c0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3210
		fput(base);
	if (!(opened & FILE_OPENED)) {
		BUG_ON(!error);
    8ab6:	mov    (%r14),%eax
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3143
	if (error) {
		fput(file);
	} else if (!(op->open_flag & O_EXCL)) {
		struct inode *inode = file_inode(file);
		spin_lock(&inode->i_lock);
		inode->i_state |= I_LINKABLE;
    8ab9:	mov    0x2c(%rsp),%edx
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3212
	if (base)
		fput(base);
	if (!(opened & FILE_OPENED)) {
		BUG_ON(!error);
		put_filp(file);
	}
    8abd:	test   $0x400000,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3210
	if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT))
		path_put(&nd->root);
	if (base)
		fput(base);
	if (!(opened & FILE_OPENED)) {
		BUG_ON(!error);
    8ac2:	mov    %eax,0x40(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3212
		put_filp(file);
	}
    8ac7:	jne    8c4c <path_openat+0x24c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3217
	if (unlikely(error)) {
		if (error == -EOPENSTALE) {
			if (flags & LOOKUP_RCU)
				error = -ECHILD;
			else
    8acd:	mov    0x0(%r13),%rsi
    8ad1:	lea    0x38(%rsp),%r8
    8ad6:	or     $0x10,%edx
    8ad9:	mov    %r15d,%edi
    8adc:	mov    %rbx,%rcx
    8adf:	callq  25f0 <path_init>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3218
				error = -ESTALE;
    8ae4:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3217
	}
	if (unlikely(error)) {
		if (error == -EOPENSTALE) {
			if (flags & LOOKUP_RCU)
				error = -ECHILD;
			else
    8ae6:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3218
				error = -ESTALE;
    8ae9:	jne    8b75 <path_openat+0x175>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8aef:	mov    %gs:0x0,%rdx
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3221
		}
		file = ERR_PTR(error);
	}
    8af8:	mov    $0x0,%rax
    8aff:	add    $0x4a8,%rdx
    8b06:	jmp    8b18 <path_openat+0x118>
    8b08:	nopl   0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8b10:	test   %cl,%cl
    8b12:	je     8be0 <path_openat+0x1e0>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8b18:	add    $0x1,%rdx
    8b1c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    8b20:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    8b24:	cmp    -0x1(%rax),%cl
    8b27:	je     8b10 <path_openat+0x110>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3221
    8b29:	mov    %gs:0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3221 (discriminator 3)
    8b32:	movl   $0x0,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3222 (discriminator 3)
	return file;
    8b3c:	mov    0x0(%r13),%rdi
    8b40:	mov    %rbx,%rsi
    8b43:	callq  2e30 <link_path_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3223 (discriminator 3)
}
    8b48:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3222 (discriminator 3)
			else
				error = -ESTALE;
		}
		file = ERR_PTR(error);
	}
	return file;
    8b4a:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3223 (discriminator 3)
}
    8b4d:	jne    8b75 <path_openat+0x175>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3226

struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)
{
    8b4f:	lea    0x34(%rsp),%r8
    8b54:	lea    0x40(%rsp),%rsi
    8b59:	mov    %r13,%r9
    8b5c:	mov    %r14,%rcx
    8b5f:	mov    %r12,%rdx
    8b62:	mov    %rbx,%rdi
    8b65:	callq  73a0 <do_last>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3227
  MY_PRINTK(get_current()->comm);
    8b6a:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3226
	}
	return file;
}

struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)
{
    8b6c:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3227
  MY_PRINTK(get_current()->comm);
    8b6f:	jg     8d44 <path_openat+0x344>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3248
	struct nameidata nd;
	struct file *file;
	struct filename filename = { .name = name };
	int flags = op->lookup_flags | LOOKUP_ROOT;

	nd.root.mnt = mnt;
    8b75:	cmpq   $0x0,0x20(%rbx)
    8b7a:	je     8b82 <path_openat+0x182>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3248 (discriminator 1)
    8b7c:	testb  $0x20,0x39(%rbx)
    8b80:	je     8c00 <path_openat+0x200>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3250
	nd.root.dentry = dentry;

    8b82:	mov    0x38(%rsp),%rdi
    8b87:	test   %rdi,%rdi
    8b8a:	je     8b91 <path_openat+0x191>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3251
	if (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)
    8b8c:	callq  8b91 <path_openat+0x191>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3252
		return ERR_PTR(-ELOOP);
    8b91:	testb  $0x2,0x34(%rsp)
    8b96:	jne    8bd8 <path_openat+0x1d8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3253

    8b98:	test   %r15d,%r15d
    8b9b:	je     8c4a <path_openat+0x24a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3254
	file = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);
    8ba1:	mov    %r12,%rdi
    8ba4:	callq  8ba9 <path_openat+0x1a9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3257
	if (unlikely(file == ERR_PTR(-ECHILD)))
		file = path_openat(-1, &filename, &nd, op, flags);
	if (unlikely(file == ERR_PTR(-ESTALE)))
    8ba9:	cmp    $0xfffffdfa,%r15d
    8bb0:	movslq %r15d,%r12
    8bb3:	je     8d2a <path_openat+0x32a>
    8bb9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3266

struct dentry *kern_path_create(int dfd, const char *pathname, struct path *path, unsigned int lookup_flags)
{
	struct dentry *dentry = ERR_PTR(-EEXIST);
	struct nameidata nd;
	int err2;
    8bc0:	add    $0x60,%rsp
    8bc4:	mov    %r12,%rax
    8bc7:	pop    %rbx
    8bc8:	pop    %r12
    8bca:	pop    %r13
    8bcc:	pop    %r14
    8bce:	pop    %r15
    8bd0:	pop    %rbp
    8bd1:	retq   
    8bd2:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3256
	if (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)
		return ERR_PTR(-ELOOP);

	file = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);
	if (unlikely(file == ERR_PTR(-ECHILD)))
		file = path_openat(-1, &filename, &nd, op, flags);
    8bd8:	test   %r15d,%r15d
    8bdb:	je     8bc0 <path_openat+0x1c0>
    8bdd:	jmp    8ba9 <path_openat+0x1a9>
    8bdf:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3221
				error = -ECHILD;
			else
				error = -ESTALE;
		}
		file = ERR_PTR(error);
	}
    8be0:	cmpb   $0x0,0x0(%rip)        # 8be7 <path_openat+0x1e7>
    8be7:	mov    0x0(%rip),%rax        # 8bee <path_openat+0x1ee>
    8bee:	jne    8b32 <path_openat+0x132>
    8bf4:	jmpq   8b29 <path_openat+0x129>
    8bf9:	nopl   0x0(%rax)
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    8c00:	mov    0x28(%rbx),%rdi
    8c04:	callq  8c09 <path_openat+0x209>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    8c09:	mov    0x20(%rbx),%rdi
    8c0d:	callq  8c12 <path_openat+0x212>
    8c12:	jmpq   8b82 <path_openat+0x182>
    8c17:	nopw   0x0(%rax,%rax,1)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    8c20:	mov    %gs:0x0,%rdx
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3198
		error = may_follow_link(&link, nd);
		if (unlikely(error))
			break;
		nd->flags |= LOOKUP_PARENT;
		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
		error = follow_link(&link, nd, &cookie);
    8c29:	mov    $0x0,%rsi
    8c30:	add    $0x4a8,%rdx
    8c37:	mov    $0x0,%rdi
    8c3e:	xor    %eax,%eax
    8c40:	callq  8c45 <path_openat+0x245>
    8c45:	jmpq   8a91 <path_openat+0x91>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3253 (discriminator 1)
	nd.root.mnt = mnt;
	nd.root.dentry = dentry;

	if (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)
		return ERR_PTR(-ELOOP);

    8c4a:	ud2    
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3142
	error = open_check_o_direct(file);
	if (error) {
		fput(file);
	} else if (!(op->open_flag & O_EXCL)) {
		struct inode *inode = file_inode(file);
		spin_lock(&inode->i_lock);
    8c4c:	mov    0x0(%r13),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3143
		inode->i_state |= I_LINKABLE;
    8c50:	or     $0x2,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3142
	error = open_check_o_direct(file);
	if (error) {
		fput(file);
	} else if (!(op->open_flag & O_EXCL)) {
		struct inode *inode = file_inode(file);
		spin_lock(&inode->i_lock);
    8c53:	mov    %r15d,%edi
    8c56:	mov    %rbx,%rcx
    8c59:	callq  38c0 <path_lookupat>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3144
		inode->i_state |= I_LINKABLE;
		spin_unlock(&inode->i_lock);
    8c5e:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3142
	error = open_check_o_direct(file);
	if (error) {
		fput(file);
	} else if (!(op->open_flag & O_EXCL)) {
		struct inode *inode = file_inode(file);
		spin_lock(&inode->i_lock);
    8c60:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3144
		inode->i_state |= I_LINKABLE;
		spin_unlock(&inode->i_lock);
    8c63:	jne    8b75 <path_openat+0x175>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3146
	}
out2:
    8c69:	mov    (%rbx),%rdi
    8c6c:	callq  8c71 <path_openat+0x271>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3147
	mnt_drop_write(nd->path.mnt);
    8c71:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3146
		struct inode *inode = file_inode(file);
		spin_lock(&inode->i_lock);
		inode->i_state |= I_LINKABLE;
		spin_unlock(&inode->i_lock);
	}
out2:
    8c73:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3147
	mnt_drop_write(nd->path.mnt);
    8c76:	jne    8d14 <path_openat+0x314>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3150
out:
	path_put(&nd->path);
	return error;
    8c7c:	mov    0x30(%rbx),%rdi
    8c80:	mov    $0x3,%esi
    8c85:	callq  8c8a <path_openat+0x28a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3151
}
    8c8a:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3150
	}
out2:
	mnt_drop_write(nd->path.mnt);
out:
	path_put(&nd->path);
	return error;
    8c8c:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3151
}
    8c8f:	jne    8d0c <path_openat+0x30c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3153

static struct file *path_openat(int dfd, struct filename *pathname, struct nameidata *nd, const struct open_flags *op, int flags)
    8c91:	mov    0x8(%rbx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3156
{
  MY_PRINTK(get_current()->comm);

    8c95:	mov    $0xffffffa1,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3154
	path_put(&nd->path);
	return error;
}

static struct file *path_openat(int dfd, struct filename *pathname, struct nameidata *nd, const struct open_flags *op, int flags)
{
    8c9b:	mov    0x30(%rdi),%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3155
  MY_PRINTK(get_current()->comm);
    8c9f:	mov    0x20(%r8),%rdx
    8ca3:	mov    %r8,0x20(%rsp)
    8ca8:	cmpq   $0x0,0xb8(%rdx)
    8cb0:	je     8d0c <path_openat+0x30c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3159

	struct file *base = NULL;
	struct file *file;
	struct path path;
    8cb2:	mov    $0x0,%rsi
    8cb9:	callq  8cbe <path_openat+0x2be>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3160
	int opened = 0;
    8cbe:	test   %rax,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3159
{
  MY_PRINTK(get_current()->comm);

	struct file *base = NULL;
	struct file *file;
	struct path path;
    8cc1:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3160
	int opened = 0;
    8cc4:	je     8f26 <path_openat+0x526>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3164
	int error;

	file = get_empty_filp();
	if (IS_ERR(file))
    8cca:	mov    0x38(%rbx),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3166
		return file;

    8ccd:	mov    0x8(%rbx),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3164
	struct path path;
	int opened = 0;
	int error;

	file = get_empty_filp();
	if (IS_ERR(file))
    8cd1:	and    $0xfffffffd,%edx
    8cd4:	mov    %edx,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3165
		return file;
    8cd7:	or     0xc(%r14),%edx
    8cdb:	mov    %edx,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3166

    8cde:	callq  8ce3 <path_openat+0x2e3>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3168
	file->f_flags = op->open_flag;

    8ce3:	mov    0x20(%rsp),%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3167

	file = get_empty_filp();
	if (IS_ERR(file))
		return file;

	file->f_flags = op->open_flag;
    8ce8:	mov    %r15,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3168

    8cec:	mov    %r15,%rsi
    8cef:	movzwl 0x4(%r14),%edx
    8cf4:	mov    0x20(%r8),%rcx
    8cf8:	mov    %r8,%rdi
    8cfb:	callq  *0xb8(%rcx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3169
	if (unlikely(file->f_flags & __O_TMPFILE)) {
    8d01:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3168
	file = get_empty_filp();
	if (IS_ERR(file))
		return file;

	file->f_flags = op->open_flag;

    8d03:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3169
	if (unlikely(file->f_flags & __O_TMPFILE)) {
    8d06:	je     8de0 <path_openat+0x3e0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3189
	while (unlikely(error > 0)) { /* trailing symlink */
		struct path link = path;
		void *cookie;
		if (!(nd->flags & LOOKUP_FOLLOW)) {
			path_put_conditional(&path, nd);
			path_put(&nd->path);
    8d0c:	mov    (%rbx),%rdi
    8d0f:	callq  8d14 <path_openat+0x314>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    8d14:	mov    0x8(%rbx),%rdi
    8d18:	callq  8d1d <path_openat+0x31d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    8d1d:	mov    (%rbx),%rdi
    8d20:	callq  8d25 <path_openat+0x325>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3214
	if (!(opened & FILE_OPENED)) {
		BUG_ON(!error);
		put_filp(file);
	}
	if (unlikely(error)) {
		if (error == -EOPENSTALE) {
    8d25:	jmpq   8b75 <path_openat+0x175>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3258

	file = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);
	if (unlikely(file == ERR_PTR(-ECHILD)))
		file = path_openat(-1, &filename, &nd, op, flags);
	if (unlikely(file == ERR_PTR(-ESTALE)))
		file = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);
    8d2a:	mov    0x2c(%rsp),%eax
    8d2e:	and    $0x40,%eax
    8d31:	cmp    $0x1,%eax
    8d34:	sbb    %r12,%r12
    8d37:	and    $0xffffffffffffff96,%r12
    8d3b:	sub    $0xa,%r12
    8d3f:	jmpq   8bc0 <path_openat+0x1c0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3228
}

struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)
{
  MY_PRINTK(get_current()->comm);

    8d44:	mov    0x40(%rsp),%rax
    8d49:	mov    0x48(%rsp),%rdx
    8d4e:	mov    %rax,0x50(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3230
	struct nameidata nd;
	int flags = op->lookup_flags;
    8d53:	mov    0x38(%rbx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3228
}

struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)
{
  MY_PRINTK(get_current()->comm);

    8d56:	mov    %rdx,0x58(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3230
	struct nameidata nd;
	int flags = op->lookup_flags;
    8d5b:	test   $0x1,%al
    8d5d:	je     9231 <path_openat+0x831>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8d63:	mov    %gs:0x0,%rdx
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    8d6c:	lea    0x4a8(%rdx),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

	touch_atime(link);
	nd_set_link(nd, NULL);

    8d73:	mov    %r12,0x20(%rsp)
    8d78:	mov    %r13,0x8(%rsp)
    8d7d:	mov    %r14,(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
	current->total_link_count++;
    8d81:	mov    %rsi,0x18(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

	touch_atime(link);
	nd_set_link(nd, NULL);

    8d86:	mov    %rsi,0x10(%rsp)
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:735
	const struct inode *parent;

	if (!sysctl_protected_symlinks)
		return 0;

	/* Allowed if owner and follower match. */
    8d8b:	mov    0x0(%rip),%edx        # 8d91 <path_openat+0x391>
    8d91:	mov    0x58(%rsp),%r12
    8d96:	test   %edx,%edx
    8d98:	je     8fa9 <path_openat+0x5a9>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8d9e:	mov    %gs:0x0,%rcx
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:739
	inode = link->dentry->d_inode;
	if (uid_eq(current_cred()->fsuid, inode->i_uid))
		return 0;

    8da7:	mov    0x30(%r12),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
	/* Allowed if parent directory not sticky and world-writable. */
    8dac:	add    $0x4a8,%rcx
    8db3:	mov    $0x0,%rdx
    8dba:	jmp    8dc9 <path_openat+0x3c9>
    8dbc:	nopl   0x0(%rax)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8dc0:	test   %sil,%sil
    8dc3:	je     8f66 <path_openat+0x566>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8dc9:	add    $0x1,%rcx
    8dcd:	movzbl -0x1(%rcx),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    8dd1:	add    $0x1,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    8dd5:	cmp    -0x1(%rdx),%sil
    8dd9:	je     8dc0 <path_openat+0x3c0>
    8ddb:	jmpq   8f76 <path_openat+0x576>
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3171

	file->f_flags = op->open_flag;

	if (unlikely(file->f_flags & __O_TMPFILE)) {
		error = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);
		goto out;
    8de0:	mov    0x8(%rbx),%r15
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    8de4:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    8deb:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    8df4:	add    $0x4a8,%rdx
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8dfb:	add    $0x1,%rdx
    8dff:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8e03:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    8e07:	cmp    -0x1(%rax),%cl
    8e0a:	jne    8f31 <path_openat+0x531>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8e10:	test   %cl,%cl
    8e12:	jne    8dfb <path_openat+0x3fb>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8e14:	mov    %gs:0x0,%rdx
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
    8e1d:	mov    $0x0,%rsi
    8e24:	add    $0x4a8,%rdx
    8e2b:	mov    $0x0,%rdi
    8e32:	xor    %eax,%eax
    8e34:	callq  8e39 <path_openat+0x439>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    8e39:	mov    %gs:0x0,%rdx
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
extern void __audit_seccomp(unsigned long syscall, long signr, int code);
extern void __audit_ptrace(struct task_struct *t);

static inline int audit_dummy_context(void)
{
	void *p = current->audit_context;
    8e42:	mov    $0x0,%rax
    8e49:	add    $0x4a8,%rdx
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8e50:	add    $0x1,%rdx
    8e54:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    8e58:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    8e5c:	cmp    -0x1(%rax),%cl
    8e5f:	jne    8e75 <path_openat+0x475>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8e61:	test   %cl,%cl
    8e63:	jne    8e50 <path_openat+0x450>
audit_dummy_context():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:122
    8e65:	cmpb   $0x0,0x0(%rip)        # 8e6c <path_openat+0x46c>
    8e6c:	mov    0x0(%rip),%rax        # 8e73 <path_openat+0x473>
    8e73:	jne    8e7e <path_openat+0x47e>
    8e75:	mov    %gs:0x0,%rax
    8e7e:	mov    0x610(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:123
	return !p || *(int *)p;
    8e85:	test   %rax,%rax
    8e88:	je     8e9d <path_openat+0x49d>
    8e8a:	mov    (%rax),%ecx
    8e8c:	test   %ecx,%ecx
    8e8e:	jne    8e9d <path_openat+0x49d>
audit_inode():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:167
  MY_PRINTK(get_current()->comm);
	if (unlikely(!audit_dummy_context())) {
		unsigned int flags = 0;
		if (parent)
			flags |= AUDIT_INODE_PARENT;
		__audit_inode(name, dentry, flags);
    8e90:	xor    %edx,%edx
    8e92:	mov    %r15,%rsi
    8e95:	mov    %r13,%rdi
    8e98:	callq  8e9d <path_openat+0x49d>
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3172
	}
    8e9d:	mov    0x8(%r14),%esi
    8ea1:	mov    (%r14),%edx
    8ea4:	mov    %rbx,%rdi
    8ea7:	callq  5000 <may_open>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3173

    8eac:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3172
	file->f_flags = op->open_flag;

	if (unlikely(file->f_flags & __O_TMPFILE)) {
		error = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);
		goto out;
	}
    8eae:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3173

    8eb1:	jne    8d0c <path_openat+0x30c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3175
	error = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);
	if (unlikely(error))
    8eb7:	mov    (%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3176
		goto out;
    8eba:	lea    0x34(%rsp),%rcx
    8ebf:	xor    %edx,%edx
    8ec1:	mov    %r12,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3175
		error = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);
		goto out;
	}

	error = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);
	if (unlikely(error))
    8ec4:	mov    %rax,0x10(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3176
		goto out;
    8ec9:	mov    0x8(%rbx),%rsi
    8ecd:	callq  8ed2 <path_openat+0x4d2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3177

    8ed2:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3176
		goto out;
	}

	error = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);
	if (unlikely(error))
		goto out;
    8ed4:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3177

    8ed7:	jne    8d0c <path_openat+0x30c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3179
	current->total_link_count = 0;
	error = link_path_walk(pathname->name, nd);
    8edd:	mov    %r12,%rdi
    8ee0:	callq  8ee5 <path_openat+0x4e5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3180
	if (unlikely(error))
    8ee5:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3179
	error = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);
	if (unlikely(error))
		goto out;

	current->total_link_count = 0;
	error = link_path_walk(pathname->name, nd);
    8ee7:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3180
	if (unlikely(error))
    8eea:	jne    92a4 <path_openat+0x8a4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3182
		goto out;

    8ef0:	testb  $0x80,(%r14)
    8ef4:	jne    8d0c <path_openat+0x30c>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3137
		goto out2;
	file->f_path.mnt = nd->path.mnt;
	error = finish_open(file, nd->path.dentry, NULL, opened);
	if (error)
		goto out2;
	error = open_check_o_direct(file);
    8efa:	mov    0x20(%r12),%r13
spin_lock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:293
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    8eff:	lea    0x88(%r13),%r14
    8f06:	mov    %r14,%rdi
    8f09:	callq  8f0e <path_openat+0x50e>
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3185
	if (unlikely(error))
		goto out;

	error = do_last(nd, &path, file, op, &opened, pathname);
	while (unlikely(error > 0)) { /* trailing symlink */
		struct path link = path;
    8f0e:	orq    $0x400,0xa0(%r13)
spin_unlock():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/spinlock.h:333
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    8f19:	mov    %r14,%rdi
    8f1c:	callq  8f21 <path_openat+0x521>
    8f21:	jmpq   8d0c <path_openat+0x30c>
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3161

	struct file *base = NULL;
	struct file *file;
	struct path path;
	int opened = 0;
	int error;
    8f26:	mov    $0xfffffff4,%r15d
    8f2c:	jmpq   8d0c <path_openat+0x30c>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    8f31:	mov    %gs:0x0,%rdx
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/audit.h:162
		__audit_getname(name);
}
static inline void audit_inode(struct filename *name,
				const struct dentry *dentry,
				unsigned int parent) {
  MY_PRINTK(get_current()->comm);
    8f3a:	mov    $0x0,%rax
    8f41:	add    $0x4a8,%rdx
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    8f48:	add    $0x1,%rdx
    8f4c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    8f50:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    8f54:	cmp    -0x1(%rax),%cl
    8f57:	jne    8e39 <path_openat+0x439>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    8f5d:	test   %cl,%cl
    8f5f:	jne    8f48 <path_openat+0x548>
    8f61:	jmpq   8e14 <path_openat+0x414>
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:740
	/* Allowed if owner and follower match. */
	inode = link->dentry->d_inode;
	if (uid_eq(current_cred()->fsuid, inode->i_uid))
		return 0;

	/* Allowed if parent directory not sticky and world-writable. */
    8f66:	cmpb   $0x0,0x0(%rip)        # 8f6d <path_openat+0x56d>
    8f6d:	mov    0x0(%rip),%rdx        # 8f74 <path_openat+0x574>
    8f74:	jne    8f7f <path_openat+0x57f>
    8f76:	mov    %gs:0x0,%rdx
    8f7f:	mov    0x4a0(%rdx),%rdx
    8f86:	mov    0x4(%rdi),%esi
    8f89:	cmp    %esi,0x1c(%rdx)
    8f8c:	je     8fa9 <path_openat+0x5a9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:744
	parent = nd->path.dentry->d_inode;
	if ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
		return 0;

    8f8e:	mov    0x8(%rbx),%rdx
    8f92:	mov    0x30(%rdx),%rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:745
	/* Allowed if parent directory and link owner match. */
    8f96:	movzwl (%rcx),%edx
    8f99:	and    $0x202,%dx
    8f9e:	cmp    $0x202,%dx
    8fa3:	je     925a <path_openat+0x85a>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3240
		filp = path_openat(dfd, pathname, &nd, op, flags);
	if (unlikely(filp == ERR_PTR(-ESTALE)))
		filp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);
	return filp;
}

    8fa9:	mov    %eax,%edx
    8fab:	and    $0xf8,%dh
    8fae:	or     $0x10,%edx
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    8fb1:	test   $0x40,%al
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3240
		filp = path_openat(dfd, pathname, &nd, op, flags);
	if (unlikely(filp == ERR_PTR(-ESTALE)))
		filp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);
	return filp;
}

    8fb3:	mov    %edx,0x38(%rbx)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    8fb6:	jne    92a2 <path_openat+0x8a2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:836
	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
    8fbc:	mov    0x50(%rsp),%rdi
    8fc1:	cmp    (%rbx),%rdi
    8fc4:	jne    8fcb <path_openat+0x5cb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:837
		goto out_put_nd_path;
    8fc6:	callq  8fcb <path_openat+0x5cb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:840

	cond_resched();
	current->total_link_count++;
    8fcb:	mov    0x18(%rsp),%rdi
    8fd0:	callq  1370 <my_strcmp_base.constprop.35>
    8fd5:	test   %eax,%eax
    8fd7:	jne    8fe9 <path_openat+0x5e9>
    8fd9:	cmpb   $0x0,0x0(%rip)        # 8fe0 <path_openat+0x5e0>
    8fe0:	mov    0x0(%rip),%rax        # 8fe7 <path_openat+0x5e7>
    8fe7:	jne    8ff2 <path_openat+0x5f2>
    8fe9:	mov    %gs:0x0,%rax
    8ff2:	cmpl   $0x27,0x4bc(%rax)
    8ff9:	jg     91fd <path_openat+0x7fd>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:843

	touch_atime(link);
	nd_set_link(nd, NULL);
    8fff:	callq  9004 <path_openat+0x604>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:844

    9004:	mov    0x10(%rsp),%rdi
    9009:	callq  1370 <my_strcmp_base.constprop.35>
    900e:	test   %eax,%eax
    9010:	jne    9022 <path_openat+0x622>
    9012:	cmpb   $0x0,0x0(%rip)        # 9019 <path_openat+0x619>
    9019:	mov    0x0(%rip),%rax        # 9020 <path_openat+0x620>
    9020:	jne    902b <path_openat+0x62b>
    9022:	mov    %gs:0x0,%rax
    902b:	addl   $0x1,0x4bc(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:846
	// error = security_inode_follow_link(link->dentry, nd);
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    9032:	lea    0x50(%rsp),%r14
    9037:	mov    %r14,%rdi
    903a:	callq  903f <path_openat+0x63f>
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88

extern void nd_jump_link(struct nameidata *nd, struct path *path);

static inline void nd_set_link(struct nameidata *nd, char *path)
{
	nd->saved_names[nd->depth] = path;
    903f:	mov    0x48(%rbx),%eax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    9042:	mov    %gs:0x0,%rdi
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
    904b:	add    $0x4a8,%rdi
nd_set_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:88
    9052:	movq   $0x0,0x50(%rbx,%rax,8)
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:850
    905b:	callq  1330 <my_strcmp.constprop.33>
    9060:	test   %eax,%eax
    9062:	jne    9146 <path_openat+0x746>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:857

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;
    9068:	movl   $0x4,0x44(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858

    906f:	mov    0x30(%r12),%rax
    9074:	mov    %rbx,%rsi
    9077:	mov    %r12,%rdi
    907a:	mov    0x20(%rax),%rax
    907e:	callq  *0x8(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	error = 0;
	s = nd_get_link(nd);
    9081:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:858
	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(*p);
	if (IS_ERR(*p))
		goto out_put_nd_path;

    9087:	mov    %rax,%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:859
	error = 0;
    908a:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:860
	s = nd_get_link(nd);
    908d:	jbe    90eb <path_openat+0x6eb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}

    908f:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:887
out_put_nd_path:
	*p = NULL;
	path_put(&nd->path);
	path_put(link);
	return error;
}
    9092:	xor    %r13d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:888

    9095:	callq  909a <path_openat+0x69a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:889
static int follow_up_rcu(struct path *path)
    909a:	mov    %r14,%rdi
    909d:	callq  90a2 <path_openat+0x6a2>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3242
		filp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);
	return filp;
}

struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt, const char *name, const struct open_flags *op)
{
    90a2:	test   %r15d,%r15d
    90a5:	jne    90e1 <path_openat+0x6e1>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3244
	struct nameidata nd;
	struct file *file;
    90a7:	mov    0x8(%rsp),%r9
    90ac:	mov    (%rsp),%rcx
    90b0:	lea    0x34(%rsp),%r8
    90b5:	mov    0x20(%rsp),%rdx
    90ba:	lea    0x40(%rsp),%rsi
    90bf:	mov    %rbx,%rdi
    90c2:	callq  73a0 <do_last>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3245
	struct filename filename = { .name = name };
    90c7:	mov    %r13,%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3244
}

struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt, const char *name, const struct open_flags *op)
{
	struct nameidata nd;
	struct file *file;
    90ca:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3245
	struct filename filename = { .name = name };
    90cd:	mov    %r14,%rsi
    90d0:	mov    %rbx,%rdi
    90d3:	callq  220 <put_link>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3227
	return file;
}

struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)
{
  MY_PRINTK(get_current()->comm);
    90d8:	test   %r15d,%r15d
    90db:	jg     920d <path_openat+0x80d>
    90e1:	mov    0x20(%rsp),%r12
    90e6:	jmpq   8b75 <path_openat+0x175>
nd_get_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:93
}

static inline char *nd_get_link(struct nameidata *nd)
{
	return nd->saved_names[nd->depth];
    90eb:	mov    0x48(%rbx),%eax
    90ee:	mov    0x50(%rbx,%rax,8),%r12
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:865
	s = nd_get_link(nd);
	if (s) {
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
    90f3:	test   %r12,%r12
    90f6:	je     90a7 <path_openat+0x6a7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:866
		}
    90f8:	cmp    $0xfffffffffffff000,%r12
    90ff:	ja     9199 <path_openat+0x799>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:871
		if (*s == '/') {
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
    9105:	cmpb   $0x2f,(%r12)
    910a:	je     9163 <path_openat+0x763>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    910c:	mov    0x8(%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    9110:	mov    %rbx,%rsi
    9113:	mov    %r12,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:878
		}
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}
    9116:	mov    0x30(%rax),%rax
    911a:	mov    %rax,0x30(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879

    911e:	callq  2e30 <link_path_walk>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    9123:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:879
		nd->inode = nd->path.dentry->d_inode;
		error = link_path_walk(s, nd);
		if (unlikely(error))
			put_link(nd, link, *p);
	}

    9125:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:880
	return error;
    9128:	je     90a7 <path_openat+0x6a7>
    912e:	mov    %r13,%rdx
    9131:	mov    %r14,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:881

    9134:	mov    %rbx,%rdi
    9137:	mov    0x20(%rsp),%r12
    913c:	callq  220 <put_link>
    9141:	jmpq   8b75 <path_openat+0x175>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    9146:	mov    0x58(%rsp),%rdi
    914b:	mov    %rbx,%rsi
    914e:	callq  9153 <path_openat+0x753>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    9153:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:851
  if (my_strcmp(get_current()->comm, "fs_kthread") != 0)
    error = security_inode_follow_link(link->dentry, nd);
  else
    error = 0;
	if (error)
		goto out_put_nd_path;
    9155:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:854

	nd->last_type = LAST_BIND;
	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
    9158:	jne    908f <path_openat+0x68f>
    915e:	jmpq   9068 <path_openat+0x668>
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    9163:	cmpq   $0x0,0x20(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652

    9168:	lea    0x20(%rbx),%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:651

static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}
    916c:	je     91b7 <path_openat+0x7b7>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:873
			set_root(nd);
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
    916e:	mov    %rbx,%rdi
    9171:	callq  9176 <path_openat+0x776>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
		nd->inode = nd->path.dentry->d_inode;
    9176:	mov    0x20(%rbx),%rax
    917a:	mov    0x28(%rbx),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    917e:	mov    %r15,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:874
			path_put(&nd->path);
			nd->path = nd->root;
			path_get(&nd->root);
			nd->flags |= LOOKUP_JUMPED;
		}
		nd->inode = nd->path.dentry->d_inode;
    9181:	mov    %rax,(%rbx)
    9184:	mov    %rdx,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:875
		error = link_path_walk(s, nd);
    9188:	callq  918d <path_openat+0x78d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:876
		if (unlikely(error))
    918d:	orl    $0x1000,0x38(%rbx)
    9194:	jmpq   910c <path_openat+0x70c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:867
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
		}
		if (*s == '/') {
    9199:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:869
			set_root(nd);
			path_put(&nd->path);
    919c:	mov    %r12d,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:867
		if (unlikely(IS_ERR(s))) {
			path_put(&nd->path);
			put_link(nd, link, *p);
			return PTR_ERR(s);
		}
		if (*s == '/') {
    919f:	callq  91a4 <path_openat+0x7a4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:868
			set_root(nd);
    91a4:	mov    %r13,%rdx
    91a7:	mov    %r14,%rsi
    91aa:	mov    %rbx,%rdi
    91ad:	callq  220 <put_link>
    91b2:	jmpq   90a2 <path_openat+0x6a2>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    91b7:	mov    %gs:0x0,%rdi
set_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:652
static __always_inline void set_root(struct nameidata *nd)
{
	if (!nd->root.mnt)
		get_fs_root(current->fs, &nd->root);
}

    91c0:	add    $0x4a8,%rdi
    91c7:	callq  1370 <my_strcmp_base.constprop.35>
    91cc:	test   %eax,%eax
    91ce:	jne    91e0 <path_openat+0x7e0>
    91d0:	cmpb   $0x0,0x0(%rip)        # 91d7 <path_openat+0x7d7>
    91d7:	mov    0x0(%rip),%rax        # 91de <path_openat+0x7de>
    91de:	jne    91e9 <path_openat+0x7e9>
    91e0:	mov    %gs:0x0,%rax
    91e9:	mov    0x588(%rax),%rdi
    91f0:	mov    %r15,%rsi
    91f3:	callq  16d0 <get_fs_root>
    91f8:	jmpq   916e <path_openat+0x76e>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:839

	error = -ELOOP;
	if (unlikely(current->total_link_count >= 40))
		goto out_put_nd_path;

	cond_resched();
    91fd:	mov    $0xffffffd8,%r15d
    9203:	lea    0x50(%rsp),%r14
    9208:	jmpq   908f <path_openat+0x68f>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3228
}

struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)
{
  MY_PRINTK(get_current()->comm);

    920d:	mov    0x40(%rsp),%rax
    9212:	mov    0x48(%rsp),%rdx
    9217:	mov    %rax,0x50(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3230
	struct nameidata nd;
	int flags = op->lookup_flags;
    921c:	mov    0x38(%rbx),%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3228
}

struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)
{
  MY_PRINTK(get_current()->comm);

    921f:	mov    %rdx,0x58(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3230
	struct nameidata nd;
	int flags = op->lookup_flags;
    9224:	test   $0x1,%al
    9226:	jne    8d8b <path_openat+0x38b>
    922c:	mov    0x20(%rsp),%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3231
	struct file *filp;
    9231:	lea    0x40(%rsp),%rdi
    9236:	mov    %rbx,%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3233

	filp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);
    9239:	mov    $0xffffffd8,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3231
{
  MY_PRINTK(get_current()->comm);

	struct nameidata nd;
	int flags = op->lookup_flags;
	struct file *filp;
    923f:	callq  d10 <path_put_conditional.isra.13>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    9244:	mov    0x8(%rbx),%rdi
    9248:	callq  924d <path_openat+0x84d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    924d:	mov    (%rbx),%rdi
    9250:	callq  9255 <path_openat+0x855>
path_openat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3234
	struct nameidata nd;
	int flags = op->lookup_flags;
	struct file *filp;

	filp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);
	if (unlikely(filp == ERR_PTR(-ECHILD)))
    9255:	jmpq   8b75 <path_openat+0x175>
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:749

	/* Allowed if parent directory and link owner match. */
	if (uid_eq(parent->i_uid, inode->i_uid))
		return 0;

	audit_log_link_denied("follow_link", link);
    925a:	cmp    0x4(%rcx),%esi
    925d:	je     8fa9 <path_openat+0x5a9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:752
	path_put_conditional(link, nd);
	path_put(&nd->path);
	return -EACCES;
    9263:	lea    0x50(%rsp),%rsi
    9268:	mov    $0x0,%rdi
    926f:	mov    0x20(%rsp),%r12
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
EXPORT_SYMBOL(path_put);
    9274:	mov    $0xfffffff3,%r15d
may_follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:752
		return 0;

	audit_log_link_denied("follow_link", link);
	path_put_conditional(link, nd);
	path_put(&nd->path);
	return -EACCES;
    927a:	callq  927f <path_openat+0x87f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:753
}
    927f:	lea    0x50(%rsp),%rdi
    9284:	mov    %rbx,%rsi
    9287:	callq  d10 <path_put_conditional.isra.13>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    928c:	mov    0x8(%rbx),%rdi
    9290:	callq  9295 <path_openat+0x895>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    9295:	mov    (%rbx),%rdi
    9298:	callq  929d <path_openat+0x89d>
    929d:	jmpq   8b75 <path_openat+0x175>
follow_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:834

	BUG_ON(nd->flags & LOOKUP_RCU);

	if (link->mnt == nd->path.mnt)
		mntget(link->mnt);

    92a2:	ud2    
do_tmpfile():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3181
		goto out;

	current->total_link_count = 0;
	error = link_path_walk(pathname->name, nd);
	if (unlikely(error))
		goto out;
    92a4:	mov    %r12,%rdi
    92a7:	callq  92ac <path_openat+0x8ac>
    92ac:	nopl   0x0(%rax)
    92b0:	jmpq   8d0c <path_openat+0x30c>
path_openat():
    92b5:	data32 nopw %cs:0x0(%rax,%rax,1)

00000000000092c0 <nd_jump_link>:
nd_jump_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:695
 */
void nd_jump_link(struct nameidata *nd, struct path *path)
{
	path_put(&nd->path);

	nd->path = *path;
    92c0:	callq  92c5 <nd_jump_link+0x5>
    92c5:	push   %rbp
    92c6:	mov    %rsp,%rbp
    92c9:	push   %r12
    92cb:	mov    %rsi,%r12
    92ce:	push   %rbx
    92cf:	mov    %rdi,%rbx
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    92d2:	mov    0x8(%rdi),%rdi
    92d6:	callq  92db <nd_jump_link+0x1b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    92db:	mov    (%rbx),%rdi
    92de:	callq  92e3 <nd_jump_link+0x23>
nd_jump_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:698
	path_put(&nd->path);

	nd->path = *path;
	nd->inode = nd->path.dentry->d_inode;
	nd->flags |= LOOKUP_JUMPED;
}
    92e3:	mov    (%r12),%rax
    92e7:	mov    0x8(%r12),%rdx
    92ec:	mov    %rax,(%rbx)
    92ef:	mov    %rdx,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:699

    92f3:	mov    0x8(%rbx),%rax
    92f7:	mov    0x30(%rax),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:700
static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
    92fb:	orl    $0x1000,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:699

	nd->path = *path;
	nd->inode = nd->path.dentry->d_inode;
	nd->flags |= LOOKUP_JUMPED;
}

    9302:	mov    %rax,0x30(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:701
static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
{
    9306:	pop    %rbx
    9307:	pop    %r12
    9309:	pop    %rbp
    930a:	retq   
    930b:	nopl   0x0(%rax,%rax,1)

0000000000009310 <kern_path_locked>:
kern_path_locked():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2017
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
	d = __lookup_hash(&nd.last, nd.path.dentry, 0);
	if (IS_ERR(d)) {
		mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
		path_put(&nd.path);
		return d;
    9310:	callq  9315 <kern_path_locked+0x5>
    9315:	push   %rbp
do_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    9316:	mov    $0x10,%edx
kern_path_locked():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2017
	d = __lookup_hash(&nd.last, nd.path.dentry, 0);
	if (IS_ERR(d)) {
		mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
		path_put(&nd.path);
		return d;
    931b:	mov    %rsp,%rbp
    931e:	push   %rbx
    931f:	mov    %rsi,%rbx
    9322:	and    $0xfffffffffffffff0,%rsp
    9326:	sub    $0xc8,%rsp
do_path_lookup():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    932d:	lea    0x28(%rsp),%rcx
    9332:	lea    0x8(%rsp),%rsi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    9337:	mov    %rdi,0x8(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    933c:	mov    $0xffffff9c,%edi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2010
	int err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);
	if (err)
		return ERR_PTR(err);
	if (nd.last_type != LAST_NORM) {
		path_put(&nd.path);
		return ERR_PTR(-EINVAL);
    9341:	movq   $0x0,0x10(%rsp)
    934a:	movq   $0x0,0x18(%rsp)
    9353:	movq   $0x0,0x20(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2012
	}
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    935c:	callq  4220 <filename_lookup>
kern_path_locked():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2021
		path_put(&nd.path);
		return d;
	}
	*path = nd.path;
	return d;
}
    9361:	test   %eax,%eax
    9363:	jne    93e0 <kern_path_locked+0xd0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2023

int kern_path(const char *name, unsigned int flags, struct path *path)
    9365:	mov    0x6c(%rsp),%eax
    9369:	test   %eax,%eax
    936b:	jne    93b8 <kern_path_locked+0xa8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2027
{
	struct nameidata nd;
	int res = do_path_lookup(AT_FDCWD, name, flags, &nd);
	if (!res)
    936d:	mov    0x30(%rsp),%rax
    9372:	mov    0x30(%rax),%rdi
    9376:	add    $0xa8,%rdi
    937d:	callq  9382 <kern_path_locked+0x72>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2028
		*path = nd.path;
    9382:	mov    0x30(%rsp),%rsi
    9387:	lea    0x38(%rsp),%rdi
    938c:	xor    %edx,%edx
    938e:	callq  9a0 <__lookup_hash>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2029
	return res;
    9393:	cmp    $0xfffffffffffff000,%rax
    9399:	ja     93e8 <kern_path_locked+0xd8>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2034
}

/**
 * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
 * @dentry:  pointer to dentry of the base directory
    939b:	mov    0x28(%rsp),%r9
    93a0:	mov    0x30(%rsp),%r10
    93a5:	mov    %r9,(%rbx)
    93a8:	mov    %r10,0x8(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2036
 * @mnt: pointer to vfs mount of the base directory
 * @name: pointer to file name
    93ac:	mov    -0x8(%rbp),%rbx
    93b0:	leaveq 
    93b1:	retq   
    93b2:	nopw   0x0(%rax,%rax,1)
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    93b8:	mov    0x30(%rsp),%rdi
    93bd:	callq  93c2 <kern_path_locked+0xb2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    93c2:	mov    0x28(%rsp),%rdi
    93c7:	callq  93cc <kern_path_locked+0xbc>
kern_path_locked():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2025
	return d;
}

int kern_path(const char *name, unsigned int flags, struct path *path)
{
	struct nameidata nd;
    93cc:	mov    $0xffffffffffffffea,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2036

/**
 * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
 * @dentry:  pointer to dentry of the base directory
 * @mnt: pointer to vfs mount of the base directory
 * @name: pointer to file name
    93d3:	mov    -0x8(%rbp),%rbx
    93d7:	leaveq 
    93d8:	retq   
    93d9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2022
		return d;
	}
	*path = nd.path;
	return d;
}

    93e0:	cltq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2036

/**
 * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
 * @dentry:  pointer to dentry of the base directory
 * @mnt: pointer to vfs mount of the base directory
 * @name: pointer to file name
    93e2:	mov    -0x8(%rbp),%rbx
    93e6:	leaveq 
    93e7:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2030
	struct nameidata nd;
	int res = do_path_lookup(AT_FDCWD, name, flags, &nd);
	if (!res)
		*path = nd.path;
	return res;
}
    93e8:	mov    0x30(%rsp),%rdx
    93ed:	mov    %rax,(%rsp)
    93f1:	mov    0x30(%rdx),%rdi
    93f5:	add    $0xa8,%rdi
    93fc:	callq  9401 <kern_path_locked+0xf1>
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    9401:	mov    0x30(%rsp),%rdi
    9406:	callq  940b <kern_path_locked+0xfb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    940b:	mov    0x28(%rsp),%rdi
    9410:	callq  9415 <kern_path_locked+0x105>
kern_path_locked():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2032
	if (!res)
		*path = nd.path;
	return res;
}

/**
    9415:	mov    (%rsp),%rax
    9419:	jmp    93ac <kern_path_locked+0x9c>
    941b:	nopl   0x0(%rax,%rax,1)

0000000000009420 <user_path_at_empty>:
user_path_at_empty():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2135
	return err;
}

int user_path_at(int dfd, const char __user *name, unsigned flags, struct path *path)
{
	return user_path_at_empty(dfd, name, flags, path, NULL);
    9420:	callq  9425 <user_path_at_empty+0x5>
    9425:	push   %rbp
    9426:	mov    %rsp,%rbp
    9429:	push   %r14
    942b:	mov    %edi,%r14d
    942e:	mov    %rsi,%rdi
    9431:	push   %r13
    9433:	mov    %rcx,%r13
    9436:	push   %r12
    9438:	mov    %edx,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2137
}

    943b:	mov    %r8,%rdx
    943e:	mov    %r12d,%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2135
	return err;
}

int user_path_at(int dfd, const char __user *name, unsigned flags, struct path *path)
{
	return user_path_at_empty(dfd, name, flags, path, NULL);
    9441:	push   %rbx
    9442:	and    $0xfffffffffffffff0,%rsp
    9446:	sub    $0xa0,%rsp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2137
}

    944d:	callq  2290 <getname_flags>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2139
/*
 * NB: most callers don't do anything directly with the reference to the
    9452:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2137

int user_path_at(int dfd, const char __user *name, unsigned flags, struct path *path)
{
	return user_path_at_empty(dfd, name, flags, path, NULL);
}

    9458:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2139
/*
 * NB: most callers don't do anything directly with the reference to the
    945b:	ja     94a5 <user_path_at_empty+0x85>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2141
 *     to struct filename, but the nd->last pointer points into the name string
 *     allocated by getname. So we must hold the reference to it until all
    945d:	test   $0x10,%r12b
    9461:	jne    94aa <user_path_at_empty+0x8a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2143
 *     path-walking is complete.
 */
    9463:	mov    %r12d,%edx
    9466:	mov    %rsp,%rcx
    9469:	mov    %rax,%rsi
    946c:	mov    %r14d,%edi
    946f:	callq  4220 <filename_lookup>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2144
static struct filename *user_path_parent(int dfd, const char __user *path, struct nameidata *nd, unsigned int flags)
    9474:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2143
/*
 * NB: most callers don't do anything directly with the reference to the
 *     to struct filename, but the nd->last pointer points into the name string
 *     allocated by getname. So we must hold the reference to it until all
 *     path-walking is complete.
 */
    9477:	mov    %eax,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2144
static struct filename *user_path_parent(int dfd, const char __user *path, struct nameidata *nd, unsigned int flags)
    947a:	callq  947f <user_path_at_empty+0x5f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2145
{
    947f:	test   %r12d,%r12d
    9482:	jne    9495 <user_path_at_empty+0x75>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2146
	struct filename *s = getname(path);
    9484:	mov    (%rsp),%rsi
    9488:	mov    0x8(%rsp),%rdi
    948d:	mov    %rsi,0x0(%r13)
    9491:	mov    %rdi,0x8(%r13)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2149
	int error;

	/* only LOOKUP_REVAL is allowed in extra flags */
    9495:	lea    -0x20(%rbp),%rsp
    9499:	mov    %r12d,%eax
    949c:	pop    %rbx
    949d:	pop    %r12
    949f:	pop    %r13
    94a1:	pop    %r14
    94a3:	pop    %rbp
    94a4:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2138
int user_path_at(int dfd, const char __user *name, unsigned flags, struct path *path)
{
	return user_path_at_empty(dfd, name, flags, path, NULL);
}

/*
    94a5:	mov    %eax,%r12d
    94a8:	jmp    9495 <user_path_at_empty+0x75>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2141 (discriminator 1)
 * NB: most callers don't do anything directly with the reference to the
 *     to struct filename, but the nd->last pointer points into the name string
 *     allocated by getname. So we must hold the reference to it until all
    94aa:	ud2    
    94ac:	nopl   0x0(%rax)

00000000000094b0 <user_path_at>:
user_path_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2153

	/* only LOOKUP_REVAL is allowed in extra flags */
	flags &= LOOKUP_REVAL;

	if (IS_ERR(s))
		return s;
    94b0:	callq  94b5 <user_path_at+0x5>
    94b5:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2154

    94b6:	xor    %r8d,%r8d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2153

	/* only LOOKUP_REVAL is allowed in extra flags */
	flags &= LOOKUP_REVAL;

	if (IS_ERR(s))
		return s;
    94b9:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2154

    94bc:	callq  94c1 <user_path_at+0x11>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2155
	error = filename_lookup(dfd, s, flags | LOOKUP_PARENT, nd);
    94c1:	pop    %rbp
    94c2:	retq   
    94c3:	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

00000000000094d0 <user_path_mountpoint_at>:
user_path_mountpoint_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2358
{
	kuid_t fsuid = current_fsuid();

	if (!(dir->i_mode & S_ISVTX))
		return 0;
	if (uid_eq(inode->i_uid, fsuid))
    94d0:	callq  94d5 <user_path_mountpoint_at+0x5>
    94d5:	push   %rbp
    94d6:	mov    %rsp,%rbp
    94d9:	push   %r14
    94db:	mov    %edx,%r14d
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    94de:	xor    %edx,%edx
user_path_mountpoint_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2358
{
	kuid_t fsuid = current_fsuid();

	if (!(dir->i_mode & S_ISVTX))
		return 0;
	if (uid_eq(inode->i_uid, fsuid))
    94e0:	push   %r13
    94e2:	mov    %rcx,%r13
    94e5:	push   %r12
    94e7:	mov    %edi,%r12d
    94ea:	mov    %rsi,%rdi
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    94ed:	xor    %esi,%esi
user_path_mountpoint_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2358
{
	kuid_t fsuid = current_fsuid();

	if (!(dir->i_mode & S_ISVTX))
		return 0;
	if (uid_eq(inode->i_uid, fsuid))
    94ef:	push   %rbx
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    94f0:	callq  2290 <getname_flags>
user_path_mountpoint_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2361
	if (!(dir->i_mode & S_ISVTX))
		return 0;
	if (uid_eq(inode->i_uid, fsuid))
		return 0;
	if (uid_eq(dir->i_uid, fsuid))
		return 0;
    94f5:	cmp    $0xfffffffffffff000,%rax
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    94fb:	mov    %rax,%rbx
user_path_mountpoint_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2361
	if (!(dir->i_mode & S_ISVTX))
		return 0;
	if (uid_eq(inode->i_uid, fsuid))
		return 0;
	if (uid_eq(dir->i_uid, fsuid))
		return 0;
    94fe:	ja     951f <user_path_mountpoint_at+0x4f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2363
	return !inode_capable(inode, CAP_FOWNER);
}
    9500:	mov    %r12d,%edi
    9503:	mov    %r14d,%ecx
    9506:	mov    %r13,%rdx
    9509:	mov    %rax,%rsi
    950c:	callq  4ce0 <filename_mountpoint>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2364

    9511:	mov    %rbx,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2363
	if (uid_eq(inode->i_uid, fsuid))
		return 0;
	if (uid_eq(dir->i_uid, fsuid))
		return 0;
	return !inode_capable(inode, CAP_FOWNER);
}
    9514:	mov    %eax,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2364

    9517:	callq  951c <user_path_mountpoint_at+0x4c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2365
/*
    951c:	mov    %r12d,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2366
 *	Check whether we can remove a link victim from directory dir, check
    951f:	pop    %rbx
    9520:	pop    %r12
    9522:	pop    %r13
    9524:	pop    %r14
    9526:	pop    %rbp
    9527:	retq   
    9528:	nopl   0x0(%rax,%rax,1)

0000000000009530 <do_filp_open>:
do_filp_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3270
	struct nameidata nd;
	int err2;
	int error;
	bool is_dir = (lookup_flags & LOOKUP_DIRECTORY);

	/*
    9530:	callq  9535 <do_filp_open+0x5>
    9535:	push   %rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3271
	 * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any
    9536:	mov    $0x0,%rax
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    953d:	mov    %gs:0x0,%r8
do_filp_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3270
	struct nameidata nd;
	int err2;
	int error;
	bool is_dir = (lookup_flags & LOOKUP_DIRECTORY);

	/*
    9546:	mov    %rsp,%rbp
    9549:	push   %r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3271
	 * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any
    954b:	add    $0x4a8,%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3270
	struct nameidata nd;
	int err2;
	int error;
	bool is_dir = (lookup_flags & LOOKUP_DIRECTORY);

	/*
    9552:	push   %r13
    9554:	mov    %rdx,%r13
    9557:	push   %r12
    9559:	mov    %rsi,%r12
    955c:	push   %rbx
    955d:	mov    %edi,%ebx
    955f:	and    $0xfffffffffffffff0,%rsp
    9563:	sub    $0xa0,%rsp
    956a:	jmp    9579 <do_filp_open+0x49>
    956c:	nopl   0x0(%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
    9570:	test   %sil,%sil
    9573:	je     95f8 <do_filp_open+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    9579:	add    $0x1,%r8
    957d:	movzbl -0x1(%r8),%esi
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    9582:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    9586:	cmp    -0x1(%rax),%sil
    958a:	je     9570 <do_filp_open+0x40>
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    958c:	mov    %gs:0x0,%rsi
do_filp_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3271
	 * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any
    9595:	mov    $0x0,%rax
    959c:	add    $0x4a8,%rsi
    95a3:	jmp    95ac <do_filp_open+0x7c>
    95a5:	nopl   (%rax)
my_strcmp():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:15
			return c1 < c2 ? -1 : 1;
		if (!c1)
    95a8:	test   %dl,%dl
    95aa:	je     95f8 <do_filp_open+0xc8>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:11

static int my_strcmp(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    95ac:	add    $0x1,%rsi
    95b0:	movzbl -0x1(%rsi),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:12
		c2 = *ct++;
    95b4:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/interactive_design.h:13
		if (c1 != c2)
    95b8:	cmp    -0x1(%rax),%dl
    95bb:	je     95a8 <do_filp_open+0x78>
do_filp_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3274
	 * other flags passed in are ignored!
	 */
	lookup_flags &= LOOKUP_REVAL;
    95bd:	mov    0x10(%r13),%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3277

	error = do_path_lookup(dfd, pathname, LOOKUP_PARENT|lookup_flags, &nd);
	if (error)
    95c1:	mov    %r13,%rcx
    95c4:	mov    %rsp,%rdx
    95c7:	mov    %r12,%rsi
    95ca:	mov    %ebx,%edi
    95cc:	mov    %r14d,%r8d
    95cf:	or     $0x40,%r8d
    95d3:	callq  8a00 <path_openat>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3278
		return ERR_PTR(error);
    95d8:	cmp    $0xfffffffffffffff6,%rax
    95dc:	je     9638 <do_filp_open+0x108>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3280

	/*
    95de:	cmp    $0xffffffffffffff8c,%rax
    95e2:	je     961f <do_filp_open+0xef>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3283
	 * Yucky last component or no last component at all?
	 * (foo/., foo/.., /////)
	 */
    95e4:	lea    -0x20(%rbp),%rsp
    95e8:	pop    %rbx
    95e9:	pop    %r12
    95eb:	pop    %r13
    95ed:	pop    %r14
    95ef:	pop    %rbp
    95f0:	retq   
    95f1:	nopl   0x0(%rax)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    95f8:	mov    %gs:0x0,%rdx
do_filp_open():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3271
	int err2;
	int error;
	bool is_dir = (lookup_flags & LOOKUP_DIRECTORY);

	/*
	 * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any
    9601:	mov    $0x0,%rsi
    9608:	add    $0x4a8,%rdx
    960f:	mov    $0x0,%rdi
    9616:	xor    %eax,%eax
    9618:	callq  961d <do_filp_open+0xed>
    961d:	jmp    95bd <do_filp_open+0x8d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3281
	error = do_path_lookup(dfd, pathname, LOOKUP_PARENT|lookup_flags, &nd);
	if (error)
		return ERR_PTR(error);

	/*
	 * Yucky last component or no last component at all?
    961f:	or     $0x20,%r14d
    9623:	mov    %r13,%rcx
    9626:	mov    %rsp,%rdx
    9629:	mov    %r14d,%r8d
    962c:	mov    %r12,%rsi
    962f:	mov    %ebx,%edi
    9631:	callq  8a00 <path_openat>
    9636:	jmp    95e4 <do_filp_open+0xb4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3279
	lookup_flags &= LOOKUP_REVAL;

	error = do_path_lookup(dfd, pathname, LOOKUP_PARENT|lookup_flags, &nd);
	if (error)
		return ERR_PTR(error);

    9638:	mov    %r14d,%r8d
    963b:	mov    %r13,%rcx
    963e:	mov    %rsp,%rdx
    9641:	mov    %r12,%rsi
    9644:	mov    %ebx,%edi
    9646:	callq  8a00 <path_openat>
    964b:	jmp    95de <do_filp_open+0xae>
    964d:	nopl   (%rax)

0000000000009650 <do_file_open_root>:
do_file_open_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3287
	 * (foo/., foo/.., /////)
	 */
	if (nd.last_type != LAST_NORM)
		goto out;
	nd.flags &= ~LOOKUP_PARENT;
	nd.flags |= LOOKUP_CREATE | LOOKUP_EXCL;
    9650:	callq  9655 <do_file_open_root+0x5>
    9655:	push   %rbp
    9656:	mov    %rsp,%rbp
    9659:	push   %r12
    965b:	push   %rbx
    965c:	mov    %rcx,%rbx
    965f:	and    $0xfffffffffffffff0,%rsp
    9663:	sub    $0xc0,%rsp
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    966a:	mov    (%rdi),%eax
do_file_open_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3291

	/* don't fail immediately if it's r/o, at least try to report other errors */
	err2 = mnt_want_write(nd.path.mnt);
	/*
    966c:	mov    0x10(%rcx),%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3290
		goto out;
	nd.flags &= ~LOOKUP_PARENT;
	nd.flags |= LOOKUP_CREATE | LOOKUP_EXCL;

	/* don't fail immediately if it's r/o, at least try to report other errors */
	err2 = mnt_want_write(nd.path.mnt);
    9670:	movq   $0x0,0x8(%rsp)
    9679:	movq   $0x0,0x10(%rsp)
    9682:	movq   $0x0,0x18(%rsp)
    968b:	mov    %rdx,(%rsp)
__d_entry_type():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/dcache.h:431
    968f:	and    $0x700000,%eax
do_file_open_root():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3293
	/*
	 * Do the final lookup.
	 */
    9694:	mov    %rsi,0x40(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3294
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
    9699:	mov    %rdi,0x48(%rsp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3296
	dentry = lookup_hash(&nd);
	if (IS_ERR(dentry))
    969e:	cmp    $0x300000,%eax
    96a3:	je     96e0 <do_file_open_root+0x90>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3299
		goto unlock;

	error = -EEXIST;
    96a5:	mov    %r12d,%r8d
    96a8:	lea    0x20(%rsp),%rdx
    96ad:	mov    %rbx,%rcx
    96b0:	or     $0x2040,%r8d
    96b7:	mov    %rsp,%rsi
    96ba:	mov    $0xffffffff,%edi
    96bf:	callq  8a00 <path_openat>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3300
	if (d_is_positive(dentry))
    96c4:	cmp    $0xfffffffffffffff6,%rax
    96c8:	je     9715 <do_file_open_root+0xc5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3302
		goto fail;

    96ca:	cmp    $0xffffffffffffff8c,%rax
    96ce:	je     96f6 <do_file_open_root+0xa6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3305
	/*
	 * Special case - lookup gave negative, but... we had foo/bar/
	 * From the vfs_mknod() POV we just have a negative dentry -
    96d0:	lea    -0x10(%rbp),%rsp
    96d4:	pop    %rbx
    96d5:	pop    %r12
    96d7:	pop    %rbp
    96d8:	retq   
    96d9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3296 (discriminator 1)
	/*
	 * Do the final lookup.
	 */
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
	dentry = lookup_hash(&nd);
	if (IS_ERR(dentry))
    96e0:	testb  $0x1,0xd(%rcx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3297 (discriminator 1)
		goto unlock;
    96e4:	mov    $0xffffffffffffffd8,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3296 (discriminator 1)
	/*
	 * Do the final lookup.
	 */
	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
	dentry = lookup_hash(&nd);
	if (IS_ERR(dentry))
    96eb:	je     96a5 <do_file_open_root+0x55>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3305
	if (d_is_positive(dentry))
		goto fail;

	/*
	 * Special case - lookup gave negative, but... we had foo/bar/
	 * From the vfs_mknod() POV we just have a negative dentry -
    96ed:	lea    -0x10(%rbp),%rsp
    96f1:	pop    %rbx
    96f2:	pop    %r12
    96f4:	pop    %rbp
    96f5:	retq   
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3303

	error = -EEXIST;
	if (d_is_positive(dentry))
		goto fail;

	/*
    96f6:	mov    %r12d,%r8d
    96f9:	lea    0x20(%rsp),%rdx
    96fe:	mov    %rbx,%rcx
    9701:	or     $0x2020,%r8d
    9708:	mov    %rsp,%rsi
    970b:	or     $0xffffffff,%edi
    970e:	callq  8a00 <path_openat>
    9713:	jmp    96d0 <do_file_open_root+0x80>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3301
	if (IS_ERR(dentry))
		goto unlock;

	error = -EEXIST;
	if (d_is_positive(dentry))
		goto fail;
    9715:	mov    %r12d,%r8d
    9718:	lea    0x20(%rsp),%rdx
    971d:	mov    %rbx,%rcx
    9720:	or     $0x2000,%r8d
    9727:	mov    %rsp,%rsi
    972a:	or     $0xffffffff,%edi
    972d:	callq  8a00 <path_openat>
    9732:	jmp    96ca <do_file_open_root+0x7a>
    9734:	data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000009740 <SyS_mknodat>:
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    9740:	callq  9745 <SyS_mknodat+0x5>
    9745:	push   %rbp
may_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    9746:	mov    $0xffffffffffffffff,%rax
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    974d:	mov    %rsp,%rbp
    9750:	push   %r15
    9752:	push   %r14
    9754:	push   %r13
    9756:	push   %r12
    9758:	push   %rbx
    9759:	mov    %edx,%ebx
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    975b:	and    $0xf000,%dx
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    9760:	sub    $0x28,%rsp
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    9764:	cmp    $0x4000,%dx
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    9769:	mov    %rdi,-0x48(%rbp)
may_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    976d:	je     9790 <SyS_mknodat+0x50>
    976f:	mov    %rsi,%r14
    9772:	ja     97a0 <SyS_mknodat+0x60>
    9774:	cmp    $0x1000,%dx
    9779:	je     97b8 <SyS_mknodat+0x78>
    977b:	cmp    $0x2000,%dx
    9780:	je     97b8 <SyS_mknodat+0x78>
    9782:	test   %dx,%dx
    9785:	je     97b8 <SyS_mknodat+0x78>
    9787:	mov    $0xffffffffffffffea,%rax
    978e:	xchg   %ax,%ax
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    9790:	add    $0x28,%rsp
    9794:	pop    %rbx
    9795:	pop    %r12
    9797:	pop    %r13
    9799:	pop    %r14
    979b:	pop    %r15
    979d:	pop    %rbp
    979e:	retq   
    979f:	nop
may_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    97a0:	cmp    $0x8000,%dx
    97a5:	je     97b8 <SyS_mknodat+0x78>
    97a7:	cmp    $0xc000,%dx
    97ac:	je     97b8 <SyS_mknodat+0x78>
    97ae:	cmp    $0x6000,%dx
    97b3:	jne    9787 <SyS_mknodat+0x47>
    97b5:	nopl   (%rax)
new_decode_dev():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:53
}

static inline dev_t new_decode_dev(u32 dev)
{
	unsigned major = (dev & 0xfff00) >> 8;
	unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
    97b8:	mov    %ecx,%eax
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    97ba:	mov    %ecx,-0x40(%rbp)
new_decode_dev():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:54
	return MKDEV(major, minor);
    97bd:	xor    %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:53
}

static inline dev_t new_decode_dev(u32 dev)
{
	unsigned major = (dev & 0xfff00) >> 8;
	unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
    97c0:	shr    $0xc,%eax
    97c3:	mov    %eax,-0x4c(%rbp)
    97c6:	andl   $0xfff00,-0x4c(%rbp)
    97cd:	movzbl %cl,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:52
	return (minor & 0xff) | (major << 8) | ((minor & ~0xff) << 12);
}

static inline dev_t new_decode_dev(u32 dev)
{
	unsigned major = (dev & 0xfff00) >> 8;
    97d0:	and    $0xfff00,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:53
	unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
    97d6:	or     %eax,-0x4c(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:54
	return MKDEV(major, minor);
    97d9:	shl    $0xc,%ecx
    97dc:	or     %ecx,-0x4c(%rbp)
    97df:	nop
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3456
	if (!dir->i_op->mkdir)
		return -EPERM;

	mode &= (S_IRWXUGO|S_ISVTX);
	error = security_inode_mkdir(dir, dentry, mode);
	if (error)
    97e0:	mov    -0x48(%rbp),%edi
    97e3:	lea    -0x38(%rbp),%rdx
    97e7:	mov    %r12d,%ecx
    97ea:	mov    %r14,%rsi
    97ed:	callq  97f2 <SyS_mknodat+0xb2>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3457
		return error;
    97f2:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3456
	if (!dir->i_op->mkdir)
		return -EPERM;

	mode &= (S_IRWXUGO|S_ISVTX);
	error = security_inode_mkdir(dir, dentry, mode);
	if (error)
    97f8:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3457
		return error;
    97fb:	ja     9790 <SyS_mknodat+0x50>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3460

	if (max_links && dir->i_nlink >= max_links)
		return -EMLINK;
    97fd:	mov    -0x30(%rbp),%rax
    9801:	mov    0x30(%rax),%rax
    9805:	mov    0x28(%rax),%rax
    9809:	testb  $0x1,0x52(%rax)
    980d:	je     98d0 <SyS_mknodat+0x190>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3462

	error = dir->i_op->mkdir(dir, dentry, mode);
    9813:	mov    -0x40(%rbp),%ecx
    9816:	movzwl %bx,%r13d
    981a:	lea    -0x38(%rbp),%rdi
    981e:	mov    %r13d,%edx
    9821:	mov    %r15,%rsi
    9824:	callq  9829 <SyS_mknodat+0xe9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3463
	if (!error)
    9829:	test   %eax,%eax
    982b:	jne    98a0 <SyS_mknodat+0x160>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3465
		fsnotify_mkdir(dir, dentry);
	return error;
    982d:	mov    %ebx,%eax
    982f:	and    $0xf000,%ax
    9833:	cmp    $0x2000,%ax
    9837:	je     9920 <SyS_mknodat+0x1e0>
    983d:	jbe    9880 <SyS_mknodat+0x140>
    983f:	cmp    $0x8000,%ax
    9843:	je     9900 <SyS_mknodat+0x1c0>
    9849:	cmp    $0xc000,%ax
    984d:	nopl   (%rax)
    9850:	je     988b <SyS_mknodat+0x14b>
    9852:	cmp    $0x6000,%ax
    9856:	je     9920 <SyS_mknodat+0x1e0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3478
	unsigned int lookup_flags = LOOKUP_DIRECTORY;

retry:
	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    985c:	lea    -0x38(%rbp),%rdi
    9860:	mov    %r15,%rsi
    9863:	callq  9868 <SyS_mknodat+0x128>
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    9868:	add    $0x28,%rsp
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3478
	unsigned int lookup_flags = LOOKUP_DIRECTORY;

retry:
	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    986c:	xor    %eax,%eax
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    986e:	pop    %rbx
    986f:	pop    %r12
    9871:	pop    %r13
    9873:	pop    %r14
    9875:	pop    %r15
    9877:	pop    %rbp
    9878:	retq   
    9879:	nopl   0x0(%rax)
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3465
		return -EMLINK;

	error = dir->i_op->mkdir(dir, dentry, mode);
	if (!error)
		fsnotify_mkdir(dir, dentry);
	return error;
    9880:	test   %ax,%ax
    9883:	je     9900 <SyS_mknodat+0x1c0>
    9885:	cmp    $0x1000,%ax
    9889:	jne    985c <SyS_mknodat+0x11c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3474
{
	struct dentry *dentry;
	struct path path;
	int error;
	unsigned int lookup_flags = LOOKUP_DIRECTORY;

    988b:	mov    -0x30(%rbp),%rax
    988f:	xor    %ecx,%ecx
    9891:	mov    %r13d,%edx
    9894:	mov    %r15,%rsi
    9897:	mov    0x30(%rax),%rdi
    989b:	callq  98a0 <SyS_mknodat+0x160>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3478
retry:
	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    98a0:	lea    -0x38(%rbp),%rdi
    98a4:	mov    %r15,%rsi
    98a7:	mov    %eax,-0x3c(%rbp)
    98aa:	callq  98af <SyS_mknodat+0x16f>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
 * Returns true if the caller should try the operation again.
 */
static inline bool
retry_estale(const long error, const unsigned int flags)
{
	return error == -ESTALE && !(flags & LOOKUP_REVAL);
    98af:	movslq -0x3c(%rbp),%rax
    98b3:	cmp    $0xffffff8c,%eax
    98b6:	jne    9790 <SyS_mknodat+0x50>
    98bc:	test   %r12d,%r12d
    98bf:	jne    98e0 <SyS_mknodat+0x1a0>
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3480

	if (!IS_POSIXACL(path.dentry->d_inode))
    98c1:	mov    $0x20,%r12b
    98c4:	jmpq   97e0 <SyS_mknodat+0xa0>
    98c9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3461
	if (error)
		return error;

	if (max_links && dir->i_nlink >= max_links)
		return -EMLINK;

    98d0:	callq  98d5 <SyS_mknodat+0x195>
    98d5:	not    %eax
    98d7:	and    %eax,%ebx
    98d9:	jmpq   9813 <SyS_mknodat+0xd3>
    98de:	xchg   %ax,%ax
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
{
	return sys_mknodat(AT_FDCWD, filename, mode, dev);
}

int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    98e0:	add    $0x28,%rsp
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    98e4:	mov    $0xffffffffffffff8c,%rax
SyS_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3444
    98eb:	pop    %rbx
    98ec:	pop    %r12
    98ee:	pop    %r13
    98f0:	pop    %r14
    98f2:	pop    %r15
    98f4:	pop    %rbp
    98f5:	retq   
    98f6:	nopw   %cs:0x0(%rax,%rax,1)
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3467
	error = dir->i_op->mkdir(dir, dentry, mode);
	if (!error)
		fsnotify_mkdir(dir, dentry);
	return error;
}

    9900:	mov    -0x30(%rbp),%rax
    9904:	mov    $0x1,%ecx
    9909:	mov    %r13d,%edx
    990c:	mov    %r15,%rsi
    990f:	mov    0x30(%rax),%rdi
    9913:	callq  9918 <SyS_mknodat+0x1d8>
    9918:	jmp    98a0 <SyS_mknodat+0x160>
    991a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3470
SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
{
	struct dentry *dentry;
    9920:	mov    -0x30(%rbp),%rax
    9924:	mov    -0x4c(%rbp),%ecx
    9927:	mov    %r13d,%edx
    992a:	mov    %r15,%rsi
    992d:	mov    0x30(%rax),%rdi
    9931:	callq  9936 <SyS_mknodat+0x1f6>
    9936:	jmpq   98a0 <SyS_mknodat+0x160>
sys_mknodat():
    993b:	nopl   0x0(%rax,%rax,1)

0000000000009940 <SyS_mknod>:
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    9940:	callq  9945 <SyS_mknod+0x5>
    9945:	push   %rbp
may_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    9946:	mov    $0xffffffffffffffff,%rax
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    994d:	mov    %rsp,%rbp
    9950:	push   %r15
    9952:	push   %r14
    9954:	push   %r13
    9956:	push   %r12
    9958:	push   %rbx
    9959:	mov    %esi,%ebx
SYSC_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    995b:	and    $0xf000,%si
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    9960:	sub    $0x20,%rsp
may_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    9964:	cmp    $0x4000,%si
    9969:	je     9990 <SyS_mknod+0x50>
    996b:	mov    %rdi,%r13
    996e:	ja     99a0 <SyS_mknod+0x60>
    9970:	cmp    $0x1000,%si
    9975:	je     99b8 <SyS_mknod+0x78>
    9977:	cmp    $0x2000,%si
    997c:	je     99b8 <SyS_mknod+0x78>
    997e:	test   %si,%si
    9981:	je     99b8 <SyS_mknod+0x78>
    9983:	mov    $0xffffffffffffffea,%rax
    998a:	nopw   0x0(%rax,%rax,1)
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    9990:	add    $0x20,%rsp
    9994:	pop    %rbx
    9995:	pop    %r12
    9997:	pop    %r13
    9999:	pop    %r14
    999b:	pop    %r15
    999d:	pop    %rbp
    999e:	retq   
    999f:	nop
may_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3429
			break;
		case S_IFIFO: case S_IFSOCK:
			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
			break;
	}
out:
    99a0:	cmp    $0x8000,%si
    99a5:	je     99b8 <SyS_mknod+0x78>
    99a7:	cmp    $0xc000,%si
    99ac:	je     99b8 <SyS_mknod+0x78>
    99ae:	cmp    $0x6000,%si
    99b3:	jne    9983 <SyS_mknod+0x43>
    99b5:	nopl   (%rax)
new_decode_dev():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:53
}

static inline dev_t new_decode_dev(u32 dev)
{
	unsigned major = (dev & 0xfff00) >> 8;
	unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
    99b8:	mov    %edx,%eax
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    99ba:	mov    %edx,-0x40(%rbp)
new_decode_dev():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:54
	return MKDEV(major, minor);
    99bd:	xor    %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:53
}

static inline dev_t new_decode_dev(u32 dev)
{
	unsigned major = (dev & 0xfff00) >> 8;
	unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
    99c0:	shr    $0xc,%eax
    99c3:	mov    %eax,-0x44(%rbp)
    99c6:	andl   $0xfff00,-0x44(%rbp)
    99cd:	movzbl %dl,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:52
	return (minor & 0xff) | (major << 8) | ((minor & ~0xff) << 12);
}

static inline dev_t new_decode_dev(u32 dev)
{
	unsigned major = (dev & 0xfff00) >> 8;
    99d0:	and    $0xfff00,%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:53
	unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
    99d6:	or     %eax,-0x44(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/kdev_t.h:54
	return MKDEV(major, minor);
    99d9:	shl    $0xc,%edx
    99dc:	or     %edx,-0x44(%rbp)
    99df:	nop
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3456
	if (!dir->i_op->mkdir)
		return -EPERM;

	mode &= (S_IRWXUGO|S_ISVTX);
	error = security_inode_mkdir(dir, dentry, mode);
	if (error)
    99e0:	lea    -0x38(%rbp),%rdx
    99e4:	mov    %r12d,%ecx
    99e7:	mov    %r13,%rsi
    99ea:	mov    $0xffffff9c,%edi
    99ef:	callq  99f4 <SyS_mknod+0xb4>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3457
		return error;
    99f4:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3456
	if (!dir->i_op->mkdir)
		return -EPERM;

	mode &= (S_IRWXUGO|S_ISVTX);
	error = security_inode_mkdir(dir, dentry, mode);
	if (error)
    99fa:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3457
		return error;
    99fd:	ja     9990 <SyS_mknod+0x50>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3460

	if (max_links && dir->i_nlink >= max_links)
		return -EMLINK;
    99ff:	mov    -0x30(%rbp),%rax
    9a03:	mov    0x30(%rax),%rax
    9a07:	mov    0x28(%rax),%rax
    9a0b:	testb  $0x1,0x52(%rax)
    9a0f:	je     9ad0 <SyS_mknod+0x190>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3462

	error = dir->i_op->mkdir(dir, dentry, mode);
    9a15:	mov    -0x40(%rbp),%ecx
    9a18:	movzwl %bx,%r14d
    9a1c:	lea    -0x38(%rbp),%rdi
    9a20:	mov    %r14d,%edx
    9a23:	mov    %r15,%rsi
    9a26:	callq  9a2b <SyS_mknod+0xeb>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3463
	if (!error)
    9a2b:	test   %eax,%eax
    9a2d:	jne    9aa0 <SyS_mknod+0x160>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3465
		fsnotify_mkdir(dir, dentry);
	return error;
    9a2f:	mov    %ebx,%eax
    9a31:	and    $0xf000,%ax
    9a35:	cmp    $0x2000,%ax
    9a39:	je     9b20 <SyS_mknod+0x1e0>
    9a3f:	jbe    9a80 <SyS_mknod+0x140>
    9a41:	cmp    $0x8000,%ax
    9a45:	je     9b00 <SyS_mknod+0x1c0>
    9a4b:	cmp    $0xc000,%ax
    9a4f:	nop
    9a50:	je     9a8b <SyS_mknod+0x14b>
    9a52:	cmp    $0x6000,%ax
    9a56:	je     9b20 <SyS_mknod+0x1e0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3478
	unsigned int lookup_flags = LOOKUP_DIRECTORY;

retry:
	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    9a5c:	lea    -0x38(%rbp),%rdi
    9a60:	mov    %r15,%rsi
    9a63:	callq  9a68 <SyS_mknod+0x128>
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    9a68:	add    $0x20,%rsp
SYSC_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3478
	unsigned int lookup_flags = LOOKUP_DIRECTORY;

retry:
	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    9a6c:	xor    %eax,%eax
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    9a6e:	pop    %rbx
    9a6f:	pop    %r12
    9a71:	pop    %r13
    9a73:	pop    %r14
    9a75:	pop    %r15
    9a77:	pop    %rbp
    9a78:	retq   
    9a79:	nopl   0x0(%rax)
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3465
		return -EMLINK;

	error = dir->i_op->mkdir(dir, dentry, mode);
	if (!error)
		fsnotify_mkdir(dir, dentry);
	return error;
    9a80:	test   %ax,%ax
    9a83:	je     9b00 <SyS_mknod+0x1c0>
    9a85:	cmp    $0x1000,%ax
    9a89:	jne    9a5c <SyS_mknod+0x11c>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3474
{
	struct dentry *dentry;
	struct path path;
	int error;
	unsigned int lookup_flags = LOOKUP_DIRECTORY;

    9a8b:	mov    -0x30(%rbp),%rax
    9a8f:	xor    %ecx,%ecx
    9a91:	mov    %r14d,%edx
    9a94:	mov    %r15,%rsi
    9a97:	mov    0x30(%rax),%rdi
    9a9b:	callq  9aa0 <SyS_mknod+0x160>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3478
retry:
	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
	if (IS_ERR(dentry))
		return PTR_ERR(dentry);
    9aa0:	lea    -0x38(%rbp),%rdi
    9aa4:	mov    %r15,%rsi
    9aa7:	mov    %eax,-0x3c(%rbp)
    9aaa:	callq  9aaf <SyS_mknod+0x16f>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9aaf:	movslq -0x3c(%rbp),%rax
    9ab3:	cmp    $0xffffff8c,%eax
    9ab6:	jne    9990 <SyS_mknod+0x50>
    9abc:	test   %r12d,%r12d
    9abf:	jne    9ae0 <SyS_mknod+0x1a0>
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3480

	if (!IS_POSIXACL(path.dentry->d_inode))
    9ac1:	mov    $0x20,%r12b
    9ac4:	jmpq   99e0 <SyS_mknod+0xa0>
    9ac9:	nopl   0x0(%rax)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3461
	if (error)
		return error;

	if (max_links && dir->i_nlink >= max_links)
		return -EMLINK;

    9ad0:	callq  9ad5 <SyS_mknod+0x195>
    9ad5:	not    %eax
    9ad7:	and    %eax,%ebx
    9ad9:	jmpq   9a15 <SyS_mknod+0xd5>
    9ade:	xchg   %ax,%ax
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
		mode &= ~current_umask();
	error = security_path_mkdir(&path, dentry, mode);
	if (!error)
		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
    9ae0:	add    $0x20,%rsp
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9ae4:	mov    $0xffffffffffffff8c,%rax
SyS_mknod():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3486
    9aeb:	pop    %rbx
    9aec:	pop    %r12
    9aee:	pop    %r13
    9af0:	pop    %r14
    9af2:	pop    %r15
    9af4:	pop    %rbp
    9af5:	retq   
    9af6:	nopw   %cs:0x0(%rax,%rax,1)
SYSC_mknodat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3467
	error = dir->i_op->mkdir(dir, dentry, mode);
	if (!error)
		fsnotify_mkdir(dir, dentry);
	return error;
}

    9b00:	mov    -0x30(%rbp),%rax
    9b04:	mov    $0x1,%ecx
    9b09:	mov    %r14d,%edx
    9b0c:	mov    %r15,%rsi
    9b0f:	mov    0x30(%rax),%rdi
    9b13:	callq  9b18 <SyS_mknod+0x1d8>
    9b18:	jmp    9aa0 <SyS_mknod+0x160>
    9b1a:	nopw   0x0(%rax,%rax,1)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3470
SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
{
	struct dentry *dentry;
    9b20:	mov    -0x30(%rbp),%rax
    9b24:	mov    -0x44(%rbp),%ecx
    9b27:	mov    %r14d,%edx
    9b2a:	mov    %r15,%rsi
    9b2d:	mov    0x30(%rax),%rdi
    9b31:	callq  9b36 <SyS_mknod+0x1f6>
    9b36:	jmpq   9aa0 <SyS_mknod+0x160>
SyS_mknod():
    9b3b:	nopl   0x0(%rax,%rax,1)

0000000000009b40 <SyS_mkdirat>:
SyS_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3516
 * that is still in use by something else..
 */
void dentry_unhash(struct dentry *dentry)
{
	shrink_dcache_parent(dentry);
	spin_lock(&dentry->d_lock);
    9b40:	callq  9b45 <SyS_mkdirat+0x5>
    9b45:	push   %rbp
    9b46:	mov    %rsp,%rbp
    9b49:	push   %r15
    9b4b:	push   %r14
    9b4d:	push   %r13
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3521
	if (dentry->d_lockref.count == 1)
		__d_drop(dentry);
	spin_unlock(&dentry->d_lock);
}

    9b4f:	mov    $0x2,%r13d
SyS_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3516
 * that is still in use by something else..
 */
void dentry_unhash(struct dentry *dentry)
{
	shrink_dcache_parent(dentry);
	spin_lock(&dentry->d_lock);
    9b55:	push   %r12
    9b57:	mov    %edx,%r12d
    9b5a:	push   %rbx
    9b5b:	sub    $0x20,%rsp
    9b5f:	mov    %rsi,-0x48(%rbp)
    9b63:	mov    %edi,-0x3c(%rbp)
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3524
	spin_unlock(&dentry->d_lock);
}

int vfs_rmdir(struct inode *dir, struct dentry *dentry)
{
	int error = may_delete(dir, dentry, 1);
    9b66:	mov    -0x48(%rbp),%rsi
    9b6a:	mov    -0x3c(%rbp),%edi
    9b6d:	lea    -0x38(%rbp),%rdx
    9b71:	mov    %r13d,%ecx
    9b74:	callq  9b79 <SyS_mkdirat+0x39>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3525

    9b79:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3524
	spin_unlock(&dentry->d_lock);
}

int vfs_rmdir(struct inode *dir, struct dentry *dentry)
{
	int error = may_delete(dir, dentry, 1);
    9b7f:	mov    %rax,%r15
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3525

    9b82:	ja     9bc4 <SyS_mkdirat+0x84>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3528
	if (error)
		return error;

    9b84:	mov    -0x30(%rbp),%rax
    9b88:	mov    0x30(%rax),%rax
    9b8c:	mov    0x28(%rax),%rax
    9b90:	testb  $0x1,0x52(%rax)
    9b94:	je     9bf0 <SyS_mkdirat+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3530
	if (!dir->i_op->rmdir)
		return -EPERM;
    9b96:	movzwl %r12w,%ebx
    9b9a:	lea    -0x38(%rbp),%rdi
    9b9e:	mov    %r15,%rsi
    9ba1:	mov    %ebx,%edx
    9ba3:	callq  9ba8 <SyS_mkdirat+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3531

    9ba8:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3530

	if (error)
		return error;

	if (!dir->i_op->rmdir)
		return -EPERM;
    9baa:	mov    %eax,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3531

    9bad:	je     9bd8 <SyS_mkdirat+0x98>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3533
	dget(dentry);
	mutex_lock(&dentry->d_inode->i_mutex);
    9baf:	lea    -0x38(%rbp),%rdi
    9bb3:	mov    %r15,%rsi
    9bb6:	callq  9bbb <SyS_mkdirat+0x7b>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9bbb:	cmp    $0xffffff8c,%r14d
    9bbf:	je     9c00 <SyS_mkdirat+0xc0>
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3538

	error = -EBUSY;
	if (d_mountpoint(dentry))
		goto out;

    9bc1:	movslq %r14d,%rax
SyS_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3516
 * that is still in use by something else..
 */
void dentry_unhash(struct dentry *dentry)
{
	shrink_dcache_parent(dentry);
	spin_lock(&dentry->d_lock);
    9bc4:	add    $0x20,%rsp
    9bc8:	pop    %rbx
    9bc9:	pop    %r12
    9bcb:	pop    %r13
    9bcd:	pop    %r14
    9bcf:	pop    %r15
    9bd1:	pop    %rbp
    9bd2:	retq   
    9bd3:	nopl   0x0(%rax,%rax,1)
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3532
		return error;

	if (!dir->i_op->rmdir)
		return -EPERM;

	dget(dentry);
    9bd8:	mov    -0x30(%rbp),%rax
    9bdc:	mov    %ebx,%edx
    9bde:	mov    %r15,%rsi
    9be1:	mov    0x30(%rax),%rdi
    9be5:	callq  9bea <SyS_mkdirat+0xaa>
    9bea:	mov    %eax,%r14d
    9bed:	jmp    9baf <SyS_mkdirat+0x6f>
    9bef:	nop
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3529
	int error = may_delete(dir, dentry, 1);

	if (error)
		return error;

	if (!dir->i_op->rmdir)
    9bf0:	callq  9bf5 <SyS_mkdirat+0xb5>
    9bf5:	not    %eax
    9bf7:	and    %eax,%r12d
    9bfa:	jmp    9b96 <SyS_mkdirat+0x56>
    9bfc:	nopl   0x0(%rax)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9c00:	and    $0x20,%r13d
    9c04:	jne    9bc1 <SyS_mkdirat+0x81>
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3535
		return -EPERM;

	dget(dentry);
	mutex_lock(&dentry->d_inode->i_mutex);

	error = -EBUSY;
    9c06:	mov    $0x22,%r13d
    9c0c:	jmpq   9b66 <SyS_mkdirat+0x26>
SyS_mkdirat():
    9c11:	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000009c20 <SyS_mkdir>:
SyS_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3541
	if (d_mountpoint(dentry))
		goto out;

	error = security_inode_rmdir(dir, dentry);
	if (error)
		goto out;
    9c20:	callq  9c25 <SyS_mkdir+0x5>
    9c25:	push   %rbp
    9c26:	mov    %rsp,%rbp
    9c29:	push   %r15
    9c2b:	push   %r14
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3521
	spin_lock(&dentry->d_lock);
	if (dentry->d_lockref.count == 1)
		__d_drop(dentry);
	spin_unlock(&dentry->d_lock);
}

    9c2d:	mov    $0x2,%r14d
SyS_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3541
	if (d_mountpoint(dentry))
		goto out;

	error = security_inode_rmdir(dir, dentry);
	if (error)
		goto out;
    9c33:	push   %r13
    9c35:	mov    %esi,%r13d
    9c38:	push   %r12
    9c3a:	push   %rbx
    9c3b:	sub    $0x18,%rsp
    9c3f:	mov    %rdi,-0x40(%rbp)
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3524
	spin_unlock(&dentry->d_lock);
}

int vfs_rmdir(struct inode *dir, struct dentry *dentry)
{
	int error = may_delete(dir, dentry, 1);
    9c43:	mov    -0x40(%rbp),%rsi
    9c47:	lea    -0x38(%rbp),%rdx
    9c4b:	mov    %r14d,%ecx
    9c4e:	mov    $0xffffff9c,%edi
    9c53:	callq  9c58 <SyS_mkdir+0x38>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3525

    9c58:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3524
	spin_unlock(&dentry->d_lock);
}

int vfs_rmdir(struct inode *dir, struct dentry *dentry)
{
	int error = may_delete(dir, dentry, 1);
    9c5e:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3525

    9c61:	ja     9ca4 <SyS_mkdir+0x84>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3528
	if (error)
		return error;

    9c63:	mov    -0x30(%rbp),%rax
    9c67:	mov    0x30(%rax),%rax
    9c6b:	mov    0x28(%rax),%rax
    9c6f:	testb  $0x1,0x52(%rax)
    9c73:	je     9cd0 <SyS_mkdir+0xb0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3530
	if (!dir->i_op->rmdir)
		return -EPERM;
    9c75:	movzwl %r13w,%r12d
    9c79:	lea    -0x38(%rbp),%rdi
    9c7d:	mov    %rbx,%rsi
    9c80:	mov    %r12d,%edx
    9c83:	callq  9c88 <SyS_mkdir+0x68>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3531

    9c88:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3530

	if (error)
		return error;

	if (!dir->i_op->rmdir)
		return -EPERM;
    9c8a:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3531

    9c8d:	je     9cb8 <SyS_mkdir+0x98>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3533
	dget(dentry);
	mutex_lock(&dentry->d_inode->i_mutex);
    9c8f:	lea    -0x38(%rbp),%rdi
    9c93:	mov    %rbx,%rsi
    9c96:	callq  9c9b <SyS_mkdir+0x7b>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9c9b:	cmp    $0xffffff8c,%r15d
    9c9f:	je     9ce0 <SyS_mkdir+0xc0>
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3538

	error = -EBUSY;
	if (d_mountpoint(dentry))
		goto out;

    9ca1:	movslq %r15d,%rax
SyS_mkdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3541
	error = security_inode_rmdir(dir, dentry);
	if (error)
		goto out;
    9ca4:	add    $0x18,%rsp
    9ca8:	pop    %rbx
    9ca9:	pop    %r12
    9cab:	pop    %r13
    9cad:	pop    %r14
    9caf:	pop    %r15
    9cb1:	pop    %rbp
    9cb2:	retq   
    9cb3:	nopl   0x0(%rax,%rax,1)
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3532
		return error;

	if (!dir->i_op->rmdir)
		return -EPERM;

	dget(dentry);
    9cb8:	mov    -0x30(%rbp),%rax
    9cbc:	mov    %r12d,%edx
    9cbf:	mov    %rbx,%rsi
    9cc2:	mov    0x30(%rax),%rdi
    9cc6:	callq  9ccb <SyS_mkdir+0xab>
    9ccb:	mov    %eax,%r15d
    9cce:	jmp    9c8f <SyS_mkdir+0x6f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3529
	int error = may_delete(dir, dentry, 1);

	if (error)
		return error;

	if (!dir->i_op->rmdir)
    9cd0:	callq  9cd5 <SyS_mkdir+0xb5>
    9cd5:	not    %eax
    9cd7:	and    %eax,%r13d
    9cda:	jmp    9c75 <SyS_mkdir+0x55>
    9cdc:	nopl   0x0(%rax)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9ce0:	and    $0x20,%r14d
    9ce4:	jne    9ca1 <SyS_mkdir+0x81>
SYSC_mkdirat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3535
		return -EPERM;

	dget(dentry);
	mutex_lock(&dentry->d_inode->i_mutex);

	error = -EBUSY;
    9ce6:	mov    $0x22,%r14d
    9cec:	jmpq   9c43 <SyS_mkdir+0x23>
sys_mkdir():
    9cf1:	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000009d00 <SyS_rmdir>:
SyS_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3664
			error = dir->i_op->unlink(dir, dentry);
			if (!error)
				dont_mount(dentry);
		}
	}
out:
    9d00:	callq  9d05 <SyS_rmdir+0x5>
    9d05:	push   %rbp
    9d06:	mov    %rdi,%rsi
SYSC_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3666
	mutex_unlock(&target->i_mutex);

    9d09:	mov    $0xffffff9c,%edi
SyS_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3664
			error = dir->i_op->unlink(dir, dentry);
			if (!error)
				dont_mount(dentry);
		}
	}
out:
    9d0e:	mov    %rsp,%rbp
SYSC_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3666
	mutex_unlock(&target->i_mutex);

    9d11:	callq  5570 <do_rmdir>
SyS_rmdir():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3664
			error = dir->i_op->unlink(dir, dentry);
			if (!error)
				dont_mount(dentry);
		}
	}
out:
    9d16:	pop    %rbp
    9d17:	retq   
    9d18:	nopl   0x0(%rax,%rax,1)

0000000000009d20 <SyS_unlinkat>:
SyS_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3801
	unsigned int lookup_flags = 0;

	from = getname(oldname);
	if (IS_ERR(from))
		return PTR_ERR(from);
retry:
    9d20:	callq  9d25 <SyS_unlinkat+0x5>
SYSC_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3803
	dentry = user_path_create(newdfd, newname, &path, lookup_flags);
	error = PTR_ERR(dentry);
    9d25:	test   $0xfffffdff,%edx
    9d2b:	jne    9d50 <SyS_unlinkat+0x30>
SyS_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3801
	unsigned int lookup_flags = 0;

	from = getname(oldname);
	if (IS_ERR(from))
		return PTR_ERR(from);
retry:
    9d2d:	push   %rbp
SYSC_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3806
	dentry = user_path_create(newdfd, newname, &path, lookup_flags);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out_putname;

    9d2e:	and    $0x2,%dh
SyS_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3801
	unsigned int lookup_flags = 0;

	from = getname(oldname);
	if (IS_ERR(from))
		return PTR_ERR(from);
retry:
    9d31:	mov    %rsp,%rbp
SYSC_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3806
	dentry = user_path_create(newdfd, newname, &path, lookup_flags);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out_putname;

    9d34:	jne    9d40 <SyS_unlinkat+0x20>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3809
	error = security_path_symlink(&path, dentry, from->name);
	if (!error)
		error = vfs_symlink(path.dentry->d_inode, dentry, from->name);
    9d36:	callq  58a0 <do_unlinkat>
SyS_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3801
	unsigned int lookup_flags = 0;

	from = getname(oldname);
	if (IS_ERR(from))
		return PTR_ERR(from);
retry:
    9d3b:	pop    %rbp
    9d3c:	retq   
    9d3d:	nopl   (%rax)
SYSC_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3807
	dentry = user_path_create(newdfd, newname, &path, lookup_flags);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out_putname;

	error = security_path_symlink(&path, dentry, from->name);
    9d40:	callq  5570 <do_rmdir>
SyS_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3801
	unsigned int lookup_flags = 0;

	from = getname(oldname);
	if (IS_ERR(from))
		return PTR_ERR(from);
retry:
    9d45:	pop    %rbp
    9d46:	retq   
    9d47:	nopw   0x0(%rax,%rax,1)
SYSC_unlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3804
	dentry = user_path_create(newdfd, newname, &path, lookup_flags);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
    9d50:	mov    $0xffffffffffffffea,%rax
    9d57:	retq   
SyS_unlinkat():
    9d58:	nopl   0x0(%rax,%rax,1)

0000000000009d60 <SyS_unlink>:
SyS_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3812
	error = security_path_symlink(&path, dentry, from->name);
	if (!error)
		error = vfs_symlink(path.dentry->d_inode, dentry, from->name);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
    9d60:	callq  9d65 <SyS_unlink+0x5>
    9d65:	push   %rbp
    9d66:	mov    %rdi,%rsi
SYSC_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3814
		goto retry;
	}
    9d69:	mov    $0xffffff9c,%edi
SyS_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3812
	error = security_path_symlink(&path, dentry, from->name);
	if (!error)
		error = vfs_symlink(path.dentry->d_inode, dentry, from->name);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
    9d6e:	mov    %rsp,%rbp
SYSC_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3814
		goto retry;
	}
    9d71:	callq  58a0 <do_unlinkat>
SyS_unlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3812
	error = security_path_symlink(&path, dentry, from->name);
	if (!error)
		error = vfs_symlink(path.dentry->d_inode, dentry, from->name);
	done_path_create(&path, dentry);
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
    9d76:	pop    %rbp
    9d77:	retq   
    9d78:	nopl   0x0(%rax,%rax,1)

0000000000009d80 <SyS_symlinkat>:
SyS_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3837
 * The caller must hold dir->i_mutex
 *
 * If vfs_link discovers a delegation on the to-be-linked file in need
 * of breaking, it will return -EWOULDBLOCK and return a reference to the
 * inode in delegated_inode.  The caller should then break the delegation
 * and retry.  Because breaking a delegation may take a long time, the
    9d80:	callq  9d85 <SyS_symlinkat+0x5>
    9d85:	push   %rbp
    9d86:	mov    %rsp,%rbp
    9d89:	push   %r15
    9d8b:	mov    %esi,%r15d
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    9d8e:	xor    %esi,%esi
SyS_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3837
 * The caller must hold dir->i_mutex
 *
 * If vfs_link discovers a delegation on the to-be-linked file in need
 * of breaking, it will return -EWOULDBLOCK and return a reference to the
 * inode in delegated_inode.  The caller should then break the delegation
 * and retry.  Because breaking a delegation may take a long time, the
    9d90:	push   %r14
    9d92:	push   %r13
    9d94:	push   %r12
    9d96:	push   %rbx
    9d97:	sub    $0x18,%rsp
    9d9b:	mov    %rdx,-0x40(%rbp)
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    9d9f:	xor    %edx,%edx
    9da1:	callq  2290 <getname_flags>
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3847
 * to be NFS exported.
 */
int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)
{
	struct inode *inode = old_dentry->d_inode;
	unsigned max_links = dir->i_sb->s_max_links;
    9da6:	cmp    $0xfffffffffffff000,%rax
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    9dac:	mov    %rax,%r13
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3847
 * to be NFS exported.
 */
int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)
{
	struct inode *inode = old_dentry->d_inode;
	unsigned max_links = dir->i_sb->s_max_links;
    9daf:	ja     9e5e <SyS_symlinkat+0xde>
    9db5:	xor    %r12d,%r12d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3850
	int error;

	if (!inode)
    9db8:	mov    -0x40(%rbp),%rsi
    9dbc:	lea    -0x38(%rbp),%rdx
    9dc0:	mov    %r12d,%ecx
    9dc3:	mov    %r15d,%edi
    9dc6:	callq  9dcb <SyS_symlinkat+0x4b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3852
		return -ENOENT;

    9dcb:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3850
{
	struct inode *inode = old_dentry->d_inode;
	unsigned max_links = dir->i_sb->s_max_links;
	int error;

	if (!inode)
    9dd1:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3852
		return -ENOENT;

    9dd4:	ja     9e59 <SyS_symlinkat+0xd9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3855
	error = may_create(dir, new_dentry);
	if (error)
		return error;
    9dda:	mov    0x0(%r13),%rdx
    9dde:	lea    -0x38(%rbp),%rdi
    9de2:	mov    %rax,%rsi
    9de5:	callq  9dea <SyS_symlinkat+0x6a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3856

    9dea:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3855
	if (!inode)
		return -ENOENT;

	error = may_create(dir, new_dentry);
	if (error)
		return error;
    9dec:	mov    %eax,%r14d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3856

    9def:	je     9e20 <SyS_symlinkat+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3858
	if (dir->i_sb != inode->i_sb)
		return -EXDEV;
    9df1:	lea    -0x38(%rbp),%rdi
    9df5:	mov    %rbx,%rsi
    9df8:	callq  9dfd <SyS_symlinkat+0x7d>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9dfd:	cmp    $0xffffff8c,%r14d
    9e01:	je     9e40 <SyS_symlinkat+0xc0>
    9e03:	movslq %r14d,%rbx
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3864

	/*
	 * A link to an append-only or immutable file cannot be created.
	 */
	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
		return -EPERM;
    9e06:	mov    %r13,%rdi
    9e09:	callq  9e0e <SyS_symlinkat+0x8e>
SyS_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3837
 * The caller must hold dir->i_mutex
 *
 * If vfs_link discovers a delegation on the to-be-linked file in need
 * of breaking, it will return -EWOULDBLOCK and return a reference to the
 * inode in delegated_inode.  The caller should then break the delegation
 * and retry.  Because breaking a delegation may take a long time, the
    9e0e:	add    $0x18,%rsp
    9e12:	mov    %rbx,%rax
    9e15:	pop    %rbx
    9e16:	pop    %r12
    9e18:	pop    %r13
    9e1a:	pop    %r14
    9e1c:	pop    %r15
    9e1e:	pop    %rbp
    9e1f:	retq   
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3857

	error = may_create(dir, new_dentry);
	if (error)
		return error;

	if (dir->i_sb != inode->i_sb)
    9e20:	mov    -0x30(%rbp),%rax
    9e24:	mov    0x0(%r13),%rdx
    9e28:	mov    %rbx,%rsi
    9e2b:	mov    0x30(%rax),%rdi
    9e2f:	callq  9e34 <SyS_symlinkat+0xb4>
    9e34:	mov    %eax,%r14d
    9e37:	jmp    9df1 <SyS_symlinkat+0x71>
    9e39:	nopl   0x0(%rax)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9e40:	test   %r12d,%r12d
    9e43:	jne    9e50 <SyS_symlinkat+0xd0>
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3860
		return -EXDEV;

	/*
    9e45:	mov    $0x20,%r12b
    9e48:	jmpq   9db8 <SyS_symlinkat+0x38>
    9e4d:	nopl   (%rax)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9e50:	mov    $0xffffffffffffff8c,%rbx
    9e57:	jmp    9e06 <SyS_symlinkat+0x86>
    9e59:	movslq %eax,%rbx
    9e5c:	jmp    9e06 <SyS_symlinkat+0x86>
PTR_ERR():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/err.h:29
    9e5e:	mov    %rax,%rbx
    9e61:	jmp    9e0e <SyS_symlinkat+0x8e>
SyS_symlinkat():
    9e63:	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000009e70 <SyS_symlink>:
SyS_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3868
	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
		return -EPERM;
	if (!dir->i_op->link)
		return -EPERM;
	if (S_ISDIR(inode->i_mode))
		return -EPERM;
    9e70:	callq  9e75 <SyS_symlink+0x5>
    9e75:	push   %rbp
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    9e76:	xor    %edx,%edx
SyS_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3868
	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
		return -EPERM;
	if (!dir->i_op->link)
		return -EPERM;
	if (S_ISDIR(inode->i_mode))
		return -EPERM;
    9e78:	mov    %rsp,%rbp
    9e7b:	push   %r15
    9e7d:	mov    %rsi,%r15
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    9e80:	xor    %esi,%esi
SyS_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3868
	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
		return -EPERM;
	if (!dir->i_op->link)
		return -EPERM;
	if (S_ISDIR(inode->i_mode))
		return -EPERM;
    9e82:	push   %r14
    9e84:	push   %r13
    9e86:	push   %r12
    9e88:	push   %rbx
    9e89:	sub    $0x10,%rsp
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    9e8d:	callq  2290 <getname_flags>
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3847
 * to be NFS exported.
 */
int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)
{
	struct inode *inode = old_dentry->d_inode;
	unsigned max_links = dir->i_sb->s_max_links;
    9e92:	cmp    $0xfffffffffffff000,%rax
getname():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:223

struct filename *getname(const char __user * filename)
{
	return getname_flags(filename, 0, NULL);
}
EXPORT_SYMBOL(getname);
    9e98:	mov    %rax,%r14
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3847
 * to be NFS exported.
 */
int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)
{
	struct inode *inode = old_dentry->d_inode;
	unsigned max_links = dir->i_sb->s_max_links;
    9e9b:	ja     9f4e <SyS_symlink+0xde>
    9ea1:	xor    %r13d,%r13d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3850
	int error;

	if (!inode)
    9ea4:	lea    -0x38(%rbp),%rdx
    9ea8:	mov    %r13d,%ecx
    9eab:	mov    %r15,%rsi
    9eae:	mov    $0xffffff9c,%edi
    9eb3:	callq  9eb8 <SyS_symlink+0x48>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3852
		return -ENOENT;

    9eb8:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3850
{
	struct inode *inode = old_dentry->d_inode;
	unsigned max_links = dir->i_sb->s_max_links;
	int error;

	if (!inode)
    9ebe:	mov    %rax,%rbx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3852
		return -ENOENT;

    9ec1:	ja     9f49 <SyS_symlink+0xd9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3855
	error = may_create(dir, new_dentry);
	if (error)
		return error;
    9ec7:	mov    (%r14),%rdx
    9eca:	lea    -0x38(%rbp),%rdi
    9ece:	mov    %rax,%rsi
    9ed1:	callq  9ed6 <SyS_symlink+0x66>
    9ed6:	movslq %eax,%r12
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3856

    9ed9:	test   %r12d,%r12d
    9edc:	je     9f10 <SyS_symlink+0xa0>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3858
	if (dir->i_sb != inode->i_sb)
		return -EXDEV;
    9ede:	lea    -0x38(%rbp),%rdi
    9ee2:	mov    %rbx,%rsi
    9ee5:	callq  9eea <SyS_symlink+0x7a>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9eea:	cmp    $0xffffff8c,%r12d
    9eee:	je     9f30 <SyS_symlink+0xc0>
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3864

	/*
	 * A link to an append-only or immutable file cannot be created.
	 */
	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
		return -EPERM;
    9ef0:	mov    %r14,%rdi
    9ef3:	callq  9ef8 <SyS_symlink+0x88>
SyS_symlink():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3868
	if (!dir->i_op->link)
		return -EPERM;
	if (S_ISDIR(inode->i_mode))
		return -EPERM;
    9ef8:	add    $0x10,%rsp
    9efc:	mov    %r12,%rax
    9eff:	pop    %rbx
    9f00:	pop    %r12
    9f02:	pop    %r13
    9f04:	pop    %r14
    9f06:	pop    %r15
    9f08:	pop    %rbp
    9f09:	retq   
    9f0a:	nopw   0x0(%rax,%rax,1)
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3857

	error = may_create(dir, new_dentry);
	if (error)
		return error;

	if (dir->i_sb != inode->i_sb)
    9f10:	mov    -0x30(%rbp),%rax
    9f14:	mov    (%r14),%rdx
    9f17:	mov    %rbx,%rsi
    9f1a:	mov    0x30(%rax),%rdi
    9f1e:	callq  9f23 <SyS_symlink+0xb3>
    9f23:	movslq %eax,%r12
    9f26:	jmp    9ede <SyS_symlink+0x6e>
    9f28:	nopl   0x0(%rax,%rax,1)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9f30:	test   %r13d,%r13d
    9f33:	jne    9f40 <SyS_symlink+0xd0>
SYSC_symlinkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3860
		return -EXDEV;

	/*
    9f35:	mov    $0x20,%r13b
    9f38:	jmpq   9ea4 <SyS_symlink+0x34>
    9f3d:	nopl   (%rax)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    9f40:	mov    $0xffffffffffffff8c,%r12
    9f47:	jmp    9ef0 <SyS_symlink+0x80>
    9f49:	movslq %eax,%r12
    9f4c:	jmp    9ef0 <SyS_symlink+0x80>
PTR_ERR():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/err.h:29
    9f4e:	mov    %rax,%r12
    9f51:	jmp    9ef8 <SyS_symlink+0x88>
SyS_symlink():
    9f53:	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)

0000000000009f60 <SyS_linkat>:
SyS_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3954
		goto out_dput;
	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
out_dput:
	done_path_create(&new_path, new_dentry);
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
    9f60:	callq  9f65 <SyS_linkat+0x5>
    9f65:	push   %rbp
    9f66:	mov    %rsp,%rbp
    9f69:	push   %r15
    9f6b:	push   %r14
    9f6d:	push   %r13
    9f6f:	push   %r12
    9f71:	push   %rbx
    9f72:	sub    $0x50,%rsp
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3963
	if (retry_estale(error, how)) {
		how |= LOOKUP_REVAL;
		goto retry;
	}
out:
	path_put(&old_path);
    9f76:	test   $0xffffebff,%r8d
SyS_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3954
		goto out_dput;
	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
out_dput:
	done_path_create(&new_path, new_dentry);
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
    9f7d:	mov    %rcx,-0x60(%rbp)
    9f81:	mov    %edx,-0x58(%rbp)
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3959
		if (!error)
			goto retry;
	}
	if (retry_estale(error, how)) {
		how |= LOOKUP_REVAL;
    9f84:	movq   $0x0,-0x50(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3963
		goto retry;
	}
out:
	path_put(&old_path);
    9f8c:	jne    a268 <SyS_linkat+0x308>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3960
		if (!error)
			goto retry;
	}
	if (retry_estale(error, how)) {
		how |= LOOKUP_REVAL;
		goto retry;
    9f92:	xor    %ebx,%ebx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3970
	return error;
}

SYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)
{
	return sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
    9f94:	test   $0x1000,%r8d
    9f9b:	mov    %rsi,%r14
    9f9e:	mov    %edi,%r13d
    9fa1:	jne    a1e8 <SyS_linkat+0x288>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3977

/*
 * The worst of all namespace operations - renaming directory. "Perverted"
 * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
 * Problems:
 *	a) we can get into loop creation. Check is done in is_subdir().
    9fa7:	mov    %ebx,%eax
    9fa9:	or     $0x1,%eax
    9fac:	test   $0x400,%r8d
    9fb3:	cmovne %eax,%ebx
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    9fb6:	mov    %gs:0x0,%rax
    9fbf:	mov    %rax,-0x68(%rbp)
    9fc3:	mov    %rax,-0x78(%rbp)
    9fc7:	nopw   0x0(%rax,%rax,1)
user_path_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2154
	/* only LOOKUP_REVAL is allowed in extra flags */
	flags &= LOOKUP_REVAL;

	if (IS_ERR(s))
		return s;

    9fd0:	lea    -0x48(%rbp),%rcx
    9fd4:	xor    %r8d,%r8d
    9fd7:	mov    %ebx,%edx
    9fd9:	mov    %r14,%rsi
    9fdc:	mov    %r13d,%edi
    9fdf:	callq  9fe4 <SyS_linkat+0x84>
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3980
 * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
 * Problems:
 *	a) we can get into loop creation. Check is done in is_subdir().
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
    9fe4:	test   %eax,%eax
    9fe6:	jne    a1b0 <SyS_linkat+0x250>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3983
 *	   story.
 *	c) we have to lock _four_ objects - parents and victim (if it exists),
 *	   and source (if it is not a directory).
    9fec:	mov    %ebx,%r12d
    9fef:	mov    -0x60(%rbp),%rsi
    9ff3:	mov    -0x58(%rbp),%edi
    9ff6:	and    $0x20,%r12d
    9ffa:	lea    -0x38(%rbp),%rdx
    9ffe:	mov    %r12d,%ecx
    a001:	callq  a006 <SyS_linkat+0xa6>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3986
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
    a006:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3983
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 *	   story.
 *	c) we have to lock _four_ objects - parents and victim (if it exists),
 *	   and source (if it is not a directory).
    a00c:	mov    %rax,%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3986
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
    a00f:	ja     a280 <SyS_linkat+0x320>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3990
 *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 *	   move will be locked.  Thus we can rank directories by the tree
 *	   (ancestors first) and rank all non-directories after them.
 *	   That works since everybody except rename does "lock parent, lookup,
    a015:	mov    -0x38(%rbp),%rax
    a019:	cmp    %rax,-0x48(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3989
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
 *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 *	   move will be locked.  Thus we can rank directories by the tree
 *	   (ancestors first) and rank all non-directories after them.
    a01d:	mov    $0xffffffee,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3990
 *	   That works since everybody except rename does "lock parent, lookup,
    a023:	je     a0e0 <SyS_linkat+0x180>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4000
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
 *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 *	   ->i_mutex on parents, which works but leads to some truly excessive
 *	   locking].
 */
    a029:	lea    -0x38(%rbp),%rdi
    a02d:	mov    %r8,%rsi
    a030:	callq  a035 <SyS_linkat+0xd5>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4001
static int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
    a035:	mov    -0x50(%rbp),%rdi
    a039:	test   %rdi,%rdi
    a03c:	je     a074 <SyS_linkat+0x114>
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    a03e:	cmpq   $0x0,0x148(%rdi)
    a046:	je     a0c0 <SyS_linkat+0x160>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    a048:	mov    $0x4,%edx
    a04d:	mov    $0x1,%esi
    a052:	callq  a057 <SyS_linkat+0xf7>
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    a057:	mov    -0x50(%rbp),%rdi
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
		return __break_lease(inode, mode, FL_DELEG);
    a05b:	mov    %eax,%r15d
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    a05e:	callq  a063 <SyS_linkat+0x103>
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4003
{
	int error = 0;
    a063:	test   %r15d,%r15d
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    a066:	movq   $0x0,-0x50(%rbp)
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4003
    a06e:	je     9fd0 <SyS_linkat+0x70>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    a074:	cmp    $0xffffff8c,%r15d
    a078:	je     a0b0 <SyS_linkat+0x150>
    a07a:	movslq %r15d,%rax
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    a07d:	mov    -0x40(%rbp),%rdi
    a081:	mov    %rax,-0x58(%rbp)
    a085:	callq  a08a <SyS_linkat+0x12a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    a08a:	mov    -0x48(%rbp),%rdi
    a08e:	callq  a093 <SyS_linkat+0x133>
    a093:	mov    -0x58(%rbp),%rax
SyS_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3954
		goto out_dput;
	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
out_dput:
	done_path_create(&new_path, new_dentry);
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
    a097:	add    $0x50,%rsp
    a09b:	pop    %rbx
    a09c:	pop    %r12
    a09e:	pop    %r13
    a0a0:	pop    %r14
    a0a2:	pop    %r15
    a0a4:	pop    %rbp
    a0a5:	retq   
    a0a6:	nopw   %cs:0x0(%rax,%rax,1)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    a0b0:	test   %r12d,%r12d
    a0b3:	je     a0d8 <SyS_linkat+0x178>
    a0b5:	mov    $0xffffffffffffff8c,%rax
    a0bc:	jmp    a07d <SyS_linkat+0x11d>
    a0be:	xchg   %ax,%ax
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    a0c0:	callq  a0c5 <SyS_linkat+0x165>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    a0c5:	movq   $0x0,-0x50(%rbp)
    a0cd:	jmpq   9fd0 <SyS_linkat+0x70>
    a0d2:	nopw   0x0(%rax,%rax,1)
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4007
{
	int error = 0;
	struct inode *target = new_dentry->d_inode;
	unsigned max_links = new_dir->i_sb->s_max_links;

	/*
    a0d8:	or     $0x20,%ebx
    a0db:	jmpq   9fd0 <SyS_linkat+0x70>
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:810
	struct inode *inode;

	if (!sysctl_protected_hardlinks)
		return 0;

	cred = current_cred();
    a0e0:	mov    0x0(%rip),%ecx        # a0e6 <SyS_linkat+0x186>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a0e6:	mov    -0x68(%rbp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:810
	struct inode *inode;

	if (!sysctl_protected_hardlinks)
		return 0;

	cred = current_cred();
    a0ea:	test   %ecx,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a0ec:	lea    0x4a8(%rax),%rdx
    a0f3:	mov    $0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:810
	struct inode *inode;

	if (!sysctl_protected_hardlinks)
		return 0;

	cred = current_cred();
    a0fa:	jne    a108 <SyS_linkat+0x1a8>
    a0fc:	jmp    a163 <SyS_linkat+0x203>
    a0fe:	xchg   %ax,%ax
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    a100:	test   %cl,%cl
    a102:	je     a1c8 <SyS_linkat+0x268>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    a108:	add    $0x1,%rdx
    a10c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    a110:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    a114:	cmp    -0x1(%rax),%cl
    a117:	je     a100 <SyS_linkat+0x1a0>
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a119:	mov    -0x78(%rbp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:814
	 * otherwise, it must be a safe source.
    a11d:	mov    -0x40(%rbp),%rdi
    a121:	mov    0x4a0(%rdx),%rdx
    a128:	mov    0x30(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:819
	 */
	if (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||
	    capable(CAP_FOWNER))
		return 0;

    a12c:	mov    0x4(%rax),%esi
    a12f:	cmp    %esi,0x1c(%rdx)
    a132:	je     a167 <SyS_linkat+0x207>
safe_hardlink_source():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:772
static bool safe_hardlink_source(struct inode *inode)
{
	umode_t mode = inode->i_mode;

	/* Special files should not get pinned to the filesystem. */
	if (!S_ISREG(mode))
    a134:	movzwl (%rax),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:775
		return false;

	/* Setuid files should not get pinned to the filesystem. */
    a137:	mov    %edx,%ecx
    a139:	and    $0xf000,%cx
    a13e:	cmp    $0x8000,%cx
    a143:	je     a207 <SyS_linkat+0x2a7>
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:820
	 */
	if (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||
	    capable(CAP_FOWNER))
		return 0;

	audit_log_link_denied("linkat", link);
    a149:	mov    $0x3,%edi
    a14e:	mov    %r8,-0x70(%rbp)
    a152:	callq  a157 <SyS_linkat+0x1f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:819
	 * otherwise, it must be a safe source.
	 */
	if (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||
	    capable(CAP_FOWNER))
		return 0;

    a157:	test   %al,%al
    a159:	mov    -0x70(%rbp),%r8
    a15d:	je     a242 <SyS_linkat+0x2e2>
    a163:	mov    -0x40(%rbp),%rdi
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3995
 *	   That works since everybody except rename does "lock parent, lookup,
 *	   lock child" and rename is under ->s_vfs_rename_mutex.
 *	   HOWEVER, it relies on the assumption that any object with ->lookup()
 *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 *	   we'd better make sure that there's no link(2) for them.
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
    a167:	lea    -0x38(%rbp),%rsi
    a16b:	mov    %r8,%rdx
    a16e:	mov    %r8,-0x70(%rbp)
    a172:	callq  a177 <SyS_linkat+0x217>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3996
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
    a177:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3995
 *	   That works since everybody except rename does "lock parent, lookup,
 *	   lock child" and rename is under ->s_vfs_rename_mutex.
 *	   HOWEVER, it relies on the assumption that any object with ->lookup()
 *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 *	   we'd better make sure that there's no link(2) for them.
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
    a179:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3996
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
    a17c:	mov    -0x70(%rbp),%r8
    a180:	jne    a029 <SyS_linkat+0xc9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3998
 *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 *	   ->i_mutex on parents, which works but leads to some truly excessive
    a186:	mov    -0x30(%rbp),%rax
    a18a:	mov    -0x40(%rbp),%rdi
    a18e:	lea    -0x50(%rbp),%rcx
    a192:	mov    %r8,%rdx
    a195:	mov    %r8,-0x70(%rbp)
    a199:	mov    0x30(%rax),%rsi
    a19d:	callq  a1a2 <SyS_linkat+0x242>
    a1a2:	mov    -0x70(%rbp),%r8
    a1a6:	mov    %eax,%r15d
    a1a9:	jmpq   a029 <SyS_linkat+0xc9>
    a1ae:	xchg   %ax,%ax
SyS_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3954
		goto out_dput;
	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
out_dput:
	done_path_create(&new_path, new_dentry);
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
    a1b0:	add    $0x50,%rsp
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3981
 * Problems:
 *	a) we can get into loop creation. Check is done in is_subdir().
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 *	   story.
    a1b4:	cltq   
SyS_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3954
		goto out_dput;
	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
out_dput:
	done_path_create(&new_path, new_dentry);
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
    a1b6:	pop    %rbx
    a1b7:	pop    %r12
    a1b9:	pop    %r13
    a1bb:	pop    %r14
    a1bd:	pop    %r15
    a1bf:	pop    %rbp
    a1c0:	retq   
    a1c1:	nopl   0x0(%rax)
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
		return 0;

	cred = current_cred();
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a1c8:	cmpb   $0x0,0x0(%rip)        # a1cf <SyS_linkat+0x26f>
    a1cf:	mov    0x0(%rip),%rdx        # a1d6 <SyS_linkat+0x276>
    a1d6:	jne    a11d <SyS_linkat+0x1bd>
    a1dc:	jmpq   a119 <SyS_linkat+0x1b9>
    a1e1:	nopl   0x0(%rax)
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3971
}

SYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)
{
	return sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}
    a1e8:	mov    $0x2,%edi
    a1ed:	mov    %r8,-0x68(%rbp)
    a1f1:	callq  a1f6 <SyS_linkat+0x296>
    a1f6:	test   %al,%al
    a1f8:	je     a274 <SyS_linkat+0x314>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3973

/*
    a1fa:	mov    $0x4000,%bx
    a1fe:	mov    -0x68(%rbp),%r8
    a202:	jmpq   9fa7 <SyS_linkat+0x47>
safe_hardlink_source():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:779

	/* Setuid files should not get pinned to the filesystem. */
	if (mode & S_ISUID)
		return false;

	/* Executable setgid files should not get pinned to the filesystem. */
    a207:	test   $0x8,%dh
    a20a:	jne    a149 <SyS_linkat+0x1e9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:783
	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
		return false;

	/* Hardlinking to unreadable or unwritable sources is dangerous. */
    a210:	and    $0x408,%dx
    a215:	cmp    $0x408,%dx
    a21a:	je     a149 <SyS_linkat+0x1e9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:787
	if (inode_permission(inode, MAY_READ | MAY_WRITE))
		return false;

	return true;
    a220:	mov    $0x6,%esi
    a225:	mov    %rax,%rdi
    a228:	mov    %r8,-0x70(%rbp)
    a22c:	callq  a231 <SyS_linkat+0x2d1>
    a231:	test   %eax,%eax
    a233:	mov    -0x70(%rbp),%r8
    a237:	je     a163 <SyS_linkat+0x203>
    a23d:	jmpq   a149 <SyS_linkat+0x1e9>
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:823
		return 0;

	audit_log_link_denied("linkat", link);
	return -EPERM;
}

    a242:	lea    -0x48(%rbp),%rsi
    a246:	mov    $0x0,%rdi
    a24d:	mov    %r8,-0x70(%rbp)
    a251:	mov    $0xffffffff,%r15d
    a257:	callq  a25c <SyS_linkat+0x2fc>
    a25c:	mov    -0x70(%rbp),%r8
    a260:	jmpq   a029 <SyS_linkat+0xc9>
    a265:	nopl   (%rax)
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3964
		how |= LOOKUP_REVAL;
		goto retry;
	}
out:
	path_put(&old_path);

    a268:	mov    $0xffffffffffffffea,%rax
    a26f:	jmpq   a097 <SyS_linkat+0x137>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3972

SYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)
{
	return sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}

    a274:	mov    $0xfffffffffffffffe,%rax
    a27b:	jmpq   a097 <SyS_linkat+0x137>
    a280:	cltq   
    a282:	jmpq   a07d <SyS_linkat+0x11d>
SyS_linkat():
    a287:	nopw   0x0(%rax,%rax,1)

000000000000a290 <SyS_link>:
SyS_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4016
	if (new_dir != old_dir) {
		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
		if (error)
			return error;
	}

    a290:	callq  a295 <SyS_link+0x5>
    a295:	push   %rbp
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    a296:	mov    %gs:0x0,%rax
SyS_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4016
    a29f:	mov    %rsp,%rbp
    a2a2:	push   %r15
    a2a4:	push   %r14
    a2a6:	mov    %rsi,%r14
    a2a9:	push   %r13
    a2ab:	mov    %rdi,%r13
    a2ae:	push   %r12
SYSC_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3959
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry;
	}
	if (retry_estale(error, how)) {
		how |= LOOKUP_REVAL;
    a2b0:	xor    %r12d,%r12d
SyS_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4016
	if (new_dir != old_dir) {
		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
		if (error)
			return error;
	}

    a2b3:	push   %rbx
    a2b4:	sub    $0x40,%rsp
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3959
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry;
	}
	if (retry_estale(error, how)) {
		how |= LOOKUP_REVAL;
    a2b8:	movq   $0x0,-0x50(%rbp)
get_current():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:19
    a2c0:	mov    %rax,-0x58(%rbp)
    a2c4:	mov    %rax,-0x68(%rbp)
    a2c8:	nopl   0x0(%rax,%rax,1)
user_path_at():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2154
	/* only LOOKUP_REVAL is allowed in extra flags */
	flags &= LOOKUP_REVAL;

	if (IS_ERR(s))
		return s;

    a2d0:	lea    -0x48(%rbp),%rcx
    a2d4:	xor    %r8d,%r8d
    a2d7:	mov    %r12d,%edx
    a2da:	mov    %r13,%rsi
    a2dd:	mov    $0xffffff9c,%edi
    a2e2:	callq  a2e7 <SyS_link+0x57>
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3980
 * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
 * Problems:
 *	a) we can get into loop creation. Check is done in is_subdir().
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
    a2e7:	test   %eax,%eax
    a2e9:	jne    a4c0 <SyS_link+0x230>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3983
 *	   story.
 *	c) we have to lock _four_ objects - parents and victim (if it exists),
 *	   and source (if it is not a directory).
    a2ef:	mov    %r12d,%ebx
    a2f2:	lea    -0x38(%rbp),%rdx
    a2f6:	mov    %r14,%rsi
    a2f9:	and    $0x20,%ebx
    a2fc:	mov    $0xffffff9c,%edi
    a301:	mov    %ebx,%ecx
    a303:	callq  a308 <SyS_link+0x78>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3986
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
    a308:	cmp    $0xfffffffffffff000,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3983
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 *	   story.
 *	c) we have to lock _four_ objects - parents and victim (if it exists),
 *	   and source (if it is not a directory).
    a30e:	mov    %rax,%r8
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3986
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
    a311:	ja     a54f <SyS_link+0x2bf>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3990
 *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 *	   move will be locked.  Thus we can rank directories by the tree
 *	   (ancestors first) and rank all non-directories after them.
 *	   That works since everybody except rename does "lock parent, lookup,
    a317:	mov    -0x38(%rbp),%rax
    a31b:	cmp    %rax,-0x48(%rbp)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3989
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
 *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 *	   move will be locked.  Thus we can rank directories by the tree
 *	   (ancestors first) and rank all non-directories after them.
    a31f:	mov    $0xffffffee,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3990
 *	   That works since everybody except rename does "lock parent, lookup,
    a325:	je     a3e8 <SyS_link+0x158>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4000
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
 *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 *	   ->i_mutex on parents, which works but leads to some truly excessive
 *	   locking].
 */
    a32b:	lea    -0x38(%rbp),%rdi
    a32f:	mov    %r8,%rsi
    a332:	callq  a337 <SyS_link+0xa7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4001
static int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
    a337:	mov    -0x50(%rbp),%rdi
    a33b:	test   %rdi,%rdi
    a33e:	je     a376 <SyS_link+0xe6>
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1973
	return 0;
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
    a340:	cmpq   $0x0,0x148(%rdi)
    a348:	je     a3c0 <SyS_link+0x130>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
		return __break_lease(inode, mode, FL_DELEG);
    a34a:	mov    $0x4,%edx
    a34f:	mov    $0x1,%esi
    a354:	callq  a359 <SyS_link+0xc9>
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    a359:	mov    -0x50(%rbp),%rdi
break_deleg():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1974
}

static inline int break_deleg(struct inode *inode, unsigned int mode)
{
	if (inode->i_flock)
		return __break_lease(inode, mode, FL_DELEG);
    a35d:	mov    %eax,%r15d
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    a360:	callq  a365 <SyS_link+0xd5>
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4003
{
	int error = 0;
    a365:	test   %r15d,%r15d
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    a368:	movq   $0x0,-0x50(%rbp)
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4003
    a370:	je     a2d0 <SyS_link+0x40>
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    a376:	cmp    $0xffffff8c,%r15d
    a37a:	je     a3b0 <SyS_link+0x120>
    a37c:	movslq %r15d,%rax
path_put():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:488
 */
void path_put(const struct path *path)
{
	dput(path->dentry);
	mntput(path->mnt);
}
    a37f:	mov    -0x40(%rbp),%rdi
    a383:	mov    %rax,-0x58(%rbp)
    a387:	callq  a38c <SyS_link+0xfc>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:489
EXPORT_SYMBOL(path_put);
    a38c:	mov    -0x48(%rbp),%rdi
    a390:	callq  a395 <SyS_link+0x105>
    a395:	mov    -0x58(%rbp),%rax
SyS_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4016
	if (new_dir != old_dir) {
		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
		if (error)
			return error;
	}

    a399:	add    $0x40,%rsp
    a39d:	pop    %rbx
    a39e:	pop    %r12
    a3a0:	pop    %r13
    a3a2:	pop    %r14
    a3a4:	pop    %r15
    a3a6:	pop    %rbp
    a3a7:	retq   
    a3a8:	nopl   0x0(%rax,%rax,1)
retry_estale():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/namei.h:114
    a3b0:	test   %ebx,%ebx
    a3b2:	je     a3d8 <SyS_link+0x148>
    a3b4:	mov    $0xffffffffffffff8c,%rax
    a3bb:	jmp    a37f <SyS_link+0xef>
    a3bd:	nopl   (%rax)
break_deleg_wait():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1995
static inline int break_deleg_wait(struct inode **delegated_inode)
{
	int ret;

	ret = break_deleg(*delegated_inode, O_WRONLY);
	iput(*delegated_inode);
    a3c0:	callq  a3c5 <SyS_link+0x135>
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/fs.h:1996
	*delegated_inode = NULL;
    a3c5:	movq   $0x0,-0x50(%rbp)
    a3cd:	jmpq   a2d0 <SyS_link+0x40>
    a3d2:	nopw   0x0(%rax,%rax,1)
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4007
{
	int error = 0;
	struct inode *target = new_dentry->d_inode;
	unsigned max_links = new_dir->i_sb->s_max_links;

	/*
    a3d8:	mov    $0x20,%r12d
    a3de:	jmpq   a2d0 <SyS_link+0x40>
    a3e3:	nopl   0x0(%rax,%rax,1)
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:810
	struct inode *inode;

	if (!sysctl_protected_hardlinks)
		return 0;

	cred = current_cred();
    a3e8:	mov    0x0(%rip),%ecx        # a3ee <SyS_link+0x15e>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a3ee:	mov    -0x58(%rbp),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:810
	struct inode *inode;

	if (!sysctl_protected_hardlinks)
		return 0;

	cred = current_cred();
    a3f2:	test   %ecx,%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a3f4:	lea    0x4a8(%rax),%rdx
    a3fb:	mov    $0x0,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:810
	struct inode *inode;

	if (!sysctl_protected_hardlinks)
		return 0;

	cred = current_cred();
    a402:	jne    a418 <SyS_link+0x188>
    a404:	jmp    a473 <SyS_link+0x1e3>
    a406:	nopw   %cs:0x0(%rax,%rax,1)
my_strcmp_base():
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:30
	while (1) {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
    a410:	test   %cl,%cl
    a412:	je     a4d8 <SyS_link+0x248>
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:26

static int my_strcmp_base(const char *cs, const char *ct) {
	unsigned char c1, c2;

	while (1) {
		c1 = *cs++;
    a418:	add    $0x1,%rdx
    a41c:	movzbl -0x1(%rdx),%ecx
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:27
		c2 = *ct++;
    a420:	add    $0x1,%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/arch/x86/include/asm/current.h:28
		if (c1 != c2)
    a424:	cmp    -0x1(%rax),%cl
    a427:	je     a410 <SyS_link+0x180>
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a429:	mov    -0x68(%rbp),%rdx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:814
	 * otherwise, it must be a safe source.
    a42d:	mov    -0x40(%rbp),%rdi
    a431:	mov    0x4a0(%rdx),%rdx
    a438:	mov    0x30(%rdi),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:819
	 */
	if (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||
	    capable(CAP_FOWNER))
		return 0;

    a43c:	mov    0x4(%rax),%esi
    a43f:	cmp    %esi,0x1c(%rdx)
    a442:	je     a477 <SyS_link+0x1e7>
safe_hardlink_source():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:772
static bool safe_hardlink_source(struct inode *inode)
{
	umode_t mode = inode->i_mode;

	/* Special files should not get pinned to the filesystem. */
	if (!S_ISREG(mode))
    a444:	movzwl (%rax),%edx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:775
		return false;

	/* Setuid files should not get pinned to the filesystem. */
    a447:	mov    %edx,%ecx
    a449:	and    $0xf000,%cx
    a44e:	cmp    $0x8000,%cx
    a453:	je     a4f1 <SyS_link+0x261>
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:820
	 */
	if (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||
	    capable(CAP_FOWNER))
		return 0;

	audit_log_link_denied("linkat", link);
    a459:	mov    $0x3,%edi
    a45e:	mov    %r8,-0x60(%rbp)
    a462:	callq  a467 <SyS_link+0x1d7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:819
	 * otherwise, it must be a safe source.
	 */
	if (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||
	    capable(CAP_FOWNER))
		return 0;

    a467:	test   %al,%al
    a469:	mov    -0x60(%rbp),%r8
    a46d:	je     a52c <SyS_link+0x29c>
    a473:	mov    -0x40(%rbp),%rdi
SYSC_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3995
 *	   That works since everybody except rename does "lock parent, lookup,
 *	   lock child" and rename is under ->s_vfs_rename_mutex.
 *	   HOWEVER, it relies on the assumption that any object with ->lookup()
 *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 *	   we'd better make sure that there's no link(2) for them.
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
    a477:	lea    -0x38(%rbp),%rsi
    a47b:	mov    %r8,%rdx
    a47e:	mov    %r8,-0x60(%rbp)
    a482:	callq  a487 <SyS_link+0x1f7>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3996
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
    a487:	test   %eax,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3995
 *	   That works since everybody except rename does "lock parent, lookup,
 *	   lock child" and rename is under ->s_vfs_rename_mutex.
 *	   HOWEVER, it relies on the assumption that any object with ->lookup()
 *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 *	   we'd better make sure that there's no link(2) for them.
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
    a489:	mov    %eax,%r15d
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3996
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
    a48c:	mov    -0x60(%rbp),%r8
    a490:	jne    a32b <SyS_link+0x9b>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3998
 *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 *	   ->i_mutex on parents, which works but leads to some truly excessive
    a496:	mov    -0x30(%rbp),%rax
    a49a:	mov    -0x40(%rbp),%rdi
    a49e:	lea    -0x50(%rbp),%rcx
    a4a2:	mov    %r8,%rdx
    a4a5:	mov    %r8,-0x60(%rbp)
    a4a9:	mov    0x30(%rax),%rsi
    a4ad:	callq  a4b2 <SyS_link+0x222>
    a4b2:	mov    -0x60(%rbp),%r8
    a4b6:	mov    %eax,%r15d
    a4b9:	jmpq   a32b <SyS_link+0x9b>
    a4be:	xchg   %ax,%ax
SyS_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4016
	if (new_dir != old_dir) {
		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
		if (error)
			return error;
	}

    a4c0:	add    $0x40,%rsp
SYSC_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:3981
 * Problems:
 *	a) we can get into loop creation. Check is done in is_subdir().
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 *	   story.
    a4c4:	cltq   
SyS_link():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4016
	if (new_dir != old_dir) {
		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
		if (error)
			return error;
	}

    a4c6:	pop    %rbx
    a4c7:	pop    %r12
    a4c9:	pop    %r13
    a4cb:	pop    %r14
    a4cd:	pop    %r15
    a4cf:	pop    %rbp
    a4d0:	retq   
    a4d1:	nopl   0x0(%rax)
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:813
		return 0;

	cred = current_cred();
	inode = link->dentry->d_inode;

	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
    a4d8:	cmpb   $0x0,0x0(%rip)        # a4df <SyS_link+0x24f>
    a4df:	mov    0x0(%rip),%rdx        # a4e6 <SyS_link+0x256>
    a4e6:	jne    a42d <SyS_link+0x19d>
    a4ec:	jmpq   a429 <SyS_link+0x199>
safe_hardlink_source():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:779

	/* Setuid files should not get pinned to the filesystem. */
	if (mode & S_ISUID)
		return false;

	/* Executable setgid files should not get pinned to the filesystem. */
    a4f1:	test   $0x8,%dh
    a4f4:	jne    a459 <SyS_link+0x1c9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:783
	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
		return false;

	/* Hardlinking to unreadable or unwritable sources is dangerous. */
    a4fa:	and    $0x408,%dx
    a4ff:	cmp    $0x408,%dx
    a504:	je     a459 <SyS_link+0x1c9>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:787
	if (inode_permission(inode, MAY_READ | MAY_WRITE))
		return false;

	return true;
    a50a:	mov    $0x6,%esi
    a50f:	mov    %rax,%rdi
    a512:	mov    %r8,-0x60(%rbp)
    a516:	callq  a51b <SyS_link+0x28b>
    a51b:	test   %eax,%eax
    a51d:	mov    -0x60(%rbp),%r8
    a521:	je     a473 <SyS_link+0x1e3>
    a527:	jmpq   a459 <SyS_link+0x1c9>
may_linkat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:823
		return 0;

	audit_log_link_denied("linkat", link);
	return -EPERM;
}

    a52c:	lea    -0x48(%rbp),%rsi
    a530:	mov    $0x0,%rdi
    a537:	mov    %r8,-0x60(%rbp)
    a53b:	mov    $0xffffffff,%r15d
    a541:	callq  a546 <SyS_link+0x2b6>
    a546:	mov    -0x60(%rbp),%r8
    a54a:	jmpq   a32b <SyS_link+0x9b>
    a54f:	cltq   
    a551:	jmpq   a37f <SyS_link+0xef>
sys_link():
    a556:	nopw   %cs:0x0(%rax,%rax,1)

000000000000a560 <SyS_renameat>:
SyS_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4204
	trap = lock_rename(new_dir, old_dir);

	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
    a560:	callq  a565 <SyS_renameat+0x5>
    a565:	push   %rbp
    a566:	mov    %rsp,%rbp
    a569:	callq  62f0 <SYSC_renameat>
    a56e:	pop    %rbp
    a56f:	retq   

000000000000a570 <SyS_rename>:
SyS_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4319
	struct page *page;
	struct address_space *mapping = dentry->d_inode->i_mapping;
	page = read_mapping_page(mapping, 0, NULL);
	if (IS_ERR(page))
		return (char*)page;
	*ppage = page;
    a570:	callq  a575 <SyS_rename+0x5>
    a575:	push   %rbp
SyS_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4204
	trap = lock_rename(new_dir, old_dir);

	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
    a576:	mov    $0xffffff9c,%edx
SyS_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4319
	struct page *page;
	struct address_space *mapping = dentry->d_inode->i_mapping;
	page = read_mapping_page(mapping, 0, NULL);
	if (IS_ERR(page))
		return (char*)page;
	*ppage = page;
    a57b:	mov    %rsi,%rcx
SyS_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4204
	trap = lock_rename(new_dir, old_dir);

	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
    a57e:	mov    %rdi,%rsi
    a581:	mov    %edx,%edi
SyS_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4319
	struct page *page;
	struct address_space *mapping = dentry->d_inode->i_mapping;
	page = read_mapping_page(mapping, 0, NULL);
	if (IS_ERR(page))
		return (char*)page;
	*ppage = page;
    a583:	mov    %rsp,%rbp
SyS_renameat():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4204
	trap = lock_rename(new_dir, old_dir);

	old_dentry = lookup_hash(&oldnd);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
    a586:	callq  62f0 <SYSC_renameat>
SyS_rename():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:4319
	struct page *page;
	struct address_space *mapping = dentry->d_inode->i_mapping;
	page = read_mapping_page(mapping, 0, NULL);
	if (IS_ERR(page))
		return (char*)page;
	*ppage = page;
    a58b:	pop    %rbp
    a58c:	retq   

Disassembly of section .text.unlikely:

0000000000000000 <acl_by_type.part.10>:
acl_by_type.part.10():
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:100

extern struct posix_acl *get_posix_acl(struct inode *, int);
extern int set_posix_acl(struct inode *, int, struct posix_acl *);

#ifdef CONFIG_FS_POSIX_ACL
static inline struct posix_acl **acl_by_type(struct inode *inode, int type)
   0:	push   %rbp
   1:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/include/linux/posix_acl.h:108
	case ACL_TYPE_ACCESS:
		return &inode->i_acl;
	case ACL_TYPE_DEFAULT:
		return &inode->i_default_acl;
	default:
		BUG();
   4:	ud2    

0000000000000006 <lookup_slow>:
lookup_slow():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1463
	BUG_ON(nd->inode != parent->d_inode);

	mutex_lock(&parent->d_inode->i_mutex);
	dentry = __lookup_hash(&nd->last, parent, nd->flags);
	mutex_unlock(&parent->d_inode->i_mutex);
	if (IS_ERR(dentry))
   6:	callq  b <lookup_slow+0x5>
   b:	push   %rbp
   c:	mov    %rsp,%rbp
   f:	push   %r14
  11:	push   %r13
  13:	push   %r12
  15:	push   %rbx
  16:	mov    %rdi,%rbx
  19:	push   %rcx
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1467
		return PTR_ERR(dentry);
	path->mnt = nd->path.mnt;
	path->dentry = dentry;
	err = follow_managed(path, nd->flags);
  1a:	mov    0x8(%rdi),%r13
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1468
	if (unlikely(err < 0)) {
  1e:	mov    0x30(%rdi),%rdi
  22:	cmp    0x30(%r13),%rdi
  26:	je     2a <lookup_slow+0x24>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1468 (discriminator 1)
  28:	ud2    
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1470
		path_put_conditional(path, nd);
		return err;
  2a:	add    $0xa8,%rdi
  31:	mov    %rsi,%r12
  34:	callq  39 <lookup_slow+0x33>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1471
	}
  39:	mov    0x38(%rbx),%edx
  3c:	lea    0x10(%rbx),%rdi
  40:	mov    %r13,%rsi
  43:	callq  48 <lookup_slow+0x42>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1472
	if (err)
  48:	mov    0x30(%r13),%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1471
	path->dentry = dentry;
	err = follow_managed(path, nd->flags);
	if (unlikely(err < 0)) {
		path_put_conditional(path, nd);
		return err;
	}
  4c:	mov    %rax,%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1472
	if (err)
  4f:	add    $0xa8,%rdi
  56:	callq  5b <lookup_slow+0x55>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1473
		nd->flags |= LOOKUP_JUMPED;
  5b:	cmp    $0xfffffffffffff000,%r14
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1474
	return 0;
  62:	mov    %r14d,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1473
	if (unlikely(err < 0)) {
		path_put_conditional(path, nd);
		return err;
	}
	if (err)
		nd->flags |= LOOKUP_JUMPED;
  65:	ja     a3 <lookup_slow+0x9d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1475
	return 0;
}
  67:	mov    (%rbx),%rax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1476

  6a:	mov    %r14,0x8(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1477
static inline int may_lookup(struct nameidata *nd)
  6f:	mov    %r12,%rdi
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1475
		return err;
	}
	if (err)
		nd->flags |= LOOKUP_JUMPED;
	return 0;
}
  72:	mov    %rax,(%r12)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1477

static inline int may_lookup(struct nameidata *nd)
  76:	mov    0x38(%rbx),%esi
  79:	callq  7e <lookup_slow+0x78>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1478
{
  7e:	test   %eax,%eax
  80:	jns    95 <lookup_slow+0x8f>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1479
	if (nd->flags & LOOKUP_RCU) {
  82:	mov    %rbx,%rsi
  85:	mov    %r12,%rdi
  88:	mov    %eax,-0x24(%rbp)
  8b:	callq  90 <lookup_slow+0x8a>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1480
		int err = inode_permission(nd->inode, MAY_EXEC|MAY_NOT_BLOCK);
  90:	mov    -0x24(%rbp),%eax
  93:	jmp    a3 <lookup_slow+0x9d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1484
		if (err != -ECHILD)
			return err;
		if (unlazy_walk(nd, NULL))
			return -ECHILD;
  95:	mov    $0x0,%eax
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1482
static inline int may_lookup(struct nameidata *nd)
{
	if (nd->flags & LOOKUP_RCU) {
		int err = inode_permission(nd->inode, MAY_EXEC|MAY_NOT_BLOCK);
		if (err != -ECHILD)
			return err;
  9a:	je     a3 <lookup_slow+0x9d>
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1483
		if (unlazy_walk(nd, NULL))
  9c:	orl    $0x1000,0x38(%rbx)
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1485
			return -ECHILD;
	}
  a3:	pop    %rdx
  a4:	pop    %rbx
  a5:	pop    %r12
  a7:	pop    %r13
  a9:	pop    %r14
  ab:	pop    %rbp
  ac:	retq   

00000000000000ad <walk_component.part.19>:
walk_component.part.19():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1534
	 * "." and ".." are special - ".." especially so because it has
	 * to be able to know about the current root directory and
	 * parent relationships.
	 */
	if (unlikely(nd->last_type != LAST_NORM))
		return handle_dots(nd, nd->last_type);
  ad:	push   %rbp
  ae:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:1568

out_path_put:
	path_to_nameidata(path, nd);
out_err:
	terminate_walk(nd);
	return err;
  b1:	ud2    

00000000000000b3 <vfs_path_lookup.part.24>:
vfs_path_lookup.part.24():
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2055
		*path = nd.path;
	return err;
}

/*
 * Restricted form of lookup. Doesn't follow links, single-component only,
  b3:	callq  b8 <vfs_path_lookup.part.24+0x5>
  b8:	push   %rbp
  b9:	mov    %rsp,%rbp
/home/lookfiresu/Desktop/my_linux-3.13.0/fs/namei.c:2063
 */
static struct dentry *lookup_hash(struct nameidata *nd)
{
	return __lookup_hash(&nd->last, nd->path.dentry, nd->flags);
}

  bc:	ud2    

Disassembly of section .fixup:

0000000000000000 <.fixup>:
   0:	lea    (%rdi),%rcx
   3:	and    $0xfffffffffffffff8,%rcx
   7:	mov    (%rcx),%rdx
   a:	lea    (%rdi),%ecx
   c:	and    $0x7,%ecx
   f:	shl    $0x3,%ecx
  12:	shr    %cl,%rdx
  15:	jmpq   1a <.fixup+0x1a>
  1a:	lea    (%r12,%rsi,1),%rcx
  1e:	and    $0xfffffffffffffff8,%rcx
  22:	mov    (%rcx),%rdx
  25:	lea    (%r12,%rsi,1),%ecx
  29:	and    $0x7,%ecx
  2c:	shl    $0x3,%ecx
  2f:	shr    %cl,%rdx
  32:	jmpq   37 <__kstrtab_vfs_rmdir+0x1>
